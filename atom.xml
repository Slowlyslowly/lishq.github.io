<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>I code,I crash</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.tolvyou.cn/"/>
  <updated>2019-01-11T06:52:59.530Z</updated>
  <id>https://blog.tolvyou.cn/</id>
  
  <author>
    <name>足迹丶</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JMM内存模型</title>
    <link href="https://blog.tolvyou.cn/2019/01/11/JMM-Mind/"/>
    <id>https://blog.tolvyou.cn/2019/01/11/JMM-Mind/</id>
    <published>2019-01-11T06:49:24.000Z</published>
    <updated>2019-01-11T06:52:59.530Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>Java内存模型思维导图</p><a id="more"></a><p><img src="http://lishq.oss-cn-beijing.aliyuncs.com/github.io/JMM-Mind.png" alt="JMM"></p><p>原图地址：<a href="http://lishq.oss-cn-beijing.aliyuncs.com/github.io/JMM-Mind.png" target="_blank" rel="noopener">http://lishq.oss-cn-beijing.aliyuncs.com/github.io/JMM-Mind.png</a></p><p>参考：</p><blockquote><p>《并发编程的艺术》</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h3&gt;&lt;p&gt;Java内存模型思维导图&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://blog.tolvyou.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Git 实用指南</title>
    <link href="https://blog.tolvyou.cn/2019/01/10/git-review/"/>
    <id>https://blog.tolvyou.cn/2019/01/10/git-review/</id>
    <published>2019-01-10T06:06:56.000Z</published>
    <updated>2019-02-09T08:57:13.550Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>分布式 VCS 和中央式的区别在于，分布式 VCS 除了中央仓库之外，还有本地仓库：团队中每一个成员的机器上都有一份本地仓库，这个仓库里包含了所有的版本历史，或者换句话说，每个人在自己的机器上就可以提交代码、查看历史，而无需联网和中央仓库交互。</p><a id="more"></a><p><strong>优点</strong>：</p><ol><li>大多数的操作可以在本地进行，所以速度更快，而且由于无需联网，所以即使不在公司甚至没有在联网，你也可以提交代码、查看历史，从而极大地减小了开发者的网络条件和物理位置的限制。</li><li>由于可以提交到本地，所以你可以分步提交代码，把代码提交做得更细，而不是一个提交包含很多代码，难以 review 也难以回溯。</li></ol><p><strong>缺点</strong>：</p><ol><li>由于每一个机器都有完整的本地仓库，所以初次获取项目的时候会比较耗时。</li><li>由于每个机器都有完整的本地仓库，所以本地占用的存储比中央式 VCS 要高。</li></ol><h3 id="实用指南"><a href="#实用指南" class="headerlink" title="实用指南"></a>实用指南</h3><ol><li>把远程仓库取到本地</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone 远程仓库地址</span><br></pre></td></tr></table></figure><ol start="2"><li>把写完的代码提交</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">添加文件到暂存区</span><br><span class="line">git add . 【添加所有文件到暂存区，add也支持匹配表达式，如 git add *.java】</span><br><span class="line">git add 文件名 【添加指定文件到暂存区】</span><br><span class="line">git commit -m <span class="string">'你提交的信息'</span></span><br><span class="line"></span><br><span class="line">注意：直接执行 git commit 时可能弹出“输入提交的信息界面”，需要按一下 <span class="string">"i"</span>（小写）来切换到插入模式，然后就可以输入你的提交信息了；在输入完成后别按回车，而是要按 ESC 键返回到命令模式，然后连续输入两个大写的 <span class="string">"Z"</span>，就保存并退出了。</span><br><span class="line"></span><br><span class="line">在这个过程中，可以使用 git status 来随时查看工作目录的状态：</span><br><span class="line">每个文件有 <span class="string">"changed / unstaged"</span>（已修改）, <span class="string">"staged"</span>（已修改并暂存）, <span class="string">"commited"</span>（已提交） 三种状态，以及一种特殊状态 <span class="string">"untracked"</span>（未跟踪）提交一次或多次之后，把本地提交 push 到中央仓库（git push）</span><br><span class="line"></span><br><span class="line">注意：如果 push 失败，就用 pull（git pull） 把本地仓库的提交和中央仓库的提交进行合并，然后再 push 一次</span><br></pre></td></tr></table></figure><p><code>git log</code> 列出提交历史<br><code>git log -p</code> 查看详细历史<br><code>git log --stat</code> 查看简要统计<br><code>git show</code> 查看具体的 commit<br><code>git diff --staged</code> 比对暂存区和上一条提交<br><code>git diff</code> 比对工作目录和暂存区<br><code>git diff HEAD</code> 比对工作目录和上一条提交</p><ol start="3"><li>.gitignore——排除不想被管理的文件和目录</li></ol><p><img src="https://lishq.oss-cn-beijing.aliyuncs.com/github.io/.gitignore.png" alt="gitignore"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.gitignore，这个文本文件记录了所有你希望被 Git 忽略的目录和文件。</span><br><span class="line">文件中 # 打头的是注释文件，其他的都是对忽略文件的配置。</span><br><span class="line">匹配规则：https:<span class="comment">//git-scm.com/docs/gitignore</span></span><br></pre></td></tr></table></figure><ol start="4"><li>偏移符号</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">在 Git 中，有两个「偏移符号」： ^ 和 ~。</span><br><span class="line"></span><br><span class="line">^ 的用法：在 commit 的后面加一个或多个 ^ 号，可以把 commit 往回偏移，偏移的数量是 ^ 的数量。例如：master^ 表示 master 指向的 commit 之前的那个 commit； HEAD^^ 表示 HEAD 所指向的 commit 往前数两个 commit。</span><br><span class="line"></span><br><span class="line">~ 的用法：在 commit 的后面加上 ~ 号和一个数，可以把 commit 往回偏移，偏移的数量是 ~ 号后面的数。例如：HEAD~<span class="number">5</span> 表示 HEAD 指向的 commit往前数 <span class="number">5</span> 个 commit。</span><br></pre></td></tr></table></figure><h3 id="HEAD、master-与-branch"><a href="#HEAD、master-与-branch" class="headerlink" title="HEAD、master 与 branch"></a>HEAD、master 与 branch</h3><pre>1.HEAD2.master3.branch--------------------------------------------------------------------1.HEAD 是指向当前 commit 的引用，它具有唯一性，每个仓库中只有一个 HEAD。在每次提交时它都会自动向前移动到最新的 commit2.branch 是一类引用。HEAD 除了直接指向 commit，也可以通过指向某个 branch 来间接指向 commit。当 HEAD 指向一个 branch 时，commit 发生时，HEAD 会带着它所指向的 branch 一起移动。3.master 是 Git 中的默认 branch，它和其它 branch 的区别在于：    a.新建的仓库中的第一个 commit 会被 master 自动指向；    b.在 git clone 时，会自动 checkout 出 master。4.branch 的创建、切换、删除和提交：    a.创建 branch 的方式是 git branch 名称 或 git checkout -b 名称（创建后自动切换）；    b.切换的方式是 git checkout 名称；    c.push 的时候，如果当前分支是一个本地创建的分支，需要指定远程仓库名和分支名，用 git push origin branch_name 的格式，而不能只用 git push；      或者可以通过 git config 修改 push.default 来改变 push 时的行为逻辑。    d.git branch -a 看到所有分支5.branch 的删除：    a.git branch -d 名称。    b.git push origin -d branch_name # 用 -d 参数把远程仓库的 branch 也删了    c.git push origin :branch注意：1. HEAD 指向的 branch 不能删除。如果要删除 HEAD 指向的 branch，需要先用 checkout 把 HEAD 指向其他地方。2. 由于 Git 中的 branch 只是一个引用，所以删除 branch 的操作也只会删掉这个引用，并不会删除任何的 commit（一定时间后，会被 Git 的回收机制删除掉）3. 出于安全考虑，没有被合并到 master 过的 branch 在删除时会失败（如果你确认是要删除这个 branch，可以把 -d 改成 -D）</pre><h3 id="Merge"><a href="#Merge" class="headerlink" title="Merge"></a>Merge</h3><p>从两个 commit「分叉」的位置起，把目标 commit 的内容应用到当前 commit（HEAD 所指向的 commit），并生成一个新的 commit；</p><p><strong>适用场景</strong></p><ul><li><p>合并分支</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. 当一个 branch 的开发已经完成，需要把内容合并回去时，用 merge 来进行合并。</span><br><span class="line"><span class="number">2</span>. git merge branch1</span><br></pre></td></tr></table></figure></li><li><p>pull 的内部操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. pull 的实际操作其实是把远端仓库的内容用 fetch 取下来之后，用 merge 来合并。</span><br></pre></td></tr></table></figure></li></ul><p><strong>冲突</strong></p><ol><li>解决冲突后手动 commit</li><li>git merge –abort 【放弃解决冲突，取消 merge】</li></ol><h3 id="Feature-Branching：工作流"><a href="#Feature-Branching：工作流" class="headerlink" title="Feature Branching：工作流"></a>Feature Branching：工作流</h3><ul><li>任何新的功能（feature）或 bug 修复全都新建一个 branch 来写；</li><li>branch 写完后，合并到 master，然后删掉这个 branch。</li></ul><h3 id="Git合并特定commits-到另一个分支"><a href="#Git合并特定commits-到另一个分支" class="headerlink" title="Git合并特定commits 到另一个分支"></a>Git合并特定commits 到另一个分支</h3><ul><li>合并某个分支上的单个commit</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. git log 查看想选择哪些commits进行合并</span><br><span class="line">eg:dd2e86 - <span class="number">946992</span> -<span class="number">9143</span>a9 - a6fd86 - <span class="number">5</span>a6057</span><br><span class="line"><span class="number">2</span>.需要将<span class="number">62</span>ecb3 合并到master，而不合并feature上的其他commits</span><br><span class="line">git checkout master</span><br><span class="line">git cherry-pick <span class="number">62</span>ecb3</span><br></pre></td></tr></table></figure><ul><li>合并某个分支上的一系列commits</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">假设需要合并feature分支的commit dd2e86 ~a6fd86 到master分支。</span><br><span class="line"></span><br><span class="line">首先需要基于feature创建一个新的分支，并指明新分支的最后一个commit：</span><br><span class="line">git checkout -b newbranch a6fd86</span><br><span class="line">然后，rebase 这个新分支的 commit 到master，dd2e86^ 指明你想从哪个特定的commit开始。</span><br><span class="line">git rebase --onto master dd2e86^</span><br></pre></td></tr></table></figure><h3 id="rebase——在新位置重新提交"><a href="#rebase——在新位置重新提交" class="headerlink" title="rebase——在新位置重新提交"></a>rebase——在新位置重新提交</h3><p><code>git rebase</code> 目标基础点</p><pre>场景：我在主分支commit a时新建了新分支，此时开始分叉，分叉后我又在主分支改了东西commit b，此时我后悔了，我不该在commit a时分叉的。因为commit b的东西我新分支也需要，此时用衍合（rebase）。就等于我丢弃原分叉，在commit b重新分叉（原分叉的改动内容当然也是带上的，没有丢）注意：为了避免和远端仓库发生冲突，一般不要从 master 向其他 branch 执行 rebase 操作。而如果是 master 以外的 branch 之间的 rebase（比如 branch1 和 branch2 之间），就不必这么多费一步，直接 rebase 就好。</pre><h3 id="其它特性"><a href="#其它特性" class="headerlink" title="其它特性"></a>其它特性</h3><pre>git commit --amend 对最新一条 commit 进行修正，生成一条新的commit替换了原commit。注意：commit之后，push之前使用有效;只针对目前最新的 commit 有效git reset --hard 目标commit  撤销最新的提交撤销过往的提交1. 用 git rebase -i 在编辑界面中删除想撤销的 commits2. 用 git rebase --onto 在 rebase 命令中直接剔除想撤销的 commitsgit push origin branch1 -f  忽略冲突，强制 pushgit revert HEAD^ commit 撤销提交reset 的三种参数：1. --hard：重置位置的同时，清空工作目录的所有改动；2. --soft：重置位置的同时，保留工作目录和暂存区的内容，并把重置 HEAD 的位置所导致的新的文件差异放进暂存区。3. --mixed（默认）：重置位置的同时，保留工作目录的内容，并清空暂存区。场景：当你手头有一件临时工作要做，需要把工作目录暂时清理干净，那么你可以：git stash -u （扔）git stash pop （取）恢复已删除的 branch1. git reflog 查看一下 HEAD 的移动历史2. git checkout c08de9a3. git checkout -b branch1注意：不再被引用直接或间接指向的 commits 会在一定时间后被 Git 回收tag：不可移动的 branch，tag 被用来在关键版本处打标记用。git config： Git 的设置 https://git-scm.com/docs/git-configcherry-pick：把选中的 commits 一个个合并进来</pre><p>参考：</p><blockquote><p><a href="https://git-scm.com/docs" target="_blank" rel="noopener">https://git-scm.com/docs</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;分布式 VCS 和中央式的区别在于，分布式 VCS 除了中央仓库之外，还有本地仓库：团队中每一个成员的机器上都有一份本地仓库，这个仓库里包含了所有的版本历史，或者换句话说，每个人在自己的机器上就可以提交代码、查看历史，而无需联网和中央仓库交互。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Git" scheme="https://blog.tolvyou.cn/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Java线上问题调查常用命令</title>
    <link href="https://blog.tolvyou.cn/2019/01/08/java-devops-review/"/>
    <id>https://blog.tolvyou.cn/2019/01/08/java-devops-review/</id>
    <published>2019-01-08T11:05:13.000Z</published>
    <updated>2019-01-08T13:08:37.619Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>Java性能排查基本操作，本文的排查环境是 Linux。</p><a id="more"></a><h3 id="Java性能相关"><a href="#Java性能相关" class="headerlink" title="Java性能相关"></a>Java性能相关</h3><ul><li><p>gc(健康度) ， 堆栈(gc不掉的数据)， 线程(cpu竞争)</p>  <pre>查看jvm进程  root用户登陆，jps（JVM Process Status Tools）  查看堆内对象是否正常  jmap -histo 61367 | more  jstat（JVM Statistics Monitoring Tools）            jstat主要用于监控虚拟机的各种运行状态信息，如类的装载、内存、垃圾回收、JIT编译器等            jstat [option vmid [interval [s|ms] [vount] ] ]            参数interval和count分别表示查询间隔和查询次数，如每1毫秒查询一次进程20445的垃圾回收情况，监控20次，命令如下所示：                 jstat –gc 20445 1 20                 --------------------------------------------------------------                 Option    Function                 -class    监视类的装载、卸载数量以及类的装载总空间和耗费时间等                 -gc  监视Java堆，包含eden、2个survivor区、old区和永久带区域的容量、已用空间、GC时间合计等信息                 -gccapcity     监视内容与-gc相同，但输出主要关注Java区域用到的最大和最小空间                 -gcutil   监视内容与-gc相同，但输出主要关注已使用空间占总空间的百分比                 -gccause  与-gcutil输出信息相同，额外输出导致上次GC产生的原因                 -gcnew    监控新生代的GC情况                 -gcnewcapacity 与-gcnew监控信息相同，输出主要关注使用到的最大和最小空间                 -gcold    监控老生代的GC情况                 -gcoldcapacity 与-gcold监控信息相同，输出主要关注使用到的最大和最小空间                 -gcpermcapacity     输出永久带用到的最大和最小空间                 -compiler 输出JIT编译器编译过的方法、耗时信息                 -printcompilation   输出已经被JIT编译的方法  example:                 jstat -gcutil jpsPid 1000 10  --------------------------------------------------------------                      top                           H show all thread by process                           P 按cpu占用排序                           M 按内存占用排序                           1 显示cpu个数  --------------------------------------------------------------  查找占用cpu高的java线程:            top -H -p javaId                        // 找出java thread id            printf '0x%x\n' java thread id          // 转16进制            jstack  jstack用于JVM当前时刻的线程快照，又称threaddump文件，它是JVM当前每一条线程正在执行的堆栈信息的集合。生成线程快照的主要目的是为了定位线程出现长时间停顿的原因，如线程死锁、死循环、请求外部时长过长导致线程停顿的原因。通过jstack我们就可以知道哪些进程在后台做些什么？在等待什么资源等！            jstack [option] vmid                 --------------------------------------------------------------                 Option    Function                 -F   当正常输出的请求不响应时强制输出线程堆栈                 -l   除堆栈信息外，显示关于锁的附加信息                 -m   显示native方法的堆栈信息                 示例：jstack -l 20445  jstack Pid > jstack.log 打印堆栈   java堆的经验值:            Space                                Option                             Occupancy Factor            Java heap                           -Xmx                               3x or 4x old generation space occupancy after full garbage collection            Perm Generation                -MaxPermSize                1.2 or 1.5x perm generation space occupancy after full garbage collection            Young Generation              -Xmn                               1x or 1.5x young generation space occupancy after full garbage collection            Old Generation                                                           2x or 3x old generation space occupancy after full garbage collection</pre></li></ul><hr><h3 id="优化思路"><a href="#优化思路" class="headerlink" title="优化思路"></a>优化思路</h3><ol><li>调整分区的比例；</li><li>尽可能的让gc发生在年轻代中；</li><li>年轻代的大小，起始值，最大值，设置一样；</li><li>设置他进阶的生命周期和进阶允许大小设置。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;Java性能排查基本操作，本文的排查环境是 Linux。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Devops" scheme="https://blog.tolvyou.cn/tags/Devops/"/>
    
  </entry>
  
  <entry>
    <title>常用运维工具汇总</title>
    <link href="https://blog.tolvyou.cn/2019/01/08/devops-review/"/>
    <id>https://blog.tolvyou.cn/2019/01/08/devops-review/</id>
    <published>2019-01-08T10:55:19.000Z</published>
    <updated>2019-01-08T13:07:45.847Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h3><p>中间件</p><p>运维工具</p><p>性能测试中使用的其他命令</p><p>进程/内存的运维，监控工具</p><a id="more"></a><h3 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h3><p><strong>redis</strong><br>常用命令：info，monitor，slowlog, redis-benchmark, scan<br>more：<a href="http://www.redis.cn/commands/info.html" target="_blank" rel="noopener">http://www.redis.cn/commands/info.html</a></p><p><strong>elasticsearch</strong><br>_plugin/head：概览，索引，基本查询，符合查询</p><p>_plugin/kopf：内存大小，磁盘占用，索引管理。</p><h3 id="进程-内存"><a href="#进程-内存" class="headerlink" title="进程/内存"></a>进程/内存</h3><p>jvisualvm：实时查看堆栈信息，需要添加jmx启动参数</p><h3 id="性能测试中使用的其他命令"><a href="#性能测试中使用的其他命令" class="headerlink" title="性能测试中使用的其他命令"></a>性能测试中使用的其他命令</h3><p>查看网络流量：cat /proc/net/dev</p><p>查看系统平均负载：cat /proc/loadavg</p><p>查看系统内存情况：cat /proc/meminfo</p><p>查看CPU的利用率：cat /proc/stat</p><p>端口相连接的机器数：<br>    ss -nao | grep 18090 | wc -l<br>    netstat -anpt | grep 18090 | wc -l</p><p>查看java线程：<br>    ps -eLf | grep java | wc -l</p><h3 id="运维工具"><a href="#运维工具" class="headerlink" title="运维工具"></a>运维工具</h3><p>cat：代码层面的监控。</p><p>netdata：Linux系统性能实时监控平台</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;大纲&quot;&gt;&lt;a href=&quot;#大纲&quot; class=&quot;headerlink&quot; title=&quot;大纲&quot;&gt;&lt;/a&gt;大纲&lt;/h3&gt;&lt;p&gt;中间件&lt;/p&gt;
&lt;p&gt;运维工具&lt;/p&gt;
&lt;p&gt;性能测试中使用的其他命令&lt;/p&gt;
&lt;p&gt;进程/内存的运维，监控工具&lt;/p&gt;
    
    </summary>
    
    
      <category term="Devops" scheme="https://blog.tolvyou.cn/tags/Devops/"/>
    
  </entry>
  
  <entry>
    <title>Intellij idea 常用快捷键</title>
    <link href="https://blog.tolvyou.cn/2019/01/08/intellij-IDEA-shortcut/"/>
    <id>https://blog.tolvyou.cn/2019/01/08/intellij-IDEA-shortcut/</id>
    <published>2019-01-08T08:59:54.000Z</published>
    <updated>2019-01-08T13:07:18.569Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>去年开始改用 IDEA，在使用 IDEA 时不想重头记一套新的快捷键，快捷键设置以 eclipse 为主。<br>整理一些自己常用的快捷键，同时下面为 windows 环境下配置</p><a id="more"></a><h3 id="CTRL系列"><a href="#CTRL系列" class="headerlink" title="CTRL系列"></a>CTRL系列</h3><p><code>CTRL + H</code> 快速打开搜索框</p><p><code>CTRL + O</code> 打开大纲视图</p><p><code>CTRL + W</code> 关闭当前窗口</p><p><code>CTRL + T</code> 查看接口实现类</p><p><code>CTRL + E</code> 最近打开过的文件</p><p><code>CTRL + SHIFT + [</code> 切换不同项目</p><p><code>CTRL + SHIFT + ALT + T</code> 调出重构菜单</p><p><code>CTRL + SHIFT + M</code> 自动声明变量类型</p><p><code>CTRL + SHIFT + R</code> 快速打开资源</p><p><code>CTRL + SHIFT + T</code> 快速打开类</p><p><code>CTRL + B</code> 强制刷新</p><p><code>CTRL + SHIFT + A</code> 快捷键查询</p><p><code>CTRL + Page Up</code> 上一窗口</p><p><code>CTRL + Page Down</code> 下一窗口</p><p><code>CTRL + SHIFT + F12</code> 切换全屏幕</p><p><code>CTRL + SHIFT + X</code> 大小写转换</p><h3 id="ALT系列"><a href="#ALT系列" class="headerlink" title="ALT系列"></a>ALT系列</h3><p><code>ALT + F1</code> 神器，按了此组合，接下来你可以跳转到项目结构，导航栏，甚至可以在Finder中定位该文件</p><p><code>ALT + /</code> 智能提醒神器，当你不知道要写什么内容的时候，试试这个组合吧，或许他会给你带来灵感</p><p><code>ALT + +/-</code> 鼠标定位到之前编辑的位置/之后编辑的位置</p><p><code>ALT + Enter</code> 改进或优化代码构造</p><p><code>ALT + SHIFT + R</code> 重命名</p><p><code>ALT + SHIFT + O</code> 高亮变量</p><p><code>ALT + SHIFT + M</code> 抽取方法</p><p><code>ALT + F12</code> 打开/关闭终端（较常用）</p><h3 id="结构类"><a href="#结构类" class="headerlink" title="结构类"></a>结构类</h3><p><code>CTRL + ALT + SHIFT + U</code> 根据上下文展示UML图</p><p><code>ALT + 类</code> 出现放大镜</p><p><code>F4 + 类</code> 查看该类源码</p><h3 id="for循环系列"><a href="#for循环系列" class="headerlink" title="for循环系列"></a>for循环系列</h3><p><code>it**</code> 生成for循环代码块</p><h3 id="测试用例系列"><a href="#测试用例系列" class="headerlink" title="测试用例系列"></a>测试用例系列</h3><p><code>CTRL + SHIFT + S</code> 创建当前类或接口的测试类</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h3&gt;&lt;p&gt;去年开始改用 IDEA，在使用 IDEA 时不想重头记一套新的快捷键，快捷键设置以 eclipse 为主。&lt;br&gt;整理一些自己常用的快捷键，同时下面为 windows 环境下配置&lt;/p&gt;
    
    </summary>
    
    
      <category term="Devops" scheme="https://blog.tolvyou.cn/tags/Devops/"/>
    
  </entry>
  
  <entry>
    <title>Spring常用扩展接口总结</title>
    <link href="https://blog.tolvyou.cn/2018/12/05/spring-extend-review/"/>
    <id>https://blog.tolvyou.cn/2018/12/05/spring-extend-review/</id>
    <published>2018-12-05T07:06:56.000Z</published>
    <updated>2018-12-05T10:10:58.505Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>Spring源码学习笔记，Spring常用扩展接口总结，错误之处欢迎指正，共同学习</p><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>Spring 提供了大量的可扩展接口。因此了解这些接口对于我们定制自己的功能，熟练使用 Spring 非常重要。</p><a id="more"></a><h3 id="常用扩展"><a href="#常用扩展" class="headerlink" title="常用扩展"></a>常用扩展</h3><pre>1.FactroyBean2.BeanPostProcess3.InstantiationAwareBeanPostProcessor4.BeanNameAware、ApplicationContextAware 和 BeanFactoryAware5.BeanFactoryPostProcessor6.InitialingBean、DisposableBean--------------------------------------------------------------------1.FactroyBean 个性化地定制自己想要实例化出来的Bean，比如AOP的实现    a.getObject() 方法是最重要的，控制Bean的实例化过程    b.getObjectType()方法获取接口返回的实例的class    c.isSingleton()方法获取该Bean是否为一个单例的Bean2.BeanPostProcess 在每个Bean初始化前后做操作。3.InstantiationAwareBeanPostProcessor 在Bean实例化前后做一些操作。    a.实例化在初始化之前执行    b.通常不会直接实现 InstantiationAwareBeanPostProcessor 接口，而是会采用继承 InstantiationAwareBeanPostProcessorAdapter 这个抽象类的方式来使用。4.BeanNameAware、ApplicationContextAware 和 BeanFactoryAware 针对bean工厂，可以获取上下文，可以获取当前bena的id。    a.从上下文获取bean时使用，可以让实现类或子接口的实现类注入ApplicationContext，获取上下文的信息。很多项目中都使用此接口做了Spring的工具类。5.BeanFactoryPostProcessor Spring允许在Bean创建之前，读取Bean的元属性，并根据自己的需求对元属性进行改变，比如将Bean的scope从singleton改变为prototype。    a.BeanFactoryPostProcessor的执行优先级高于BeanPostProcessor    b.BeanFactoryPostProcessor的 postProcessBeanFactory() 方法只会执行一次，携带了每个bean的基本信息6.InitialingBean 在属性设置完毕后做一些自定义操作 DisposableBean 在关闭容器前做一些操作。    a.InitialingBean 实现 afterPropertiesSet()方法    b.DisposableBean 实现 destory() 方法</pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过了解 Spring 的扩展接口，我们可以基于 Spring 做一些除了简单注入之外的定制功能。同时，我们也发现 Spring 的扩展性非常高，符合设计模式中的开闭原则，对修改关闭，对扩展开放。我们在以后的开发工作中也可以借鉴 Spring 的设计思想，让程序更加优雅。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;Spring源码学习笔记，Spring常用扩展接口总结，错误之处欢迎指正，共同学习&lt;/p&gt;

&lt;h3 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h3&gt;&lt;p&gt;Spring 提供了大量的可扩展接口。因此了解这些接口对于我们定制自己的功能，熟练使用 Spring 非常重要。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Spring" scheme="https://blog.tolvyou.cn/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring源码学习笔记之AOP</title>
    <link href="https://blog.tolvyou.cn/2018/12/04/spring-deep-aop/"/>
    <id>https://blog.tolvyou.cn/2018/12/04/spring-deep-aop/</id>
    <published>2018-12-04T10:27:32.000Z</published>
    <updated>2018-12-05T10:10:46.435Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>Spring源码学习笔记，Spring-AOP实现大致过程，错误之处欢迎指正，共同学习</p><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>类应该是纯净的，不应含有与本身无关的逻辑。单一职责原则。</p><a id="more"></a><h3 id="Spring-AOP-接口设计"><a href="#Spring-AOP-接口设计" class="headerlink" title="Spring AOP 接口设计"></a>Spring AOP 接口设计</h3><p><strong>AOP概念总结</strong></p><pre>1.Advice2.Pointcut3.Advisor4.Joinpoint5.Aspect--------------------------------------------------------------------1.Advice（增强，定义在链接点做什么）    a.Before Advice（执行前增强，实现MethodBeforeAdvice接口）    b.Around Advice（环绕增强，可以实现以上三种功能，实现MethodInterceptor接口）    c.After Running Advice（方法执行后增强，实现AfterRunningAdvice接口）    d.After Throw Advice（抛出异常后增强，实现ThrowsAdvice接口）    e.Introduction（引入，特殊的advice，普通advice都是作用在pointcut指定的方法上，而introduction作用在类上，可以添加类中没有的方法和属性）2.Pointcut（连接点，定义匹配哪些方法）3.Advisor（通知器，将 Advice 和 PointCut 结合起来，目的是为了将advice与pointcut解耦和）    a.PointcutAdvisor（一个advice和一个pointcut，作用在某个连接点上）    b.IntroductionAdvisor（作用于类上）4.Joinpoint（连接点，所有可能的需要注入切面的地方。如方法前后、类初始化、属性初始化前后等等。pointcut只能选择连接点切入）    a.通过joinPoint 参数，可以获取目标对象的信息,如类名称,方法参数,方法名称等5.Aspect（切面，切面是切点和增强的集合，一般单独作为一个类。通知和切点共同定义了关于切面的全部内容，它是什么时候，在何时和何处完成功能。）</pre><p>Spring AOP 的底层实现有两种可选，一种是 JDK 动态代理，一种是 CGLib 动态代理。先说下结论，如果要代理的 target 有接口，则默认采用 JDK 动态代理。如果没有，则采用 CGLib 动态代理。当然也可以强制指定使用 CGLib 动态代理。方法:</p><ul><li>XML配置AOP: &lt;aop:config proxy-target-class=”true”&gt;</li><li>注解配置AOP: &lt;aop:aspectj-autoproxy proxy-target-class=”true”/&gt;</li></ul><p>CGLib 创建代理的速度比较慢，但创建代理后运行的速度却非常快，而 JDK 动态代理正好相反。如果在运行的时候不断地用 CGLib 去创建代理，系统的性能会大打折扣，所以建议一般在系统初始化的时候用 CGLib 去创建代理，并放入 Spring 的 ApplicationContext 中以备后用。</p><h3 id="源码开始"><a href="#源码开始" class="headerlink" title="源码开始"></a>源码开始</h3><p>Spring 使用 AOP 可以通过XML配置和注解两种方式，但是底层原理都是一样的。Spring 是否支持注解的 AOP 是由一个配置文件控制的，也就是&lt;aop:aspectj-autoproxy /&gt;，当在配置文件中声明了这句配置的时候，Spring就会支持注解的 AOP，那么我们分析就从这句注解开始</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AopNamespaceHandler.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// In 2.0 XSD as well as in 2.1 XSD.</span></span><br><span class="line">registerBeanDefinitionParser(<span class="string">"config"</span>, <span class="keyword">new</span> ConfigBeanDefinitionParser());</span><br><span class="line">registerBeanDefinitionParser(<span class="string">"aspectj-autoproxy"</span>, <span class="keyword">new</span> AspectJAutoProxyBeanDefinitionParser());</span><br><span class="line">registerBeanDefinitionDecorator(<span class="string">"scoped-proxy"</span>, <span class="keyword">new</span> ScopedProxyBeanDefinitionDecorator());</span><br><span class="line"></span><br><span class="line"><span class="comment">// Only in 2.0 XSD: moved to context namespace as of 2.1</span></span><br><span class="line">registerBeanDefinitionParser(<span class="string">"spring-configured"</span>, <span class="keyword">new</span> SpringConfiguredBeanDefinitionParser());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册AnnotationAutoProxyCreator</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">parse</span><span class="params">(Element element, ParserContext parserContext)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 注册AspectJAnnotationAutoProxyCreator</span></span><br><span class="line">AopNamespaceUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(parserContext, element);</span><br><span class="line"><span class="comment">// 对于注解中子类的处理</span></span><br><span class="line">extendBeanDefinition(element, parserContext);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerAspectJAnnotationAutoProxyCreatorIfNecessary</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">ParserContext parserContext, Element sourceElement)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">BeanDefinition beanDefinition = AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(</span><br><span class="line">parserContext.getRegistry(), parserContext.extractSource(sourceElement));</span><br><span class="line"><span class="comment">// 对于 proxy-target-class 属性的处理</span></span><br><span class="line">useClassProxyingIfNecessary(parserContext.getRegistry(), sourceElement);</span><br><span class="line"><span class="comment">// 注册组件并通知，便于监听器做进一步处理</span></span><br><span class="line">registerComponentIfNecessary(beanDefinition, parserContext);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BeanDefinition <span class="title">registerAspectJAnnotationAutoProxyCreatorIfNecessary</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">BeanDefinitionRegistry registry, @Nullable Object source)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> registerOrEscalateApcAsRequired(AnnotationAwareAspectJAutoProxyCreator.class, registry, source);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AnnotationAwareAspectJAutoProxyCreator"><a href="#AnnotationAwareAspectJAutoProxyCreator" class="headerlink" title="AnnotationAwareAspectJAutoProxyCreator"></a>AnnotationAwareAspectJAutoProxyCreator</h3><p><img src="http://lishq.oss-cn-beijing.aliyuncs.com/github.io/AnnotationAwareAspectJAutoProxyCreator.png" alt=""></p><p>在类的层级中，我们看到 AnnotationAwareAspectJAutoProxyCreator 实现了 BeanPostProcessor 接口，而实现 BeanPostProcessor 后，当 Spring 加载这个 Bean 时会在实例化前调用其 postProcessAfterInitialization 方法，而我们对于 AOP 逻辑的分析也由此开始。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类 AbstractAutoProxyCreator</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(@Nullable Object bean, String beanName)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// 根据给定的 bean 的class和name构建出个key</span></span><br><span class="line">Object cacheKey = getCacheKey(bean.getClass(), beanName);</span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">this</span>.earlyProxyReferences.contains(cacheKey)) &#123;</span><br><span class="line"><span class="comment">// 如果它适合被代理，则需要封装指定bean</span></span><br><span class="line"><span class="keyword">return</span> wrapIfNecessary(bean, beanName, cacheKey);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">wrapIfNecessary</span><span class="params">(Object bean, String beanName, Object cacheKey)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 如果已经处理过</span></span><br><span class="line"><span class="keyword">if</span> (StringUtils.hasLength(beanName) &amp;&amp; <span class="keyword">this</span>.targetSourcedBeans.contains(beanName)) &#123;</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 无需增强</span></span><br><span class="line"><span class="keyword">if</span> (Boolean.FALSE.equals(<span class="keyword">this</span>.advisedBeans.get(cacheKey))) &#123;</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 给定的bean类是否代表一个基础设施类，基础设施类不应代理，或者配置了指定bean不需要自动代理</span></span><br><span class="line"><span class="keyword">if</span> (isInfrastructureClass(bean.getClass()) || shouldSkip(bean.getClass(), beanName)) &#123;</span><br><span class="line"><span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create proxy if we have advice.</span></span><br><span class="line"><span class="comment">// 如果存在增强方法则创建代理</span></span><br><span class="line">Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, <span class="keyword">null</span>);</span><br><span class="line"><span class="comment">// 如果获取到了增强则需要针对增强创建代理</span></span><br><span class="line"><span class="keyword">if</span> (specificInterceptors != DO_NOT_PROXY) &#123;</span><br><span class="line"><span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.TRUE);</span><br><span class="line"><span class="comment">// 创建代理</span></span><br><span class="line">Object proxy = createProxy(</span><br><span class="line">bean.getClass(), beanName, specificInterceptors, <span class="keyword">new</span> SingletonTargetSource(bean));</span><br><span class="line"><span class="keyword">this</span>.proxyTypes.put(cacheKey, proxy.getClass());</span><br><span class="line"><span class="keyword">return</span> proxy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数中我们已经看到了代理创建的雏形。当然，真正开始之前还需要经过一些判断，比如是否已经处理过或者是否是需要跳过的bean,而真正创建代理的代码是从 getAdvicesAndAdvisorsForBean 开始的。<br>创建代理主要包含了两个步骤：</p><ol><li>获取增强方法或者增强器</li><li>根据获取的增强进行代理</li></ol><h3 id="获取增强方法的实现"><a href="#获取增强方法的实现" class="headerlink" title="获取增强方法的实现"></a>获取增强方法的实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object[] getAdvicesAndAdvisorsForBean(</span><br><span class="line">Class&lt;?&gt; beanClass, String beanName, <span class="meta">@Nullable</span> TargetSource targetSource) &#123;</span><br><span class="line"></span><br><span class="line">List&lt;Advisor&gt; advisors = findEligibleAdvisors(beanClass, beanName);</span><br><span class="line"><span class="keyword">if</span> (advisors.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">return</span> DO_NOT_PROXY;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> advisors.toArray();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DO_NOT_PROXY = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;Advisor&gt; <span class="title">findEligibleAdvisors</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 获取所有的增强</span></span><br><span class="line">List&lt;Advisor&gt; candidateAdvisors = findCandidateAdvisors();</span><br><span class="line"><span class="comment">// 寻找所有的增强中适用于bean的增强并应用</span></span><br><span class="line">List&lt;Advisor&gt; eligibleAdvisors = findAdvisorsThatCanApply(candidateAdvisors, beanClass, beanName);</span><br><span class="line">extendAdvisors(eligibleAdvisors);</span><br><span class="line"><span class="keyword">if</span> (!eligibleAdvisors.isEmpty()) &#123;</span><br><span class="line">eligibleAdvisors = sortAdvisors(eligibleAdvisors);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> eligibleAdvisors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>获取增强器</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;Advisor&gt; <span class="title">findCandidateAdvisors</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// Add all the Spring advisors found according to superclass rules.</span></span><br><span class="line"><span class="comment">// 当使用注解方式配置 AOP 的时候并不是丢弃了对XML配置的支持</span></span><br><span class="line"><span class="comment">// 在这里调用父类方法加载配置文件中的 AOP 声明</span></span><br><span class="line">List&lt;Advisor&gt; advisors = <span class="keyword">super</span>.findCandidateAdvisors();</span><br><span class="line"><span class="comment">// Build Advisors for all AspectJ aspects in the bean factory.</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.aspectJAdvisorsBuilder != <span class="keyword">null</span>) &#123;</span><br><span class="line">advisors.addAll(<span class="keyword">this</span>.aspectJAdvisorsBuilder.buildAspectJAdvisors());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> advisors;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Advisor&gt; <span class="title">buildAspectJAdvisors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">List&lt;String&gt; aspectNames = <span class="keyword">this</span>.aspectBeanNames;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (aspectNames == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">aspectNames = <span class="keyword">this</span>.aspectBeanNames;</span><br><span class="line"><span class="keyword">if</span> (aspectNames == <span class="keyword">null</span>) &#123;</span><br><span class="line">List&lt;Advisor&gt; advisors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">aspectNames = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">// 获取所有的 beanName</span></span><br><span class="line">String[] beanNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(</span><br><span class="line"><span class="keyword">this</span>.beanFactory, Object.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line"><span class="comment">// 循环所有的 beanName 找出对应的增强方法</span></span><br><span class="line"><span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line"><span class="comment">// 略过不合法的bean</span></span><br><span class="line"><span class="keyword">if</span> (!isEligibleBean(beanName)) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// We must be careful not to instantiate beans eagerly as in this case they</span></span><br><span class="line"><span class="comment">// would be cached by the Spring container but would not have been weaved.</span></span><br><span class="line"><span class="comment">// 获取对应的bean的实例</span></span><br><span class="line">Class&lt;?&gt; beanType = <span class="keyword">this</span>.beanFactory.getType(beanName);</span><br><span class="line"><span class="keyword">if</span> (beanType == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果存在 Aspect 注解</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.advisorFactory.isAspect(beanType)) &#123;</span><br><span class="line">aspectNames.add(beanName);</span><br><span class="line">AspectMetadata amd = <span class="keyword">new</span> AspectMetadata(beanType, beanName);</span><br><span class="line"><span class="keyword">if</span> (amd.getAjType().getPerClause().getKind() == PerClauseKind.SINGLETON) &#123;</span><br><span class="line">MetadataAwareAspectInstanceFactory factory =</span><br><span class="line"><span class="keyword">new</span> BeanFactoryAspectInstanceFactory(<span class="keyword">this</span>.beanFactory, beanName);</span><br><span class="line"><span class="comment">// 解析标记AspectJ注解中的增强方法</span></span><br><span class="line">List&lt;Advisor&gt; classAdvisors = <span class="keyword">this</span>.advisorFactory.getAdvisors(factory);</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.beanFactory.isSingleton(beanName)) &#123;</span><br><span class="line"><span class="keyword">this</span>.advisorsCache.put(beanName, classAdvisors);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">this</span>.aspectFactoryCache.put(beanName, factory);</span><br><span class="line">&#125;</span><br><span class="line">advisors.addAll(classAdvisors);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>.aspectBeanNames = aspectNames;</span><br><span class="line"><span class="keyword">return</span> advisors;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (aspectNames.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 记录在缓存中</span></span><br><span class="line">List&lt;Advisor&gt; advisors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (String aspectName : aspectNames) &#123;</span><br><span class="line">List&lt;Advisor&gt; cachedAdvisors = <span class="keyword">this</span>.advisorsCache.get(aspectName);</span><br><span class="line"><span class="keyword">if</span> (cachedAdvisors != <span class="keyword">null</span>) &#123;</span><br><span class="line">advisors.addAll(cachedAdvisors);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">MetadataAwareAspectInstanceFactory factory = <span class="keyword">this</span>.aspectFactoryCache.get(aspectName);</span><br><span class="line">advisors.addAll(<span class="keyword">this</span>.advisorFactory.getAdvisors(factory));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> advisors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol><li>获取所有 beanName，这一步骤中所有在 beanFactory 中注册的Bean都会被提取出来</li><li>遍历所有 beanName，并找出声明 AspectJ 注解的类，进行进一步的处理</li><li>对标记为 AspectJ 注解的类进行增强器的提取</li><li>将提取结果加入缓存</li></ol><p><strong>寻找匹配的增强器</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;Advisor&gt; <span class="title">findAdvisorsThatCanApply</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">List&lt;Advisor&gt; candidateAdvisors, Class&lt;?&gt; beanClass, String beanName)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">ProxyCreationContext.setCurrentProxiedBeanName(beanName);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 过滤已经得到的Advisors</span></span><br><span class="line"><span class="keyword">return</span> AopUtils.findAdvisorsThatCanApply(candidateAdvisors, beanClass);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">ProxyCreationContext.setCurrentProxiedBeanName(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Advisor&gt; <span class="title">findAdvisorsThatCanApply</span><span class="params">(List&lt;Advisor&gt; candidateAdvisors, Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (candidateAdvisors.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">return</span> candidateAdvisors;</span><br><span class="line">&#125;</span><br><span class="line">List&lt;Advisor&gt; eligibleAdvisors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">// 首次处理引介增强</span></span><br><span class="line"><span class="keyword">for</span> (Advisor candidate : candidateAdvisors) &#123;</span><br><span class="line"><span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> IntroductionAdvisor &amp;&amp; canApply(candidate, clazz)) &#123;</span><br><span class="line">eligibleAdvisors.add(candidate);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">boolean</span> hasIntroductions = !eligibleAdvisors.isEmpty();</span><br><span class="line"><span class="keyword">for</span> (Advisor candidate : candidateAdvisors) &#123;</span><br><span class="line"><span class="comment">// 引介增强已经处理</span></span><br><span class="line"><span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> IntroductionAdvisor) &#123;</span><br><span class="line"><span class="comment">// already processed</span></span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 对于普通bean的处理</span></span><br><span class="line"><span class="keyword">if</span> (canApply(candidate, clazz, hasIntroductions)) &#123;</span><br><span class="line">eligibleAdvisors.add(candidate);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> eligibleAdvisors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>findAdvisorsThatCanApply 函数的主要功能是寻找所有增强器中适用于当前 class 的增强器。引介增强与普通的增强处理是不一样的，所以分开处理。而对于真正的匹配在 canApply 中实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">canApply</span><span class="params">(Pointcut pc, Class&lt;?&gt; targetClass, <span class="keyword">boolean</span> hasIntroductions)</span> </span>&#123;</span><br><span class="line">Assert.notNull(pc, <span class="string">"Pointcut must not be null"</span>);</span><br><span class="line"><span class="keyword">if</span> (!pc.getClassFilter().matches(targetClass)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MethodMatcher methodMatcher = pc.getMethodMatcher();</span><br><span class="line"><span class="keyword">if</span> (methodMatcher == MethodMatcher.TRUE) &#123;</span><br><span class="line"><span class="comment">// No need to iterate the methods if we're matching any method anyway...</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">IntroductionAwareMethodMatcher introductionAwareMethodMatcher = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (methodMatcher <span class="keyword">instanceof</span> IntroductionAwareMethodMatcher) &#123;</span><br><span class="line">introductionAwareMethodMatcher = (IntroductionAwareMethodMatcher) methodMatcher;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Set&lt;Class&lt;?&gt;&gt; classes = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line"><span class="keyword">if</span> (!Proxy.isProxyClass(targetClass)) &#123;</span><br><span class="line">classes.add(ClassUtils.getUserClass(targetClass));</span><br><span class="line">&#125;</span><br><span class="line">classes.addAll(ClassUtils.getAllInterfacesForClassAsSet(targetClass));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Class&lt;?&gt; clazz : classes) &#123;</span><br><span class="line">Method[] methods = ReflectionUtils.getAllDeclaredMethods(clazz);</span><br><span class="line"><span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line"><span class="keyword">if</span> (introductionAwareMethodMatcher != <span class="keyword">null</span> ?</span><br><span class="line">introductionAwareMethodMatcher.matches(method, targetClass, hasIntroductions) :</span><br><span class="line">methodMatcher.matches(method, targetClass)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建代理"><a href="#创建代理" class="headerlink" title="创建代理"></a>创建代理</h3><p>在获取了所有对应bean的增强器后，便可以进行代理的创建了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">createProxy</span><span class="params">(Class&lt;?&gt; beanClass, @Nullable String beanName,</span></span></span><br><span class="line"><span class="function"><span class="params">@Nullable Object[] specificInterceptors, TargetSource targetSource)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.beanFactory <span class="keyword">instanceof</span> ConfigurableListableBeanFactory) &#123;</span><br><span class="line">AutoProxyUtils.exposeTargetClass((ConfigurableListableBeanFactory) <span class="keyword">this</span>.beanFactory, beanName, beanClass);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ProxyFactory proxyFactory = <span class="keyword">new</span> ProxyFactory();</span><br><span class="line"><span class="comment">// 获取当前类中相关属性</span></span><br><span class="line">proxyFactory.copyFrom(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 决定对于给定的bean是否应该使用TargetClass而不是它的接口代理</span></span><br><span class="line"><span class="keyword">if</span> (!proxyFactory.isProxyTargetClass()) &#123;</span><br><span class="line"><span class="keyword">if</span> (shouldProxyTargetClass(beanClass, beanName)) &#123;</span><br><span class="line">proxyFactory.setProxyTargetClass(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 添加代理接口</span></span><br><span class="line">evaluateProxyInterfaces(beanClass, proxyFactory);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Advisor[] advisors = buildAdvisors(beanName, specificInterceptors);</span><br><span class="line"><span class="comment">// 加入增强器</span></span><br><span class="line">proxyFactory.addAdvisors(advisors);</span><br><span class="line"><span class="comment">// 设置要代理的类</span></span><br><span class="line">proxyFactory.setTargetSource(targetSource);</span><br><span class="line"><span class="comment">// 定制代理</span></span><br><span class="line">customizeProxyFactory(proxyFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用来控制代理工厂被配置之后，是否还允许修改通知</span></span><br><span class="line"><span class="comment">// 缺省值为false(代理被配置之后，不允许修改)</span></span><br><span class="line"><span class="comment">// private boolean freezeProxy = false;</span></span><br><span class="line">proxyFactory.setFrozen(<span class="keyword">this</span>.freezeProxy);</span><br><span class="line"><span class="keyword">if</span> (advisorsPreFiltered()) &#123;</span><br><span class="line">proxyFactory.setPreFiltered(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> proxyFactory.getProxy(getProxyClassLoader());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于代理类的创建及处理，Spring委托给了ProxyFactory去处理，此函数中主要是对ProxyFactory的初始化操作，进而对真正的创建代理做准备。</p><ol><li>获取当前类中的属性</li><li>添加代理接口</li><li>封装Advisor并加入到ProxyFactory中</li><li>设置要代理的类</li><li>为子类提供了定制的函数 customizeProxyFactory，子类可以在此函数中进行对 ProxyFactory的进一步封装</li><li>进行获取代理操作</li></ol><p>将拦截器封装为增强器<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Advisor[] buildAdvisors(<span class="meta">@Nullable</span> String beanName, <span class="meta">@Nullable</span> Object[] specificInterceptors) &#123;</span><br><span class="line"><span class="comment">// 解析注册的所有InterceptorName</span></span><br><span class="line">Advisor[] commonInterceptors = resolveInterceptorNames();</span><br><span class="line"></span><br><span class="line">List&lt;Object&gt; allInterceptors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">if</span> (specificInterceptors != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// 加入拦截器</span></span><br><span class="line">allInterceptors.addAll(Arrays.asList(specificInterceptors));</span><br><span class="line"><span class="keyword">if</span> (commonInterceptors.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.applyCommonInterceptorsFirst) &#123;</span><br><span class="line">allInterceptors.addAll(<span class="number">0</span>, Arrays.asList(commonInterceptors));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">allInterceptors.addAll(Arrays.asList(commonInterceptors));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">Advisor[] advisors = <span class="keyword">new</span> Advisor[allInterceptors.size()];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; allInterceptors.size(); i++) &#123;</span><br><span class="line"><span class="comment">// 拦截器进行封装转化为Advisor</span></span><br><span class="line">advisors[i] = <span class="keyword">this</span>.advisorAdapterRegistry.wrap(allInterceptors.get(i));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> advisors;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Advisor <span class="title">wrap</span><span class="params">(Object adviceObject)</span> <span class="keyword">throws</span> UnknownAdviceTypeException </span>&#123;</span><br><span class="line"><span class="comment">// 如果要封装的对象本身就是Advisor直接返回</span></span><br><span class="line"><span class="keyword">if</span> (adviceObject <span class="keyword">instanceof</span> Advisor) &#123;</span><br><span class="line"><span class="keyword">return</span> (Advisor) adviceObject;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 封装方法只对 Advisor 和 Advice 两种类型的数据有效</span></span><br><span class="line"><span class="keyword">if</span> (!(adviceObject <span class="keyword">instanceof</span> Advice)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> UnknownAdviceTypeException(adviceObject);</span><br><span class="line">&#125;</span><br><span class="line">Advice advice = (Advice) adviceObject;</span><br><span class="line"><span class="keyword">if</span> (advice <span class="keyword">instanceof</span> MethodInterceptor) &#123;</span><br><span class="line"><span class="comment">// So well-known it doesn't even need an adapter.</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> DefaultPointcutAdvisor(advice);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (AdvisorAdapter adapter : <span class="keyword">this</span>.adapters) &#123;</span><br><span class="line"><span class="comment">// Check that it is supported.</span></span><br><span class="line"><span class="keyword">if</span> (adapter.supportsAdvice(advice)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> DefaultPointcutAdvisor(advice);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> UnknownAdviceTypeException(advice);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>由于Spring中涉及过多的拦截器、增强器、增强方法等方式来对逻辑进行增强，所以非常有必要统一封装成Advisor来进行代理的创建</p><h3 id="代理的创建与获取"><a href="#代理的创建与获取" class="headerlink" title="代理的创建与获取"></a>代理的创建与获取</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">(@Nullable ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> createAopProxy().getProxy(classLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>创建代理</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> AopProxy <span class="title">createAopProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">this</span>.active) &#123;</span><br><span class="line">activate();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建代理</span></span><br><span class="line"><span class="keyword">return</span> getAopProxyFactory().createAopProxy(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> AopProxy <span class="title">createAopProxy</span><span class="params">(AdvisedSupport config)</span> <span class="keyword">throws</span> AopConfigException </span>&#123;</span><br><span class="line"><span class="comment">// 首先考虑使用cglib来实现代理对象，当然如果同时目标对象不是接口的实现类的话</span></span><br><span class="line"><span class="keyword">if</span> (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) &#123;</span><br><span class="line">Class&lt;?&gt; targetClass = config.getTargetClass();</span><br><span class="line"><span class="keyword">if</span> (targetClass == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">"TargetSource cannot determine target class: "</span> +</span><br><span class="line"><span class="string">"Either an interface or a target is required for proxy creation."</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ObjenesisCglibAopProxy(config);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 这里使用JDK来生成Proxy,返回JDK类型的AopProxy</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">optimize控制cglib代理是否使用优化</span><br><span class="line">ProxyTargetClass：<span class="keyword">true</span>时，目标类本身被代理，而不是目标类的接口。即使用cglib代理</span><br><span class="line">hasNoUserSuppliedProxyInterfaces： 是否存在代理接口</span><br></pre></td></tr></table></figure></p><p>如果目标对象实现了接口，默认情况下会采用JDK的动态代理实现AOP<br>如果目标对象实现了接口，可以强制使用CGLIB实现AOP<br>如果目标对象没有实现了接口，必须采用CGLIB库，Spring会自动在JDK动态代理和CGLIB之间转换</p><p>区别：<br>JDK动态代理只能对实现了接口的类生成代理，而不能针对类<br>CGLIB是针对类实现代理，主要是对指定的类生成一个子类，覆盖其中的方法，因为是继承，所以该类或方法最好不要声明成final</p><p><strong>获取代理</strong><br>两种代理方式的使用方法</p><ol><li>JDK代理使用示例<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 业务接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">request</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 业务接口实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"real subject execute request"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建自定义的 InvocationHandler，用于对接口提供的方法进行增强</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdkDynamicProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//目标对象</span></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JdkDynamicProxy</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行目标对象的方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"before"</span>);</span><br><span class="line">        Object result = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            result = method.invoke(target,args);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            System.err.println(<span class="string">"ex:"</span>+e.getMessage());</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"after"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取目标对象的代理对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// System.getProperties().put("sun.misc.ProxyGenerator.saveGeneratedFiles", "true");</span></span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(),</span><br><span class="line">                target.getClass().getInterfaces(),<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实例化目标对象</span></span><br><span class="line">    Subject subject = <span class="keyword">new</span> RealSubject();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实例化 InvocationHandler</span></span><br><span class="line">    JdkProxySubject jdkProxySubject = <span class="keyword">new</span> JdkProxySubject(subject);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据目标对象生成代理对象</span></span><br><span class="line">    Subject proxy = (Subject) jdkProxySubject.getProxy();</span><br><span class="line">    proxy.request();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>执行结果如下</p><pre>beforereal subject execute requestafter</pre><p>那么，我们看看Spring中的JDK代理实现。继续之前的跟踪，到达JdkDynamicAopProxy.getProxy()<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">(@Nullable ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">"Creating JDK dynamic proxy: "</span> + <span class="keyword">this</span>.advised.getTargetSource());</span><br><span class="line">&#125;</span><br><span class="line">Class&lt;?&gt;[] proxiedInterfaces = AopProxyUtils.completeProxiedInterfaces(<span class="keyword">this</span>.advised, <span class="keyword">true</span>);</span><br><span class="line">findDefinedEqualsAndHashCodeMethods(proxiedInterfaces);</span><br><span class="line"><span class="keyword">return</span> Proxy.newProxyInstance(classLoader, proxiedInterfaces, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">MethodInvocation invocation;</span><br><span class="line">Object oldProxy = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">boolean</span> setProxyContext = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">TargetSource targetSource = <span class="keyword">this</span>.advised.targetSource;</span><br><span class="line">Object target = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">this</span>.equalsDefined &amp;&amp; AopUtils.isEqualsMethod(method)) &#123;</span><br><span class="line"><span class="comment">// The target does not implement the equals(Object) method itself.</span></span><br><span class="line"><span class="keyword">return</span> equals(args[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.hashCodeDefined &amp;&amp; AopUtils.isHashCodeMethod(method)) &#123;</span><br><span class="line"><span class="comment">// The target does not implement the hashCode() method itself.</span></span><br><span class="line"><span class="keyword">return</span> hashCode();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (method.getDeclaringClass() == DecoratingProxy.class) &#123;</span><br><span class="line"><span class="comment">// There is only getDecoratedClass() declared -&gt; dispatch to proxy config.</span></span><br><span class="line"><span class="keyword">return</span> AopProxyUtils.ultimateTargetClass(<span class="keyword">this</span>.advised);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.advised.opaque &amp;&amp; method.getDeclaringClass().isInterface() &amp;&amp;</span><br><span class="line">method.getDeclaringClass().isAssignableFrom(Advised.class)) &#123;</span><br><span class="line"><span class="comment">// Service invocations on ProxyConfig with the proxy config...</span></span><br><span class="line"><span class="comment">// 通过反射机制来对目标对象的方法进行调用</span></span><br><span class="line"><span class="keyword">return</span> AopUtils.invokeJoinpointUsingReflection(<span class="keyword">this</span>.advised, method, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Object retVal;</span><br><span class="line"><span class="comment">// 有时候目标对象内部的自我调用将无法实施切面中的增强，则需要通过此属性暴露代理</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.advised.exposeProxy) &#123;</span><br><span class="line"><span class="comment">// Make invocation available if necessary.</span></span><br><span class="line">oldProxy = AopContext.setCurrentProxy(proxy);</span><br><span class="line">setProxyContext = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get as late as possible to minimize the time we "own" the target,</span></span><br><span class="line"><span class="comment">// in case it comes from a pool.</span></span><br><span class="line"><span class="comment">// 这里是得到目标对象的地方，当然这个目标对象可能来自于一个实例池，或一个简单的Java对象</span></span><br><span class="line">target = targetSource.getTarget();</span><br><span class="line">Class&lt;?&gt; targetClass = (target != <span class="keyword">null</span> ? target.getClass() : <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get the interception chain for this method.</span></span><br><span class="line"><span class="comment">// 获取当前方法的拦截器链</span></span><br><span class="line">List&lt;Object&gt; chain = <span class="keyword">this</span>.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check whether we have any advice. If we don't, we can fallback on direct</span></span><br><span class="line"><span class="comment">// reflective invocation of the target, and avoid creating a MethodInvocation.</span></span><br><span class="line"><span class="comment">// 如果没有设定拦截器，那么我们就直接调用目标的对应方法</span></span><br><span class="line"><span class="keyword">if</span> (chain.isEmpty()) &#123;</span><br><span class="line"><span class="comment">// We can skip creating a MethodInvocation: just invoke the target directly</span></span><br><span class="line"><span class="comment">// Note that the final invoker must be an InvokerInterceptor so we know it does</span></span><br><span class="line"><span class="comment">// nothing but a reflective operation on the target, and no hot swapping or fancy proxying.</span></span><br><span class="line">Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);</span><br><span class="line">retVal = AopUtils.invokeJoinpointUsingReflection(target, method, argsToUse);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// We need to create a method invocation...</span></span><br><span class="line"><span class="comment">// 如果有拦截器的设定，那么需要调用拦截器之后才调用目标对象的相应方法</span></span><br><span class="line"><span class="comment">// 这里通过构造一个 ReflectiveMethodInvocation 来实现，封装拦截器</span></span><br><span class="line"><span class="comment">// 以便于使用其 proceed 进行链接表用拦截器</span></span><br><span class="line">invocation = <span class="keyword">new</span> ReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain);</span><br><span class="line"><span class="comment">// Proceed to the joinpoint through the interceptor chain.</span></span><br><span class="line"><span class="comment">// 执行拦截器链</span></span><br><span class="line">retVal = invocation.proceed();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Massage return value if necessary.</span></span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>invoke 函数最主要的工作就是创建了一个拦截器链，并使用 ReflectiveMethodInvocation 类进行了类的封装，而在 ReflectiveMethodInvocation 类的 proceed 方法中实现了拦截器的逐一调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对拦截器的调用处理</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">proceed</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"><span class="comment">//We start with an index of -1 and increment early.</span></span><br><span class="line"><span class="comment">// 执行完所有增强后执行切点方法</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.currentInterceptorIndex == <span class="keyword">this</span>.interceptorsAndDynamicMethodMatchers.size() - <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> invokeJoinpoint();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取下一个要拦截的拦截器</span></span><br><span class="line">Object interceptorOrInterceptionAdvice =</span><br><span class="line"><span class="keyword">this</span>.interceptorsAndDynamicMethodMatchers.get(++<span class="keyword">this</span>.currentInterceptorIndex);</span><br><span class="line"><span class="keyword">if</span> (interceptorOrInterceptionAdvice <span class="keyword">instanceof</span> InterceptorAndDynamicMethodMatcher) &#123;</span><br><span class="line"><span class="comment">// Evaluate dynamic method matcher here: static part will already have</span></span><br><span class="line"><span class="comment">// been evaluated and found to match.</span></span><br><span class="line"><span class="comment">// 这里获得相应的拦截器,如果拦截器可以匹配上的话,那就调用拦截器的invoke方法</span></span><br><span class="line">InterceptorAndDynamicMethodMatcher dm =</span><br><span class="line">(InterceptorAndDynamicMethodMatcher) interceptorOrInterceptionAdvice;</span><br><span class="line">Class&lt;?&gt; targetClass = (<span class="keyword">this</span>.targetClass != <span class="keyword">null</span> ? <span class="keyword">this</span>.targetClass : <span class="keyword">this</span>.method.getDeclaringClass());</span><br><span class="line"><span class="keyword">if</span> (dm.methodMatcher.matches(<span class="keyword">this</span>.method, targetClass, <span class="keyword">this</span>.arguments)) &#123;</span><br><span class="line"><span class="keyword">return</span> dm.interceptor.invoke(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Dynamic matching failed.</span></span><br><span class="line"><span class="comment">// Skip this interceptor and invoke the next in the chain.</span></span><br><span class="line"><span class="comment">// 如果拦截器匹配不上,那就调用下一个拦截器</span></span><br><span class="line"><span class="keyword">return</span> proceed();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// It's an interceptor, so we just invoke it: The pointcut will have</span></span><br><span class="line"><span class="comment">// been evaluated statically before this object was constructed.</span></span><br><span class="line"><span class="comment">// 将 this 作为参数传递以保证当前实例中调用链的执行</span></span><br><span class="line"><span class="keyword">return</span> ((MethodInterceptor) interceptorOrInterceptionAdvice).invoke(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>CGLIB使用示例</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodInterceptorDemo</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"before in cglib"</span>);</span><br><span class="line">        Object result = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            result = proxy.invokeSuper(obj, args);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            System.err.println(<span class="string">"get ex:"</span>+e.getMessage());</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"after in cglib"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">    enhancer.setSuperclass(RealSubject.class);</span><br><span class="line">    enhancer.setCallback(<span class="keyword">new</span> MethodInterceptorDemo());</span><br><span class="line">    Subject subject = (Subject) enhancer.create();</span><br><span class="line">    subject.hello();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果如下</p><pre>before in cglibhelloafter in cglib</pre><p>CglibAopProxy 有众多内部类。这些内部类是为了实现 Cglib 的各种回调而实现的。主要实现了 MethodInterceptor 接口，Callback 接口，Joinpoint 接口，Invocation 接口等待，总之是实现了Spring 的 cglib 模块的各种接口。</p><p>实现与 JDK 方式实现代理中的 invoke 方法大同小异，都是首先构造链，然后封装此链进行串联调用。<br>区别是JDK中直接构造 ReflectiveMethodInvocation，而在cglib中使用 CglibMethodInvocation。CglibMethodInvocation 继承自 ReflectiveMethodInvocation，但是proceed方法没有重写</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过源码分析我们知道注解方式的底层是通过继承 ProxyProcessorSupport 来实现的，并且扩展的是 BenaPostProcessor 接口，通过Spring 的扩展接口，能够对特定的Bean进行增强。而 AOP 正是通过这种方式实现的。我们也可以通过扩展 Spring 的某些接口来增强我们需要的 Bean 的某些功能。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;Spring源码学习笔记，Spring-AOP实现大致过程，错误之处欢迎指正，共同学习&lt;/p&gt;

&lt;h3 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h3&gt;&lt;p&gt;类应该是纯净的，不应含有与本身无关的逻辑。单一职责原则。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Spring" scheme="https://blog.tolvyou.cn/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring源码学习笔记之IOC</title>
    <link href="https://blog.tolvyou.cn/2018/11/28/spring-deep-ioc/"/>
    <id>https://blog.tolvyou.cn/2018/11/28/spring-deep-ioc/</id>
    <published>2018-11-28T01:10:37.000Z</published>
    <updated>2018-12-05T02:53:26.039Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>Spring源码学习笔记，Spring-Ioc源码浅析，错误之处欢迎指正，共同学习</p><p></p><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>Ioc 容器的核心是控制对象的创建，销毁，管理对象之间的依赖关系，并由IOC容器完成对象的注入。我们只需要关注业务逻辑。</p><h3 id="IOC-原理"><a href="#IOC-原理" class="headerlink" title="IOC 原理"></a>IOC 原理</h3><p>Ioc 底层通过 java 反射创建实例，利用set方法对实例的依赖进行注入。</p><a id="more"></a><h3 id="搭建源码研究环境"><a href="#搭建源码研究环境" class="headerlink" title="搭建源码研究环境"></a>搭建源码研究环境</h3><ol><li>直接从 spirng 的 github 上 clone spring-framework 源码，部署项目</li></ol><p><img src="http://lishq.oss-cn-beijing.aliyuncs.com/github.io/spring-framework.png" alt=""></p><ol start="2"><li>debug 启动该项目，运行main方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">ApplicationContext ctx = <span class="keyword">new</span> FileSystemXmlApplicationContext(</span><br><span class="line"><span class="string">"spring-context/src/test/resources/org/springframework/context/lishqTest/beans.xml"</span>);</span><br><span class="line">System.out.println(<span class="string">"begin..."</span>);</span><br><span class="line">System.out.println(<span class="string">"number : "</span> + ctx.getBeanDefinitionCount());</span><br><span class="line">System.out.println(((TestBean) ctx.getBean(<span class="string">"beans1.bean1"</span>)).getName());</span><br><span class="line">System.out.println(((TestBean) ctx.getBean(<span class="string">"beans1.bean2"</span>)).getObjRef());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><pre>new Instance......whennew Instance......whenbegin...number : 2lishq-toSpringtest.lishqTest.TestBean@329302</pre><h3 id="Spring的IOC实现"><a href="#Spring的IOC实现" class="headerlink" title="Spring的IOC实现"></a>Spring的IOC实现</h3><ol><li>资源(Resource)定位.</li><li>BeanDefinition 的载入和 BeanFactory 的构造.</li><li>向 IOC 容器(BeanFactory)注册 BeanDefinition.</li><li>根据 lazy-init 属性初始化 Bean 实例和依赖注入.</li></ol><p><strong>IOC中几个重要概念及其关系</strong></p><pre>1.BeanFactory2.ApplicationContext3.BeanDefinition--------------------------------------------------------------------1.BeanFactory是IOC容器的接口定义，定义了容器的基本功能    a.获取Bean    b.注册Bean    c.more2.ApplicationContext 则是扩展后的容器，它通过继承 MessageSource，ResourceLoader，ApplicationEventPublisher 接口，在BeanFactory 简单IOC容器的基础上添加了许多对高级容器的支持。    a.MessageSource 接口，提供了消息处理的功能。在web项目上用于国际化    b.ResourceLoader 是资源加载接口，用于对不同的Resource进行加载。Resource getResource(String location)通过一个标识加载资源信息。    c.ApplicationEventPublisher 提供了发布 event 组件的接口。spring 的事件体系 和Spring内置事件处理3.BeanDefinition 可简单理解为容器实现依赖反转功能的核心数据结构    a.Spring 通过定义 BeanDefinition 来管理基于Spring 的应用中的各种对象以及他们直接的相互依赖关系    b.BeanDefinition 抽象了我们对 Bean的定义，是让容器起作用的主要数据类型</pre><h3 id="Spring-Bean-解析过程"><a href="#Spring-Bean-解析过程" class="headerlink" title="Spring Bean 解析过程"></a>Spring Bean 解析过程</h3><p><img src="http://lishq.oss-cn-beijing.aliyuncs.com/github.io/Spring%20Bean%20%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B.png" alt=""></p><p>Spring Bean 解析过程如上图所示，下面我们据此逻辑debug源码</p><p><strong>FileSystemXmlApplicationContext</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FileSystemXmlApplicationContext 的构造方法，默认刷新为true</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FileSystemXmlApplicationContext</span><span class="params">(String configLocation)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"><span class="keyword">this</span>(<span class="keyword">new</span> String[] &#123;configLocation&#125;, <span class="keyword">true</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该构造器做了2件事情，一是设置配置文件，二是刷新容器。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FileSystemXmlApplicationContext</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">String[] configLocations, <span class="keyword">boolean</span> refresh, @Nullable ApplicationContext parent)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">super</span>(parent);</span><br><span class="line">setConfigLocations(configLocations);</span><br><span class="line"><span class="keyword">if</span> (refresh) &#123;</span><br><span class="line">refresh();<span class="comment">// 初始化容器核心方法</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>AbstractApplicationContext.refresh()</strong></p><ul><li>构建BeanFactory，以便于产生所需的 Bean</li><li>注册可能感兴趣的事件</li><li>创建Bean实例对象</li><li>触发被监听的事件</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 整个IOC容器初始化的所有逻辑</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line"><span class="comment">// 为刷新准备应用上下文</span></span><br><span class="line">prepareRefresh();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 告诉子类刷新内部bean工厂，即在子类中启动refreshBeanFactory()的地方----创建bean工厂，根据配置文件生成bean定义</span></span><br><span class="line">ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 准备在此上下文中使用的bean工厂。</span></span><br><span class="line">prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 允许在上下文子类中对bean工厂进行后处理。</span></span><br><span class="line">postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用在上下文中注册为bean的工厂处理器。</span></span><br><span class="line">invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册拦截bean创建的bean处理器。</span></span><br><span class="line">registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化此上下文的消息源。</span></span><br><span class="line">initMessageSource();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化上下文中的事件机制</span></span><br><span class="line">initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化特定上下文子类中的其他特殊bean。</span></span><br><span class="line">onRefresh();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查监听Bean并且将这些Bean向容器注册</span></span><br><span class="line">registerListeners();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化所有的非延迟加载的单例类</span></span><br><span class="line">finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">//  发布容器事件，结束refresh过程</span></span><br><span class="line">finishRefresh();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">logger.warn(<span class="string">"Exception encountered during context initialization - "</span> +</span><br><span class="line"><span class="string">"cancelling refresh attempt: "</span> + ex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为防止bean资源占用，在异常处理中，销毁已经在前面过程中生成的单件bean</span></span><br><span class="line">destroyBeans();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重置“active”标志</span></span><br><span class="line">cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将异常传播给调用方。</span></span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">// Reset common introspection caches in Spring's core, since we</span></span><br><span class="line"><span class="comment">// might not ever need metadata for singleton beans anymore...</span></span><br><span class="line">resetCommonCaches();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Spring 通过 refresh 操作重建了 ApplicaitonContext，在这个过程中同时也构建了默认的 BeanFactory 以及加载了 BeanDefinition。AbstractApplicationContext类在refresh()方法中调用了obtainFreshBeanFactory， 此方法主要负责重建BeanFactory以及加载BeanDefinition。 下面我们对此方法进行简要分析：</p><p><strong>obtainFreshBeanFactory</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (hasBeanFactory()) &#123;</span><br><span class="line"><span class="comment">// 如果存在就销毁</span></span><br><span class="line">destroyBeans();</span><br><span class="line">closeBeanFactory();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">DefaultListableBeanFactory beanFactory = createBeanFactory();</span><br><span class="line"><span class="comment">// 设置序列化</span></span><br><span class="line">beanFactory.setSerializationId(getId());</span><br><span class="line"><span class="comment">// 定制的BeanFactory</span></span><br><span class="line">customizeBeanFactory(beanFactory);</span><br><span class="line"><span class="comment">// 使用BeanFactory加载bean定义 AbstractXmlApplicationContext</span></span><br><span class="line">loadBeanDefinitions(beanFactory);</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>.beanFactoryMonitor) &#123;</span><br><span class="line"><span class="keyword">this</span>.beanFactory = beanFactory;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(<span class="string">"I/O error parsing bean definition source for "</span> + getDisplayName(), ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到BeanFactory的创建过程，首先判断是否已存在BeanFactory，如果已存在则销毁：<br>destroyBeans() 清除Bean引用的缓存<br>closeBeanFactory() 释放已创建的BeanFactory</p><p>其次调用 createBeanFactory 建立默认的 BeanFactoryDefaultListableBeanFactory，也就是 BeanFactory的默认实现；</p><p>当BeanFactory建立好之后，进行一项简单的配置 customizeBeanFactory()，以决定在加载 BeanDefinition 的过程中是否允许循环引用以及是否允许对已有BeanDefinition进行覆写。</p><p>然后我们看到一个很感兴趣的方法，就是 loadBeanDefinitions(beanFactory)，看名字是加载 Definitions，Definition 是核心之一，代表着 IOC 中的基本数据结构。该方法也是个抽象方法，默认实现是 AbstractXmlApplicationContext ，我们看看该方法实现：</p><p><strong>loadBeanDefinitions</strong></p><ol><li>XmlBeanDefinitionReader loadBeanDefinitions();</li><li>doLoadBeanDefinitions();</li><li>registerBeanDefinitions();</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 首先创建一个 XmlBeanDefinitionReader ，用于读取XML中配置，设置了环境，资源加载器，</span></span><br><span class="line"><span class="comment"> * 最后初始化，加载。可以说，该方法将加载，解析Bean的定义，也就是把用户定义的数据结构</span></span><br><span class="line"><span class="comment"> * 转化为 IOC容器中的特定数据结构。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(DefaultListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException, IOException </span>&#123;</span><br><span class="line"><span class="comment">// 为给定的BeanFactory创建一个新的XmlBeanDefinitionReader</span></span><br><span class="line">XmlBeanDefinitionReader beanDefinitionReader = <span class="keyword">new</span> XmlBeanDefinitionReader(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Configure the bean definition reader with this context's</span></span><br><span class="line"><span class="comment">// resource loading environment.</span></span><br><span class="line">beanDefinitionReader.setEnvironment(<span class="keyword">this</span>.getEnvironment());</span><br><span class="line">beanDefinitionReader.setResourceLoader(<span class="keyword">this</span>);</span><br><span class="line">beanDefinitionReader.setEntityResolver(<span class="keyword">new</span> ResourceEntityResolver(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 允许子类提供自定义的读取器初始化，然后继续实际加载bean定义</span></span><br><span class="line">initBeanDefinitionReader(beanDefinitionReader);</span><br><span class="line">loadBeanDefinitions(beanDefinitionReader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们主要关注该方法的 loadBeanDefinitions(beanDefinitionReader) 就是BeanDefinition的主要加载过程。它使用指定的 XmlBeanDefinitionReader 进行加载BeanDefinition。这个方法仅负责加载或者注册BeanDefinition，而生命周期是通过bean工厂的refreshBeanFactory方法管理</p><p><strong>loadBeanDefinitions</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(XmlBeanDefinitionReader reader)</span> <span class="keyword">throws</span> BeansException, IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 获取是否有配置好的Resource，如果有直接交由reader进行加载</span></span><br><span class="line">Resource[] configResources = getConfigResources();</span><br><span class="line"><span class="keyword">if</span> (configResources != <span class="keyword">null</span>) &#123;</span><br><span class="line">reader.loadBeanDefinitions(configResources);</span><br><span class="line">&#125;</span><br><span class="line">String[] configLocations = getConfigLocations();</span><br><span class="line"><span class="keyword">if</span> (configLocations != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// 加载给定的路径文件</span></span><br><span class="line">reader.loadBeanDefinitions(configLocations);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，对于BeanDefinition的加载最终是使用 XmlBeanDefinitionReader 的实例进行加载的，此处只是对其指定了加载的资源或者资源的位置。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(String... locations)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">Assert.notNull(locations, <span class="string">"Location array must not be null"</span>);</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 循环加载配置文件</span></span><br><span class="line"><span class="keyword">for</span> (String location : locations) &#123;</span><br><span class="line">count += loadBeanDefinitions(location);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此方法位于AbstractBeanDefinitionReader类中，主要针对字符串路径进行解析，最终得到Resource对象，然后将Resource交由XmlBeanDefinitionReader进行处理。所以针对 xml 的资源加载的最终位置还是位于XmlBeanDefinitionReader中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从指定的资源位置加载bean定义，返回找到的bean定义的数量</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(String location, @Nullable Set&lt;Resource&gt; actualResources)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">    <span class="comment">// 获取资源加载器</span></span><br><span class="line">ResourceLoader resourceLoader = getResourceLoader();</span><br><span class="line"><span class="keyword">if</span> (resourceLoader == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</span><br><span class="line"><span class="string">"Cannot load bean definitions from location ["</span> + location + <span class="string">"]: no ResourceLoader available"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (resourceLoader <span class="keyword">instanceof</span> ResourcePatternResolver) &#123;</span><br><span class="line"><span class="comment">// Resource pattern matching available.</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 循环加载resource 资源数组</span></span><br><span class="line">Resource[] resources = ((ResourcePatternResolver) resourceLoader).getResources(location);</span><br><span class="line">            <span class="comment">// 根据配置文件加载Bean定义</span></span><br><span class="line"><span class="keyword">int</span> count = loadBeanDefinitions(resources);</span><br><span class="line"><span class="keyword">if</span> (actualResources != <span class="keyword">null</span>) &#123;</span><br><span class="line">Collections.addAll(actualResources, resources);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Can only load single resources by absolute URL.</span></span><br><span class="line">Resource resource = resourceLoader.getResource(location);</span><br><span class="line"><span class="keyword">int</span> count = loadBeanDefinitions(resource);</span><br><span class="line"><span class="keyword">if</span> (actualResources != <span class="keyword">null</span>) &#123;</span><br><span class="line">actualResources.add(resource);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据输入流加载 Document 文档对象，然后根据得到的文档对象注册到容器</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">doLoadBeanDefinitions</span><span class="params">(InputSource inputSource, Resource resource)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Document doc = doLoadDocument(inputSource, resource);</span><br><span class="line"><span class="comment">// 真正的注册bean</span></span><br><span class="line"><span class="keyword">int</span> count = registerBeanDefinitions(doc, resource);</span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到通过 doLoadDocument 方法将其解析为Document对象，然后通过 registerBeanDefinitions 方法对 Document 对象进行提取与 BeanDefinition 的注册.</p><blockquote><p>这里的Document是符合 w3c 定义的标准xml文档; 我们知道xml解析一般有DOM方式(document)、SAX方式(Simple API for XML)以及StAX(Streaming API for xml)方式；<br>而此处的Resource不会包含太大量的信息，所以采用了DOM方式，即一次将整个XML都加载到内存中进行解析.</p></blockquote><p><strong>registerBeanDefinitions</strong></p><ol><li>DefaultBeanDefinitionDocumentReader</li><li>registerBeanDefinitions();</li><li>doRegisterBeanDefinitions();</li><li>parseBeanDefinitions();</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解析文档中根层次的元素:“import”、“alias”、“bean”</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">parseBeanDefinitions</span><span class="params">(Element root, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">NodeList nl = root.getChildNodes();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nl.getLength(); i++) &#123;</span><br><span class="line">Node node = nl.item(i);</span><br><span class="line"><span class="keyword">if</span> (node <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line">Element ele = (Element) node;</span><br><span class="line"><span class="keyword">if</span> (delegate.isDefaultNamespace(ele)) &#123;</span><br><span class="line">parseDefaultElement(ele, delegate);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">delegate.parseCustomElement(ele);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">delegate.parseCustomElement(root);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解析root的过程，判断root为spring默认标签还是用户自定义标签，分别交由不同委托类解析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseDefaultElement</span><span class="params">(Element ele, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) &#123;</span><br><span class="line">        <span class="comment">// 通过resource属性取得配置文件的位置，然后将其转换为Resource，交由XmlBeanDefinitionReader来解析</span></span><br><span class="line">importBeanDefinitionResource(ele);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) &#123;</span><br><span class="line">        <span class="comment">// 进行是否可重写校验和循环引用校验后，将alias标签的name和alias属性添加到上下文的aliasMap中；</span></span><br><span class="line">processAliasRegistration(ele);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) &#123;</span><br><span class="line">        <span class="comment">// 处理和注册bean</span></span><br><span class="line">processBeanDefinition(ele, delegate);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) &#123;</span><br><span class="line"><span class="comment">// beans标签，进行迭代调用doRegisterBeanDefinitions方法</span></span><br><span class="line">doRegisterBeanDefinitions(ele);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Process the given bean element, parsing the bean definition</span></span><br><span class="line"><span class="comment"> * and registering it with the registry.</span></span><br><span class="line"><span class="comment"> * 处理给定的 bean 元素，解析 bean 定义，并在注册中心注册。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processBeanDefinition</span><span class="params">(Element ele, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 创建一个 BeanDefinitionHolder</span></span><br><span class="line">BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);</span><br><span class="line"><span class="keyword">if</span> (bdHolder != <span class="keyword">null</span>) &#123;</span><br><span class="line">bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// Register the final decorated instance.</span></span><br><span class="line"><span class="comment">// 开始注册</span></span><br><span class="line">BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">getReaderContext().error(<span class="string">"Failed to register bean definition with name '"</span> +</span><br><span class="line">bdHolder.getBeanName() + <span class="string">"'"</span>, ele, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 执行容器通知事件</span></span><br><span class="line">getReaderContext().fireComponentRegistered(<span class="keyword">new</span> BeanComponentDefinition(bdHolder));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先创建一个 BeanDefinitionHolder，该方法会调用 BeanDefinitionReaderUtils.registerBeanDefinition 方法， 最后执行容器通知事件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 向给定的bean工厂注册给定的bean定义</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> definitionHolder bean定义，包括名称和别名</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> registry 要注册的bean工厂</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> BeanDefinitionStoreException 如果注册失败，抛出BeanDefinitionStoreException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Register bean definition under primary name.</span></span><br><span class="line">String beanName = definitionHolder.getBeanName();</span><br><span class="line"><span class="comment">// 将bean的名字和 BeanDefinition 注册</span></span><br><span class="line">registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());</span><br><span class="line"></span><br><span class="line"><span class="comment">// Register aliases for bean name, if any.</span></span><br><span class="line">String[] aliases = definitionHolder.getAliases();</span><br><span class="line"><span class="keyword">if</span> (aliases != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (String alias : aliases) &#123;</span><br><span class="line">registry.registerAlias(beanName, alias);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先从bean的持有者那里获取了beanName，然后调用 registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition())， 将bena的名字和 BeanDefinition 注册：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(String beanName, BeanDefinition beanDefinition)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"></span><br><span class="line">Assert.hasText(beanName, <span class="string">"Bean name must not be empty"</span>);</span><br><span class="line">Assert.notNull(beanDefinition, <span class="string">"BeanDefinition must not be null"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (beanDefinition <span class="keyword">instanceof</span> AbstractBeanDefinition) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">((AbstractBeanDefinition) beanDefinition).validate();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,</span><br><span class="line"><span class="string">"Validation of bean definition failed"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BeanDefinition existingDefinition = <span class="keyword">this</span>.beanDefinitionMap.get(beanName);</span><br><span class="line"><span class="keyword">if</span> (existingDefinition != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (!isAllowBeanDefinitionOverriding()) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionOverrideException(beanName, beanDefinition, existingDefinition);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line"><span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (hasBeanCreationStarted()) &#123;</span><br><span class="line"><span class="comment">// Cannot modify startup-time collection elements anymore (for stable iteration)</span></span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>.beanDefinitionMap) &#123;</span><br><span class="line"><span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">List&lt;String&gt; updatedDefinitions = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">this</span>.beanDefinitionNames.size() + <span class="number">1</span>);</span><br><span class="line">updatedDefinitions.addAll(<span class="keyword">this</span>.beanDefinitionNames);</span><br><span class="line">updatedDefinitions.add(beanName);</span><br><span class="line"><span class="keyword">this</span>.beanDefinitionNames = updatedDefinitions;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.manualSingletonNames.contains(beanName)) &#123;</span><br><span class="line">Set&lt;String&gt; updatedSingletons = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(<span class="keyword">this</span>.manualSingletonNames);</span><br><span class="line">updatedSingletons.remove(beanName);</span><br><span class="line"><span class="keyword">this</span>.manualSingletonNames = updatedSingletons;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 仍处于启动注册阶段,最终放进这个map 实现注册</span></span><br><span class="line"><span class="comment">// private final Map&lt;String, BeanDefinition&gt; beanDefinitionMap = new ConcurrentHashMap&lt;&gt;(256);</span></span><br><span class="line"><span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line"><span class="keyword">this</span>.beanDefinitionNames.add(beanName);</span><br><span class="line"><span class="keyword">this</span>.manualSingletonNames.remove(beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>.frozenBeanDefinitionNames = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (existingDefinition != <span class="keyword">null</span> || containsSingleton(beanName)) &#123;</span><br><span class="line">resetBeanDefinition(beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注册bean的最后一步，将beanName和 beanDefinition 放进一个 ConcurrentHashMap（256） 中。</p><p>那么这个 beanDefinition 是时候创建的呢？ 就是在 DefaultBeanDefinitionDocumentReader.processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) 方法中，在这里创建了 BeanDefinitionHolder， 而该实例中解析Bean并将Bean 保存在该对象中。所以称为持有者。<br>该实例会调用  parseBeanDefinitionElement(Element ele, @Nullable BeanDefinition containingBean) 方法，该方法用于解析XML文件并创建一个 BeanDefinitionHolder 返回，该方法会调用 parseBeanDefinitionElement(ele, beanName, containingBean) 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> AbstractBeanDefinition <span class="title">parseBeanDefinitionElement</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">Element ele, String beanName, @Nullable BeanDefinition containingBean)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 入栈，用于跟踪解析过程</span></span><br><span class="line"><span class="keyword">this</span>.parseState.push(<span class="keyword">new</span> BeanEntry(beanName));</span><br><span class="line"></span><br><span class="line">String className = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (ele.hasAttribute(CLASS_ATTRIBUTE)) &#123;</span><br><span class="line"><span class="comment">// public static final String CLASS_ATTRIBUTE = "class";</span></span><br><span class="line"><span class="comment">// 从XML元素中取出 class 元素</span></span><br><span class="line">className = ele.getAttribute(CLASS_ATTRIBUTE).trim();</span><br><span class="line">&#125;</span><br><span class="line">String parent = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (ele.hasAttribute(PARENT_ATTRIBUTE)) &#123;</span><br><span class="line">parent = ele.getAttribute(PARENT_ATTRIBUTE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 根据class属性和parent属性创建BeanDefinition, </span></span><br><span class="line">        <span class="comment">// 首先通过类加载器寻找class类并将其设置于beanClass属性</span></span><br><span class="line">        <span class="comment">// 如果类加载器暂时无法发现此类，则将class设置于beanClassName属性上</span></span><br><span class="line">AbstractBeanDefinition bd = createBeanDefinition(className, parent);</span><br><span class="line"></span><br><span class="line">parseBeanDefinitionAttributes(ele, beanName, containingBean, bd);</span><br><span class="line">bd.setDescription(DomUtils.getChildElementValueByTagName(ele, DESCRIPTION_ELEMENT));</span><br><span class="line"></span><br><span class="line">parseMetaElements(ele, bd);</span><br><span class="line">parseLookupOverrideSubElements(ele, bd.getMethodOverrides());</span><br><span class="line">parseReplacedMethodSubElements(ele, bd.getMethodOverrides());</span><br><span class="line"></span><br><span class="line">parseConstructorArgElements(ele, bd);</span><br><span class="line">parsePropertyElements(ele, bd);</span><br><span class="line">parseQualifierElements(ele, bd);</span><br><span class="line"></span><br><span class="line">bd.setResource(<span class="keyword">this</span>.readerContext.getResource());</span><br><span class="line">bd.setSource(extractSource(ele));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> bd;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="keyword">this</span>.parseState.pop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看看该方法，可以看到，该方法从XML元素中取出 class 元素，然后拿着 className 调用 createBeanDefinition(className, parent) 方法，该方法核心是调用 BeanDefinitionReaderUtils.createBeanDefinition 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> AbstractBeanDefinition <span class="title">createBeanDefinition</span><span class="params">(@Nullable String className, @Nullable String parentName)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> BeanDefinitionReaderUtils.createBeanDefinition(</span><br><span class="line">parentName, className, <span class="keyword">this</span>.readerContext.getBeanClassLoader());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AbstractBeanDefinition <span class="title">createBeanDefinition</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">@Nullable String parentName, @Nullable String className, @Nullable ClassLoader classLoader)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 泛型的bean定义，也就是最终生成的bean定义。</span></span><br><span class="line">GenericBeanDefinition bd = <span class="keyword">new</span> GenericBeanDefinition();</span><br><span class="line">bd.setParentName(parentName);</span><br><span class="line"><span class="keyword">if</span> (className != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (classLoader != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// 设置Class 对象，该对象就是我们在配置文件中配置的Class对象。最后返回。</span></span><br><span class="line">bd.setBeanClass(ClassUtils.forName(className, classLoader));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">bd.setBeanClassName(className);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> bd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法很简单，创建一个 Definition  的持有者，然后设置该持有者的Class对象，该对象就是我们在配置文件中配置的Class对象。最后返回。</p><p>至此，xml中定义的BeanDefinition元数据被注册至应用上下文中，创建bean工厂，生成Bean定义。但还没有实例化该类。</p><h3 id="Spring-ioc-依赖注入及lazy－init"><a href="#Spring-ioc-依赖注入及lazy－init" class="headerlink" title="Spring ioc 依赖注入及lazy－init"></a>Spring ioc 依赖注入及lazy－init</h3><blockquote><p>我们刚刚创建了Bean工厂，并创建 BeanDefinitions 放进 Map 里，以beanName为key。那么我们现在有了Bean定义，但还没有实例，也没有构建Bean与Bean之间的依赖关系。 接下来我们看如何实例及构建 Bean 依赖关系</p></blockquote><pre>1：BeanDefinition 保存所有 bean 定义及依赖关系2：解析所有 bean 定义，存储到 BeanDefinition 中3：getBean() 时，触发 ioc 依赖注入4：getBean() 由使用或者 context 中的 finishBeanFactoryInitialization() 循环触发（判断是否lazy，是否是单例）5：创建bean自身---由 factoryBean 或者自定义的 facotry-method 或者默认构造方法(cglib或class.newInstance())6：ioc 依赖注入：    A: - BeanDefinitionValueResolver，判断各种属性类型获取属性值（如果ref引用类型，递归调用getBean()，其它则返回对应值）    B: - 正式注入：BeanWrapper.setPropertyValues()</pre><p><img src="http://lishq.oss-cn-beijing.aliyuncs.com/github.io/Spring%20ioc%20%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E5%8F%8Alazy%EF%BC%8Dinit.png" alt=""></p><p><strong>AbstractApplicationContext.refresh().finishBeanFactoryInitialization(beanFactory)</strong> 实例化所有的非延迟加载的单例类</p><p><strong>preInstantiateSingletons</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preInstantiateSingletons</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"><span class="comment">// private volatile List&lt;String&gt; beanDefinitionNames = new ArrayList&lt;&gt;(256);</span></span><br><span class="line">List&lt;String&gt; beanNames = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">this</span>.beanDefinitionNames);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发所有非延迟单例bean的初始化...</span></span><br><span class="line">    <span class="comment">// 创建bean并递归构建依赖关系</span></span><br><span class="line"><span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line"><span class="keyword">if</span> (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) &#123;</span><br><span class="line"><span class="keyword">if</span> (isFactoryBean(beanName)) &#123;</span><br><span class="line">Object bean = getBean(FACTORY_BEAN_PREFIX + beanName);</span><br><span class="line"><span class="keyword">if</span> (bean <span class="keyword">instanceof</span> FactoryBean) &#123;</span><br><span class="line"><span class="keyword">final</span> FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) bean;</span><br><span class="line"><span class="keyword">boolean</span> isEagerInit;</span><br><span class="line"><span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span> &amp;&amp; factory <span class="keyword">instanceof</span> SmartFactoryBean) &#123;</span><br><span class="line">isEagerInit = AccessController.doPrivileged((PrivilegedAction&lt;Boolean&gt;)</span><br><span class="line">((SmartFactoryBean&lt;?&gt;) factory)::isEagerInit,</span><br><span class="line">getAccessControlContext());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">isEagerInit = (factory <span class="keyword">instanceof</span> SmartFactoryBean &amp;&amp;</span><br><span class="line">((SmartFactoryBean&lt;?&gt;) factory).isEagerInit());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (isEagerInit) &#123;</span><br><span class="line"><span class="comment">// 创建bean</span></span><br><span class="line">getBean(beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">getBean(beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为所有适用的bean触发初始化后回调</span></span><br><span class="line"><span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">Object singletonInstance = getSingleton(beanName);</span><br><span class="line"><span class="keyword">if</span> (singletonInstance <span class="keyword">instanceof</span> SmartInitializingSingleton) &#123;</span><br><span class="line"><span class="keyword">final</span> SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance;</span><br><span class="line"><span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">smartSingleton.afterSingletonsInstantiated();</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;, getAccessControlContext());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>doGetBean</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">doGetBean</span><span class="params">(<span class="keyword">final</span> String name, @Nullable <span class="keyword">final</span> Class&lt;T&gt; requiredType,</span></span></span><br><span class="line"><span class="function"><span class="params">@Nullable <span class="keyword">final</span> Object[] args, <span class="keyword">boolean</span> typeCheckOnly)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> String beanName = transformedBeanName(name);</span><br><span class="line">Object bean;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">final</span> RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">checkMergedBeanDefinition(mbd, beanName, args);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Guarantee initialization of beans that the current bean depends on.</span></span><br><span class="line">String[] dependsOn = mbd.getDependsOn();</span><br><span class="line"><span class="keyword">if</span> (dependsOn != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (String dep : dependsOn) &#123;</span><br><span class="line"><span class="keyword">if</span> (isDependent(beanName, dep)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line"><span class="string">"Circular depends-on relationship between '"</span> + beanName + <span class="string">"' and '"</span> + dep + <span class="string">"'"</span>);</span><br><span class="line">&#125;</span><br><span class="line">registerDependentBean(dep, beanName);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">getBean(dep);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line"><span class="string">"'"</span> + beanName + <span class="string">"' depends on missing bean '"</span> + dep + <span class="string">"'"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create bean instance.</span></span><br><span class="line"><span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">sharedInstance = getSingleton(beanName, () -&gt; &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">destroySingleton(beanName);</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line"><span class="keyword">return</span> (T) bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，该方法首先会获取依赖关系，拿着依赖的BeanName 递归调用 getBean方法，直到调用 getSingleton 方法返回依赖bean，而 getSingleton 方法的参数是 createBean 返回的实例，该方法内部调用 AbstractAutowireCapableBeanFactory.doCreateBean 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd, <span class="keyword">final</span> @Nullable Object[] args)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Instantiate the bean.</span></span><br><span class="line">BeanWrapper instanceWrapper = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">instanceWrapper = <span class="keyword">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (instanceWrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// 创建实例</span></span><br><span class="line">instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> Object bean = instanceWrapper.getWrappedInstance();</span><br><span class="line">Class&lt;?&gt; beanType = instanceWrapper.getWrappedClass();</span><br><span class="line"><span class="keyword">if</span> (beanType != NullBean.class) &#123;</span><br><span class="line">mbd.resolvedTargetType = beanType;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allow post-processors to modify the merged bean definition.</span></span><br><span class="line"><span class="keyword">synchronized</span> (mbd.postProcessingLock) &#123;</span><br><span class="line"><span class="keyword">if</span> (!mbd.postProcessed) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line"><span class="string">"Post-processing of merged bean definition failed"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">mbd.postProcessed = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Eagerly cache singletons to be able to resolve circular references</span></span><br><span class="line"><span class="comment">// even when triggered by lifecycle interfaces like BeanFactoryAware.</span></span><br><span class="line"><span class="keyword">boolean</span> earlySingletonExposure = (mbd.isSingleton() &amp;&amp; <span class="keyword">this</span>.allowCircularReferences &amp;&amp;</span><br><span class="line">isSingletonCurrentlyInCreation(beanName));</span><br><span class="line"><span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">"Eagerly caching bean '"</span> + beanName +</span><br><span class="line"><span class="string">"' to allow for resolving potential circular references"</span>);</span><br><span class="line">&#125;</span><br><span class="line">addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize the bean instance.</span></span><br><span class="line">Object exposedObject = bean;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 填充Bean，发生依赖注入的地方</span></span><br><span class="line">populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="keyword">if</span> (ex <span class="keyword">instanceof</span> BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) &#123;</span><br><span class="line"><span class="keyword">throw</span> (BeanCreationException) ex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">mbd.getResourceDescription(), beanName, <span class="string">"Initialization of bean failed"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">Object earlySingletonReference = getSingleton(beanName, <span class="keyword">false</span>);</span><br><span class="line"><span class="keyword">if</span> (earlySingletonReference != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (exposedObject == bean) &#123;</span><br><span class="line">exposedObject = earlySingletonReference;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123;</span><br><span class="line">String[] dependentBeans = getDependentBeans(beanName);</span><br><span class="line">Set&lt;String&gt; actualDependentBeans = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(dependentBeans.length);</span><br><span class="line"><span class="keyword">for</span> (String dependentBean : dependentBeans) &#123;</span><br><span class="line"><span class="keyword">if</span> (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123;</span><br><span class="line">actualDependentBeans.add(dependentBean);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!actualDependentBeans.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(......);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Register bean as disposable.</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">registerDisposableBeanIfNecessary(beanName, bean, mbd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心代码：</p><ol><li>instanceWrapper = createBeanInstance(beanName, mbd, args) 创建实例。</li><li>populateBean(beanName, mbd, instanceWrapper) ， 用于填充Bean，发生依赖注入。</li></ol><p><strong>createBeanInstance</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用适当的实例化策略，为指定的bean创建一个新实例:</span></span><br><span class="line"><span class="comment"> * 工厂方法、构造函数自动连接或简单实例化.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> BeanWrapper <span class="title">createBeanInstance</span><span class="params">(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 确保bean类在这一点上得到了实际的解析.</span></span><br><span class="line">Class&lt;?&gt; beanClass = resolveBeanClass(mbd, beanName);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (beanClass != <span class="keyword">null</span> &amp;&amp; !Modifier.isPublic(beanClass.getModifiers()) &amp;&amp; !mbd.isNonPublicAccessAllowed()) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line"><span class="string">"Bean class isn't public, and non-public access not allowed: "</span> + beanClass.getName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Supplier&lt;?&gt; instanceSupplier = mbd.getInstanceSupplier();</span><br><span class="line"><span class="keyword">if</span> (instanceSupplier != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> obtainFromSupplier(instanceSupplier, beanName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (mbd.getFactoryMethodName() != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> instantiateUsingFactoryMethod(beanName, mbd, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Shortcut when re-creating the same bean...</span></span><br><span class="line"><span class="keyword">boolean</span> resolved = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">boolean</span> autowireNecessary = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">if</span> (args == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">synchronized</span> (mbd.constructorArgumentLock) &#123;</span><br><span class="line"><span class="keyword">if</span> (mbd.resolvedConstructorOrFactoryMethod != <span class="keyword">null</span>) &#123;</span><br><span class="line">resolved = <span class="keyword">true</span>;</span><br><span class="line">autowireNecessary = mbd.constructorArgumentsResolved;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (resolved) &#123;</span><br><span class="line"><span class="keyword">if</span> (autowireNecessary) &#123;</span><br><span class="line"><span class="keyword">return</span> autowireConstructor(beanName, mbd, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> instantiateBean(beanName, mbd);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Candidate constructors for autowiring?</span></span><br><span class="line">Constructor&lt;?&gt;[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);</span><br><span class="line"><span class="keyword">if</span> (ctors != <span class="keyword">null</span> || mbd.getResolvedAutowireMode() == AUTOWIRE_CONSTRUCTOR ||</span><br><span class="line">mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args)) &#123;</span><br><span class="line"><span class="keyword">return</span> autowireConstructor(beanName, mbd, ctors, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Preferred constructors for default construction?</span></span><br><span class="line">ctors = mbd.getPreferredConstructors();</span><br><span class="line"><span class="keyword">if</span> (ctors != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> autowireConstructor(beanName, mbd, ctors, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// No special handling: simply use no-arg constructor.</span></span><br><span class="line"><span class="keyword">return</span> instantiateBean(beanName, mbd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法首先创建Class 对象，然后获取构造器对象，最后调用 <strong>instantiateBean(beanName, mbd)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用它的默认构造函数实例化给定的bean.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> BeanWrapper <span class="title">instantiateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Object beanInstance;</span><br><span class="line"><span class="keyword">final</span> BeanFactory parent = <span class="keyword">this</span>;</span><br><span class="line"><span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">beanInstance = AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt;</span><br><span class="line">getInstantiationStrategy().instantiate(mbd, beanName, parent),</span><br><span class="line">getAccessControlContext());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">beanInstance = getInstantiationStrategy().instantiate(mbd, beanName, parent);</span><br><span class="line">&#125;</span><br><span class="line">BeanWrapper bw = <span class="keyword">new</span> BeanWrapperImpl(beanInstance);</span><br><span class="line">initBeanWrapper(bw);</span><br><span class="line"><span class="keyword">return</span> bw;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法核心逻辑是 <strong>beanInstance = getInstantiationStrategy().instantiate(mbd, beanName, parent)</strong>，携带BeanName，RootBeanDefinition ,发挥的策略对象是 SimpleInstantiationStrategy，该方法内部调用静态方法 <strong>BeanUtils.instantiateClass(constructorToUse)</strong>， 最后调用 Constructor 的 newInstance 方法，<br>也就是最终使用反射创建了该实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">instantiate</span><span class="params">(RootBeanDefinition bd, @Nullable String beanName, BeanFactory owner)</span> </span>&#123;</span><br><span class="line"><span class="comment">// Don't override the class with CGLIB if no overrides.</span></span><br><span class="line"><span class="keyword">if</span> (!bd.hasMethodOverrides()) &#123;</span><br><span class="line">Constructor&lt;?&gt; constructorToUse;</span><br><span class="line"><span class="keyword">synchronized</span> (bd.constructorArgumentLock) &#123;</span><br><span class="line">constructorToUse = (Constructor&lt;?&gt;) bd.resolvedConstructorOrFactoryMethod;</span><br><span class="line"><span class="keyword">if</span> (constructorToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">final</span> Class&lt;?&gt; clazz = bd.getBeanClass();</span><br><span class="line"><span class="keyword">if</span> (clazz.isInterface()) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanInstantiationException(clazz, <span class="string">"Specified class is an interface"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">constructorToUse = AccessController.doPrivileged(</span><br><span class="line">(PrivilegedExceptionAction&lt;Constructor&lt;?&gt;&gt;) clazz::getDeclaredConstructor);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">constructorToUse = clazz.getDeclaredConstructor();</span><br><span class="line">&#125;</span><br><span class="line">bd.resolvedConstructorOrFactoryMethod = constructorToUse;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanInstantiationException(clazz, <span class="string">"No default constructor found"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> BeanUtils.instantiateClass(constructorToUse);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Must generate CGLIB subclass.</span></span><br><span class="line"><span class="keyword">return</span> instantiateWithMethodInjection(bd, beanName, owner);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">instantiateClass</span><span class="params">(Constructor&lt;T&gt; ctor, Object... args)</span> <span class="keyword">throws</span> BeanInstantiationException </span>&#123;</span><br><span class="line">Assert.notNull(ctor, <span class="string">"Constructor must not be null"</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 判断是否是 Kotlin 类型。如果不是，则调用构造器的实例方法</span></span><br><span class="line">ReflectionUtils.makeAccessible(ctor);</span><br><span class="line"><span class="keyword">return</span> (KotlinDetector.isKotlinReflectPresent() &amp;&amp; KotlinDetector.isKotlinType(ctor.getDeclaringClass()) ?</span><br><span class="line">KotlinDelegate.instantiateClass(ctor, args) : ctor.newInstance(args));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里，我们的实例已经创建。但是我们的实例的依赖还没有设置：</p><ul><li>populateBean(beanName, mbd, instanceWrapper) ， 用于填充Bean，依赖注入。</li></ul><p><strong>populateBean</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">populateBean</span><span class="params">(String beanName, RootBeanDefinition mbd, @Nullable BeanWrapper bw)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (bw == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (mbd.hasPropertyValues()) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">mbd.getResourceDescription(), beanName, <span class="string">"Cannot apply property values to null instance"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Skip property population phase for null instance.</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Give any InstantiationAwareBeanPostProcessors the opportunity to modify the</span></span><br><span class="line"><span class="comment">// state of the bean before properties are set. This can be used, for example,</span></span><br><span class="line"><span class="comment">// to support styles of field injection.</span></span><br><span class="line"><span class="keyword">boolean</span> continueWithPropertyPopulation = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line"><span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line"><span class="keyword">if</span> (bp <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;</span><br><span class="line"><span class="keyword">if</span> (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) &#123;</span><br><span class="line">continueWithPropertyPopulation = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!continueWithPropertyPopulation) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取该bean的所有属性，也就是我们配置property元素</span></span><br><span class="line">PropertyValues pvs = (mbd.hasPropertyValues() ? mbd.getPropertyValues() : <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (mbd.getResolvedAutowireMode() == AUTOWIRE_BY_NAME || mbd.getResolvedAutowireMode() == AUTOWIRE_BY_TYPE) &#123;</span><br><span class="line">MutablePropertyValues newPvs = <span class="keyword">new</span> MutablePropertyValues(pvs);</span><br><span class="line"><span class="comment">// Add property values based on autowire by name if applicable.</span></span><br><span class="line"><span class="keyword">if</span> (mbd.getResolvedAutowireMode() == AUTOWIRE_BY_NAME) &#123;</span><br><span class="line">autowireByName(beanName, mbd, bw, newPvs);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Add property values based on autowire by type if applicable.</span></span><br><span class="line"><span class="keyword">if</span> (mbd.getResolvedAutowireMode() == AUTOWIRE_BY_TYPE) &#123;</span><br><span class="line">autowireByType(beanName, mbd, bw, newPvs);</span><br><span class="line">&#125;</span><br><span class="line">pvs = newPvs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> hasInstAwareBpps = hasInstantiationAwareBeanPostProcessors();</span><br><span class="line"><span class="keyword">boolean</span> needsDepCheck = (mbd.getDependencyCheck() != AbstractBeanDefinition.DEPENDENCY_CHECK_NONE);</span><br><span class="line"></span><br><span class="line">PropertyDescriptor[] filteredPds = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (hasInstAwareBpps) &#123;</span><br><span class="line"><span class="keyword">if</span> (pvs == <span class="keyword">null</span>) &#123;</span><br><span class="line">pvs = mbd.getPropertyValues();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line"><span class="keyword">if</span> (bp <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">PropertyValues pvsToUse = ibp.postProcessProperties(pvs, bw.getWrappedInstance(), beanName);</span><br><span class="line"><span class="keyword">if</span> (pvsToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (filteredPds == <span class="keyword">null</span>) &#123;</span><br><span class="line">filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);</span><br><span class="line">&#125;</span><br><span class="line">pvsToUse = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);</span><br><span class="line"><span class="keyword">if</span> (pvsToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">pvs = pvsToUse;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (needsDepCheck) &#123;</span><br><span class="line"><span class="keyword">if</span> (filteredPds == <span class="keyword">null</span>) &#123;</span><br><span class="line">filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);</span><br><span class="line">&#125;</span><br><span class="line">checkDependencies(beanName, mbd, filteredPds, pvs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pvs != <span class="keyword">null</span>) &#123;</span><br><span class="line">applyPropertyValues(beanName, mbd, bw, pvs);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">applyPropertyValues</span><span class="params">(String beanName, BeanDefinition mbd, BeanWrapper bw, PropertyValues pvs)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (pvs.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span> &amp;&amp; bw <span class="keyword">instanceof</span> BeanWrapperImpl) &#123;</span><br><span class="line">((BeanWrapperImpl) bw).setSecurityContext(getAccessControlContext());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MutablePropertyValues mpvs = <span class="keyword">null</span>;</span><br><span class="line">List&lt;PropertyValue&gt; original;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pvs <span class="keyword">instanceof</span> MutablePropertyValues) &#123;</span><br><span class="line">mpvs = (MutablePropertyValues) pvs;</span><br><span class="line"><span class="keyword">if</span> (mpvs.isConverted()) &#123;</span><br><span class="line"><span class="comment">// Shortcut: use the pre-converted values as-is.</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">bw.setPropertyValues(mpvs);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">mbd.getResourceDescription(), beanName, <span class="string">"Error setting property values"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">original = mpvs.getPropertyValueList();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">original = Arrays.asList(pvs.getPropertyValues());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TypeConverter converter = getCustomTypeConverter();</span><br><span class="line"><span class="keyword">if</span> (converter == <span class="keyword">null</span>) &#123;</span><br><span class="line">converter = bw;</span><br><span class="line">&#125;</span><br><span class="line">BeanDefinitionValueResolver valueResolver = <span class="keyword">new</span> BeanDefinitionValueResolver(<span class="keyword">this</span>, beanName, mbd, converter);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个深度副本，解析值的任何引用</span></span><br><span class="line">List&lt;PropertyValue&gt; deepCopy = <span class="keyword">new</span> ArrayList&lt;&gt;(original.size());</span><br><span class="line"><span class="keyword">boolean</span> resolveNecessary = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">for</span> (PropertyValue pv : original) &#123;</span><br><span class="line"><span class="keyword">if</span> (pv.isConverted()) &#123;</span><br><span class="line">deepCopy.add(pv);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">String propertyName = pv.getName();</span><br><span class="line">Object originalValue = pv.getValue();</span><br><span class="line"><span class="comment">// 获取 pvName 所对应的容器value</span></span><br><span class="line">Object resolvedValue = valueResolver.resolveValueIfNecessary(pv, originalValue);</span><br><span class="line">Object convertedValue = resolvedValue;</span><br><span class="line"><span class="keyword">boolean</span> convertible = bw.isWritableProperty(propertyName) &amp;&amp;</span><br><span class="line">!PropertyAccessorUtils.isNestedOrIndexedProperty(propertyName);</span><br><span class="line"><span class="keyword">if</span> (convertible) &#123;</span><br><span class="line">convertedValue = convertForProperty(resolvedValue, propertyName, bw, converter);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Possibly store converted value in merged bean definition,</span></span><br><span class="line"><span class="comment">// in order to avoid re-conversion for every created bean instance.</span></span><br><span class="line"><span class="keyword">if</span> (resolvedValue == originalValue) &#123;</span><br><span class="line"><span class="keyword">if</span> (convertible) &#123;</span><br><span class="line">pv.setConvertedValue(convertedValue);</span><br><span class="line">&#125;</span><br><span class="line">deepCopy.add(pv);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (convertible &amp;&amp; originalValue <span class="keyword">instanceof</span> TypedStringValue &amp;&amp;</span><br><span class="line">!((TypedStringValue) originalValue).isDynamic() &amp;&amp;</span><br><span class="line">!(convertedValue <span class="keyword">instanceof</span> Collection || ObjectUtils.isArray(convertedValue))) &#123;</span><br><span class="line">pv.setConvertedValue(convertedValue);</span><br><span class="line">deepCopy.add(pv);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">resolveNecessary = <span class="keyword">true</span>;</span><br><span class="line">deepCopy.add(<span class="keyword">new</span> PropertyValue(pv, convertedValue));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (mpvs != <span class="keyword">null</span> &amp;&amp; !resolveNecessary) &#123;</span><br><span class="line">mpvs.setConverted();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set our (possibly massaged) deep copy.</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">bw.setPropertyValues(<span class="keyword">new</span> MutablePropertyValues(deepCopy));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法核心逻辑是 <strong>PropertyValues pvs = (mbd.hasPropertyValues() ? mbd.getPropertyValues() : null)</strong>， 即获取该 bean 的所有属性，也就是我们配置的 property 元素。最后执行 applyPropertyValues(beanName, mbd, bw, pvs) 方法。现在的PropertyValues 都是字符串，没有值，这个方法的作用就是获取值，关键代码：<strong>Object resolvedValue = valueResolver.resolveValueIfNecessary(pv, originalValue)</strong>，该方法会获取 pvName 所对应的容器 value，该方法内部会调用 BeanWrapperImpl.resolveReference(argName, ref) 方法</p><p><strong>resolveReference</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">resolveReference</span><span class="params">(Object argName, RuntimeBeanReference ref)</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Object bean;</span><br><span class="line">String refName = ref.getBeanName();</span><br><span class="line">refName = String.valueOf(doEvaluate(refName));</span><br><span class="line"><span class="keyword">if</span> (ref.isToParent()) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.beanFactory.getParentBeanFactory() == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line"><span class="keyword">this</span>.beanDefinition.getResourceDescription(), <span class="keyword">this</span>.beanName,</span><br><span class="line"><span class="string">"Can't resolve reference to bean '"</span> + refName +</span><br><span class="line"><span class="string">"' in parent factory: no parent factory available"</span>);</span><br><span class="line">&#125;</span><br><span class="line">bean = <span class="keyword">this</span>.beanFactory.getParentBeanFactory().getBean(refName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 根据属性名从容器中获取实例,递归</span></span><br><span class="line">bean = <span class="keyword">this</span>.beanFactory.getBean(refName);</span><br><span class="line"><span class="keyword">this</span>.beanFactory.registerDependentBean(refName, <span class="keyword">this</span>.beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (bean <span class="keyword">instanceof</span> NullBean) &#123;</span><br><span class="line">bean = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line"><span class="keyword">this</span>.beanDefinition.getResourceDescription(), <span class="keyword">this</span>.beanName,</span><br><span class="line"><span class="string">"Cannot resolve reference to bean '"</span> + ref.getBeanName() + <span class="string">"' while setting "</span> + argName, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(<span class="keyword">final</span> @Nullable Object value)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="keyword">final</span> Method writeMethod = (<span class="keyword">this</span>.pd <span class="keyword">instanceof</span> GenericTypeAwarePropertyDescriptor ?</span><br><span class="line">((GenericTypeAwarePropertyDescriptor) <span class="keyword">this</span>.pd).getWriteMethodForActualAccess() :</span><br><span class="line"><span class="keyword">this</span>.pd.getWriteMethod());</span><br><span class="line"><span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">ReflectionUtils.makeAccessible(writeMethod);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">AccessController.doPrivileged((PrivilegedExceptionAction&lt;Object&gt;) () -&gt;</span><br><span class="line">writeMethod.invoke(getWrappedInstance(), value), acc);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (PrivilegedActionException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> ex.getException();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">ReflectionUtils.makeAccessible(writeMethod);</span><br><span class="line">writeMethod.invoke(getWrappedInstance(), value);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法是最后一步，我们看到该方法会找到set方法，然后调用 Method 的 invoke 方法，完成属性注入。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Spring 的 Bean 其实就是 BeanDefinition，在 Bean 的创建和依赖注入的过程中，需要根据 BeanDefinition 的信息来递归的完成依赖注入。这些递归都是以 getBean() 为入口的，一个递归是在上下文体系中查找需要的 Bean 和创建 Bean 的递归调用；另一个 Bean 是在依赖注入时，通过递归调用容器的 getBean 方法，得到当前的依赖 Bean，同时也触发对依赖 Bean 的创建和注入。在对 Bean 的属性进行依赖注入时，解析的过程也是一个递归的过程，这样，根据依赖关系，一层一层的完成 Bean 的创建和注入，直到最后完成当前 Bean 的创建。有了这个顶层 Bean 的创建和对他的属性依赖注入的完成，意味着当前 Bean 相关的整个依赖链的注入也完成了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;Spring源码学习笔记，Spring-Ioc源码浅析，错误之处欢迎指正，共同学习&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
&lt;h3 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h3&gt;&lt;p&gt;Ioc 容器的核心是控制对象的创建，销毁，管理对象之间的依赖关系，并由IOC容器完成对象的注入。我们只需要关注业务逻辑。&lt;/p&gt;
&lt;h3 id=&quot;IOC-原理&quot;&gt;&lt;a href=&quot;#IOC-原理&quot; class=&quot;headerlink&quot; title=&quot;IOC 原理&quot;&gt;&lt;/a&gt;IOC 原理&lt;/h3&gt;&lt;p&gt;Ioc 底层通过 java 反射创建实例，利用set方法对实例的依赖进行注入。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Spring" scheme="https://blog.tolvyou.cn/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>netty-轻量级对象池-recycler</title>
    <link href="https://blog.tolvyou.cn/2018/11/22/netty-recycler/"/>
    <id>https://blog.tolvyou.cn/2018/11/22/netty-recycler/</id>
    <published>2018-11-22T09:14:11.000Z</published>
    <updated>2019-02-08T08:25:15.550Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>netty学习系列笔记总结，轻量级对象池-Recycler源码浅析，错误之处欢迎指正, 共同学习</p><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>由于Java 创建一个实例的消耗不小，所以现在很多框架都使用对象池。创建对象的时候不需要每次都通过new方式创建，如果Recycler有对象直接获取二次利用，不需要对象的时候放入Recycler对象池。通过重用对象，能够避免频繁创建对象和销毁对象带来的损耗。</p><a id="more"></a><h3 id="Recycler的使用"><a href="#Recycler的使用" class="headerlink" title="Recycler的使用"></a>Recycler的使用</h3><ol><li><p>定义基于 FastThreadLocal 的轻量级对象池 Recycler 负责对象的回收和二次利用，不需要每次分配内存减少内存使用，减少 new 对象频率即减少 Young GC 频率</p></li><li><p>创建对象通过 Recycler 的 get() 获取对象池里面的对象，不需要对象时可以显式调用 recycle() 方法回收对象放到对象池</p></li><li><p>通过自定义 newObject() 方法定义对象创建，参数handle负责对象回收到对象池Recycler</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Recycler&lt;User&gt; RECYCLER = <span class="keyword">new</span> Recycler&lt;User&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> User <span class="title">newObject</span><span class="params">(Handle&lt;User&gt; handle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User(handle);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Recycler.Handle&lt;User&gt; handle;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(Recycler.Handle&lt;User&gt; handle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.handle = handle;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recycle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        handle.recycle(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    User user = RECYCLER.get();</span><br><span class="line"></span><br><span class="line">    user.recycle();</span><br><span class="line">    RECYCLER.get().recycle();</span><br><span class="line"></span><br><span class="line">    User user1 = RECYCLER.get();</span><br><span class="line"></span><br><span class="line">    System.out.println(user1 == user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">true</span></span><br></pre></td></tr></table></figure></p><h3 id="Recycler的创建"><a href="#Recycler的创建" class="headerlink" title="Recycler的创建"></a>Recycler的创建</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">Recycler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(DEFAULT_MAX_CAPACITY_PER_THREAD);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> FastThreadLocal&lt;Stack&lt;T&gt;&gt; threadLocal = <span class="keyword">new</span> FastThreadLocal&lt;Stack&lt;T&gt;&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Stack&lt;T&gt; <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Stack&lt;T&gt;(Recycler.<span class="keyword">this</span>, </span><br><span class="line">        Thread.currentThread(), </span><br><span class="line">        maxCapacityPerThread,<span class="comment">// Use 32k instances as default.</span></span><br><span class="line">        maxSharedCapacityFactor,<span class="comment">//2</span></span><br><span class="line">        ratioMask, <span class="comment">//7</span></span><br><span class="line">        maxDelayedQueuesPerThread);<span class="comment">//2*cpu</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Stack(Recycler&lt;T&gt; parent, Thread thread, <span class="keyword">int</span> maxCapacity, <span class="keyword">int</span> maxSharedCapacityFactor,</span><br><span class="line">      <span class="keyword">int</span> ratioMask, <span class="keyword">int</span> maxDelayedQueues) &#123;</span><br><span class="line">    <span class="keyword">this</span>.parent = parent;</span><br><span class="line">    <span class="keyword">this</span>.thread = thread;</span><br><span class="line">    <span class="keyword">this</span>.maxCapacity = maxCapacity;</span><br><span class="line">    availableSharedCapacity = <span class="keyword">new</span> AtomicInteger(max(maxCapacity / maxSharedCapacityFactor, LINK_CAPACITY));<span class="comment">//own 32k, shared 16k</span></span><br><span class="line">    elements = <span class="keyword">new</span> DefaultHandle[min(INITIAL_CAPACITY, maxCapacity)];</span><br><span class="line">    <span class="keyword">this</span>.ratioMask = ratioMask;<span class="comment">//控制对象回收频率</span></span><br><span class="line">    <span class="keyword">this</span>.maxDelayedQueues = maxDelayedQueues;<span class="comment">//当前线程创建的对象可以在多少线程缓存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Recycler成员变量FastThreadLocal&lt;Stack<t>&gt;类型的threadLocal,Stack成员变量包括DefaultHandle类型数组elements[实际存放对象池,Handle包装对象并且被外部对象引用从而回收对象],thread[当前Stack归属线程],ratioMask[控制对象回收频率],maxCapacity[承载元素最大容量],maxDelayedQueues[当前线程创建的对象释放的最大线程数量],head/prev/cursor,availableSharedCapacity[当前线程创建的对象在其他线程缓存的最大数量]</t></p><h3 id="Recycler中获取对象"><a href="#Recycler中获取对象" class="headerlink" title="Recycler中获取对象"></a>Recycler中获取对象</h3><ul><li>获取当前线程的Stack</li><li>从Stack里面弹出DefaultHandle对象</li><li>创建对象并绑定到Stack</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (maxCapacityPerThread == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> newObject((Handle&lt;T&gt;) NOOP_HANDLE);</span><br><span class="line">    &#125;</span><br><span class="line">    Stack&lt;T&gt; stack = threadLocal.get();</span><br><span class="line">    DefaultHandle&lt;T&gt; handle = stack.pop();</span><br><span class="line">    <span class="keyword">if</span> (handle == <span class="keyword">null</span>) &#123;</span><br><span class="line">        handle = stack.newHandle();</span><br><span class="line">        handle.value = newObject(handle);<span class="comment">// 跳转到用户自定义代码</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (T) handle.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Handle NOOP_HANDLE = <span class="keyword">new</span> Handle() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recycle</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// NOOP</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个handle绑定一个stack</span></span><br><span class="line"><span class="function">DefaultHandle&lt;T&gt; <span class="title">newHandle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DefaultHandle&lt;T&gt;(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DefaultHandle(Stack&lt;?&gt; stack) &#123;</span><br><span class="line">    <span class="keyword">this</span>.stack = stack;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">DefaultHandle&lt;T&gt; <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当前stack里有多少对象</span></span><br><span class="line">    <span class="keyword">int</span> size = <span class="keyword">this</span>.size;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!scavenge()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        size = <span class="keyword">this</span>.size;</span><br><span class="line">    &#125;</span><br><span class="line">    size --;</span><br><span class="line">    DefaultHandle ret = elements[size];</span><br><span class="line">    elements[size] = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (ret.lastRecycledId != ret.recycleId) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"recycled multiple times"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ret.recycleId = <span class="number">0</span>;</span><br><span class="line">    ret.lastRecycledId = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>.size = size;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="回收对象到Recycler"><a href="#回收对象到Recycler" class="headerlink" title="回收对象到Recycler"></a>回收对象到Recycler</h3><ul><li>同线程回收对象</li><li>异线程回收对象</li></ul><p><strong>同线程回收对象</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recycle</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (object != value) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"object does not belong to handle"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    stack.push(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(DefaultHandle&lt;?&gt; item)</span> </span>&#123;</span><br><span class="line">    Thread currentThread = Thread.currentThread();</span><br><span class="line">    <span class="keyword">if</span> (thread == currentThread) &#123;</span><br><span class="line">        <span class="comment">// The current Thread is the thread that belongs to the Stack, we can try to push the object now.</span></span><br><span class="line">        pushNow(item);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// The current Thread is not the one that belongs to the Stack, we need to signal that the push</span></span><br><span class="line">        <span class="comment">// happens later.</span></span><br><span class="line">        pushLater(item, currentThread);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pushNow</span><span class="params">(DefaultHandle&lt;?&gt; item)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((item.recycleId | item.lastRecycledId) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"recycled already"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    item.recycleId = item.lastRecycledId = OWN_THREAD_ID;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> size = <span class="keyword">this</span>.size;</span><br><span class="line">    <span class="keyword">if</span> (size &gt;= maxCapacity || dropHandle(item)) &#123;</span><br><span class="line">        <span class="comment">// Hit the maximum capacity or should drop - drop the possibly youngest object.</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (size == elements.length) &#123;</span><br><span class="line">        elements = Arrays.copyOf(elements, min(size &lt;&lt; <span class="number">1</span>, maxCapacity));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    elements[size] = item;</span><br><span class="line">    <span class="keyword">this</span>.size = size + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回收对象到Recycler:<br>调用Handle的recycle()方法回收对象,使用Stack的push()方法把当前对象压入栈里面,判断当前线程是否为创建Stack的thread执行同/异线程回收对象<br>1.同线程回收对象-&gt;stack.pushNow()<br>设置recycleId/lastRecycledId为OWN_THREAD_ID,当前Stack对象数量超过承载最大容量或者Handle没有被回收过并且回收对象数量+1&amp;对象回收频率不等于0即回收1/8对象则丢弃对象,当前Stack对象数量达到数组容量则重新创建2倍Stack对象数量的数组,赋值数组当前Stack对象数量位置为回收对象</p><p><strong>异线程回收对象</strong></p><ul><li>获取WeakOrderQueue</li><li>创建WeakOrderQueue</li><li>将对象追加到WeakOrderQueue</li></ul><p>回收对象到Recycler:<br>2.异线程回收对象-&gt;stack.pushLater()<br>(1)获取WeakOrderQueue-&gt;DELAYED_RECYCLED.get()<br>通过当前Stack对象获取delayedRecycled的WeakOrderQueue<br>(2)创建WeakOrderQueue-&gt;WeakOrderQueue.allocate()<br>把WeakOrderQueue插入到Stack对象头部实现当前线程分配Stack对象<br>(3)将对象追加到WeakOrderQueue-&gt;queue.add()<br>将DefaultHandle对象追加到尾指针tail的elements数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pushLater</span><span class="params">(DefaultHandle&lt;?&gt; item, Thread thread)</span> </span>&#123;</span><br><span class="line">    Map&lt;Stack&lt;?&gt;, WeakOrderQueue&gt; delayedRecycled = DELAYED_RECYCLED.get();</span><br><span class="line">    WeakOrderQueue queue = delayedRecycled.get(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (queue == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (delayedRecycled.size() &gt;= maxDelayedQueues) &#123;</span><br><span class="line">            <span class="comment">// Add a dummy queue so we know we should drop the object</span></span><br><span class="line">            delayedRecycled.put(<span class="keyword">this</span>, WeakOrderQueue.DUMMY);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Check if we already reached the maximum number of delayed queues and if we can allocate at all.</span></span><br><span class="line">        <span class="keyword">if</span> ((queue = WeakOrderQueue.allocate(<span class="keyword">this</span>, thread)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// drop object</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        delayedRecycled.put(<span class="keyword">this</span>, queue);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (queue == WeakOrderQueue.DUMMY) &#123;</span><br><span class="line">        <span class="comment">// drop object</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    queue.add(item);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> FastThreadLocal&lt;Map&lt;Stack&lt;?&gt;, WeakOrderQueue&gt;&gt; DELAYED_RECYCLED =</span><br><span class="line">        <span class="keyword">new</span> FastThreadLocal&lt;Map&lt;Stack&lt;?&gt;, WeakOrderQueue&gt;&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Map&lt;Stack&lt;?&gt;, WeakOrderQueue&gt; initialValue() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> WeakHashMap&lt;Stack&lt;?&gt;, WeakOrderQueue&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> WeakOrderQueue <span class="title">allocate</span><span class="params">(Stack&lt;?&gt; stack, Thread thread)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// We allocated a Link so reserve the space</span></span><br><span class="line">    <span class="keyword">return</span> reserveSpace(stack.availableSharedCapacity, LINK_CAPACITY)</span><br><span class="line">            ? <span class="keyword">new</span> WeakOrderQueue(stack, thread) : <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">reserveSpace</span><span class="params">(AtomicInteger availableSharedCapacity, <span class="keyword">int</span> space)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> space &gt;= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> available = availableSharedCapacity.get();</span><br><span class="line">        <span class="keyword">if</span> (available &lt; space) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (availableSharedCapacity.compareAndSet(available, available - space)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">WeakOrderQueue</span><span class="params">(Stack&lt;?&gt; stack, Thread thread)</span> </span>&#123;</span><br><span class="line">    head = tail = <span class="keyword">new</span> Link();</span><br><span class="line">    owner = <span class="keyword">new</span> WeakReference&lt;Thread&gt;(thread);</span><br><span class="line">    <span class="keyword">synchronized</span> (stack) &#123;</span><br><span class="line">        next = stack.head;</span><br><span class="line">        stack.head = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Its important that we not store the Stack itself in the WeakOrderQueue as the Stack also is used in</span></span><br><span class="line">    <span class="comment">// the WeakHashMap as key. So just store the enclosed AtomicInteger which should allow to have the</span></span><br><span class="line">    <span class="comment">// Stack itself GCed.</span></span><br><span class="line">    availableSharedCapacity = stack.availableSharedCapacity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="异线程收割对象"><a href="#异线程收割对象" class="headerlink" title="异线程收割对象"></a>异线程收割对象</h3><ul><li>获取当前线程的Stack</li><li>从Stack里面弹出对象</li><li>创建对象并绑定到Stack</li></ul><p>异线程收割对象-&gt;stack.scavenge()从其他线程回收对象<br>使用scavengeSome()方法获取当前需要回收WeakOrderQueue cursor,while循环向当前Stack关联的WeakOrderQueue回收对象,使用WeakOrderQueue cursor的transfer()方法把WeakOrderQueue的Link传输到Stack,循环将当前Link数组元素传输到当前Stack底层数组,cursor的关联线程owner是否为空释放cursor节点,如果没有回收到对象则重置prev指针置为空/cursor指针置为head头节点即下次从头部开始回收</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;netty学习系列笔记总结，轻量级对象池-Recycler源码浅析，错误之处欢迎指正, 共同学习&lt;/p&gt;

&lt;h3 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h3&gt;&lt;p&gt;由于Java 创建一个实例的消耗不小，所以现在很多框架都使用对象池。创建对象的时候不需要每次都通过new方式创建，如果Recycler有对象直接获取二次利用，不需要对象的时候放入Recycler对象池。通过重用对象，能够避免频繁创建对象和销毁对象带来的损耗。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Netty" scheme="https://blog.tolvyou.cn/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>netty解码器抽象父类-ByteToMessageDecoder解析</title>
    <link href="https://blog.tolvyou.cn/2018/11/20/netty-byteToMessageDecoder/"/>
    <id>https://blog.tolvyou.cn/2018/11/20/netty-byteToMessageDecoder/</id>
    <published>2018-11-20T03:10:58.000Z</published>
    <updated>2019-02-08T08:14:11.739Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>netty学习系列笔记总结，解码器抽象父类-ByteToMessageDecoder源码浅析，错误之处欢迎指正, 共同学习</p><a id="more"></a><h3 id="累加字节流"><a href="#累加字节流" class="headerlink" title="累加字节流"></a>累加字节流</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> ByteBuf) &#123;</span><br><span class="line">        <span class="comment">// 从对象池中取出一个List</span></span><br><span class="line">        CodecOutputList out = CodecOutputList.newInstance();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ByteBuf data = (ByteBuf) msg;</span><br><span class="line">            first = cumulation == <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (first) &#123;</span><br><span class="line">                <span class="comment">// 第一次解码</span></span><br><span class="line">                cumulation = data;<span class="comment">// 累计</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 第二次解码，就将 data 向 cumulation 追加，并释放 data</span></span><br><span class="line">                cumulation = cumulator.cumulate(ctx.alloc(), cumulation, data);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 得到追加后的 cumulation 后，调用 decode 方法进行解码</span></span><br><span class="line">            <span class="comment">// 解码过程中，调用 fireChannelRead 方法，主要目的是将累积区的内容 decode 到 数组中</span></span><br><span class="line">            callDecode(ctx, cumulation, out);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (DecoderException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> DecoderException(t);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// ......</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 非ByteBuf，直接将当前对象向下进行传播</span></span><br><span class="line">        ctx.fireChannelRead(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>. 从对象池中取出一个空的数组。</span><br><span class="line"><span class="number">2</span>. 判断成员变量是否是第一次使用，将 unsafe 中传递来的数据写入到这个 cumulation 累积区中。</span><br><span class="line"><span class="number">3</span>. 写到累积区后，调用子类的 decode 方法，尝试将累积区的内容解码，每成功解码一个，就调用后面节点的 channelRead 方法。若没有解码成功，什么都不做。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Cumulator cumulator = MERGE_CUMULATOR;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Cumulator MERGE_CUMULATOR = <span class="keyword">new</span> Cumulator() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ByteBuf <span class="title">cumulate</span><span class="params">(ByteBufAllocator alloc, ByteBuf cumulation, ByteBuf in)</span> </span>&#123;</span><br><span class="line">        ByteBuf buffer;</span><br><span class="line">        <span class="comment">// 判断当前cumulation是否可写</span></span><br><span class="line">        <span class="keyword">if</span> (cumulation.writerIndex() &gt; cumulation.maxCapacity() - in.readableBytes()</span><br><span class="line">                || cumulation.refCnt() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 扩容</span></span><br><span class="line">            buffer = expandCumulation(alloc, cumulation, in.readableBytes());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            buffer = cumulation;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 把当前数据写入到累加器</span></span><br><span class="line">        buffer.writeBytes(in);</span><br><span class="line">        <span class="comment">// 把读进来的数据进行释放</span></span><br><span class="line">        in.release();</span><br><span class="line">        <span class="keyword">return</span> buffer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">将 unsafe.read 传递过来的 ByteBuf 的内容写入到 cumulation 累积区中，然后释放掉旧的内容，由于这个变量是成员变量，因此可以多次调用 channelRead 方法写入。</span><br><span class="line"></span><br><span class="line">同时这个方法也考虑到了扩容的问题。</span><br></pre></td></tr></table></figure><h3 id="调用子类的decode方法进行解析"><a href="#调用子类的decode方法进行解析" class="headerlink" title="调用子类的decode方法进行解析"></a>调用子类的decode方法进行解析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">callDecode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 如果累计区还有可读字节</span></span><br><span class="line">        <span class="keyword">while</span> (in.isReadable()) &#123;</span><br><span class="line"><span class="comment">// mark 解析前数组大小</span></span><br><span class="line">            <span class="keyword">int</span> outSize = out.size();</span><br><span class="line">            <span class="comment">// 判断list中是否有对象</span></span><br><span class="line">            <span class="keyword">if</span> (outSize &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 调用后面的业务 handler 的  ChannelRead 方法向下传播</span></span><br><span class="line">                fireChannelRead(ctx, out, outSize);</span><br><span class="line">                <span class="comment">// 清空 list</span></span><br><span class="line">                out.clear();</span><br><span class="line">                <span class="comment">// 解码过程中如果当前 context 被 remove 掉，直接 break</span></span><br><span class="line">                <span class="keyword">if</span> (ctx.isRemoved()) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                outSize = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// mark 当前可读字节数</span></span><br><span class="line">            <span class="keyword">int</span> oldInputLength = in.readableBytes();</span><br><span class="line">            <span class="comment">// 调用 decode 方法，将成功解码后的数据放入 out 数组中，</span></span><br><span class="line">            decode(ctx, in, out);</span><br><span class="line">            <span class="comment">// 解码过程中如果当前 context 被 remove 掉，直接 break</span></span><br><span class="line">            <span class="keyword">if</span> (ctx.isRemoved()) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 判断 decode 方法是否解析出对象</span></span><br><span class="line">            <span class="keyword">if</span> (outSize == out.size()) &#123;</span><br><span class="line">                <span class="comment">// 当前累加器数据是否可以拼装成一个完整的数据包</span></span><br><span class="line">                <span class="keyword">if</span> (oldInputLength == in.readableBytes()) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;<span class="comment">//当前到数据，但没有解析到对象，continue</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">// 没有从累加器中读取数据</span></span><br><span class="line">            <span class="keyword">if</span> (oldInputLength == in.readableBytes()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> DecoderException(</span><br><span class="line">                        StringUtil.simpleClassName(getClass()) +</span><br><span class="line">                        <span class="string">".decode() did not read anything but decoded a message."</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (isSingleDecode()) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (DecoderException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable cause) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> DecoderException(cause);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">该方法主要逻辑：只要累积区还有未读数据，就循环进行读取。</span><br><span class="line"><span class="number">1</span>. 调用 decode 方法，内部调用了子类重写的 decode 方法。decode 方法的逻辑就是将累积区的内容按照约定进行解码，如果成功解码，就添加到数组中。同时该方法也会检查该 handler 的状态，如果被移除出 pipeline 了，就将累积区的内容直接刷新到后面的 handler 中。</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>. 如果 Context 节点被移除了，直接结束循环。如果解码前的数组大小和解码后的数组大小相等，且累积区的可读字节数没有变化，说明此次读取什么都没做，就直接结束。如果字节数变化了，说明虽然数组没有增加，但确实在读取字节，就再继续读取。</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>. 如果上面的判断过了，说明数组读到数据了，但如果累积区的 readIndex 没有变化，则抛出异常，说明没有读取数据，但数组却增加了，子类的操作是不对的。</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>. 如果是个单次解码器，解码一次就直接结束了。</span><br><span class="line"></span><br><span class="line">所以，这段代码的关键就是子类需要重写 decode 方法，将累积区的数据正确的解码并添加到数组中。每添加一次成功，就会调用 fireChannelRead 方法，将数组中的数据传递给后面的 handler。完成之后将数组的 size 设置为 <span class="number">0</span>.</span><br><span class="line"></span><br><span class="line">所以，如果你的业务 handler 在这个地方可能会被多次调用。也可能一次也不调用。取决于数组中的值。当然，如果解码 handler 被移除了，就会将累积区的所有数据刷到后面的 handler。</span><br></pre></td></tr></table></figure><h3 id="将解析到的ByteBuf向下传播"><a href="#将解析到的ByteBuf向下传播" class="headerlink" title="将解析到的ByteBuf向下传播"></a>将解析到的ByteBuf向下传播</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> ByteBuf) &#123;</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> DecoderException(t);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 如果累计区没有可读字节了</span></span><br><span class="line">            <span class="keyword">if</span> (cumulation != <span class="keyword">null</span> &amp;&amp; !cumulation.isReadable()) &#123;</span><br><span class="line">                numReads = <span class="number">0</span>;<span class="comment">// 将次数归零</span></span><br><span class="line">                cumulation.release();<span class="comment">// 释放累计区</span></span><br><span class="line">                cumulation = <span class="keyword">null</span>;<span class="comment">// Help GC</span></span><br><span class="line">            &#125; <span class="comment">// 如果超过了 16 次，就压缩累计区，主要是将已经读过的数据丢弃，将 readIndex 归零。</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (++ numReads &gt;= discardAfterReads) &#123;</span><br><span class="line">                numReads = <span class="number">0</span>;</span><br><span class="line">                discardSomeReadBytes();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> size = out.size();</span><br><span class="line">            <span class="comment">// 如果没有向数组插入过任何数据</span></span><br><span class="line">            decodeWasNull = !out.insertSinceRecycled();</span><br><span class="line">            <span class="comment">// 循环数组，向后面的 handler 发送数据，如果数组是空，那不会调用</span></span><br><span class="line">            fireChannelRead(ctx, out, size);</span><br><span class="line">            <span class="comment">// 将数组回收</span></span><br><span class="line">            out.recycle();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 非ByteBuf，直接将当前对象向下进行传播</span></span><br><span class="line">        ctx.fireChannelRead(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1</span>. 如果累积区没有可读数据了，将计数器归零，并释放累积区。</span><br><span class="line"><span class="number">2</span>. 如果不满足上面的条件，且计数器超过了 <span class="number">16</span> 次，就压缩累积区的内容，压缩手段是删除已读的数据。将 readIndex 置为 <span class="number">0</span>。</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fireChannelRead</span><span class="params">(ChannelHandlerContext ctx, CodecOutputList msgs, <span class="keyword">int</span> numElements)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numElements; i ++) &#123;</span><br><span class="line">        <span class="comment">// 将解析出来的每一个对象向下传播</span></span><br><span class="line">        ctx.fireChannelRead(msgs.getUnsafe(i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">将 read 方法的数据读取到累积区，使用解码器解码累积区的数据，解码成功一个就放入到一个数组中，并将数组中的数据一次次的传递到后面的handler。</span><br><span class="line"></span><br><span class="line">记录 decodeWasNull 属性，这个值的决定来自于你有没有成功的向数组中插入数据，如果插入了，它就是 fasle，没有插入，他就是 <span class="keyword">true</span>。这个值的作用在于，当 channelRead 方法结束的时候，执行该 decoder 的 channelReadComplete 方法（如果你没有重写的话），会判断这个值</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>解码的主要逻辑就是将所有的数据全部放入累积区，子类从累积区取出数据进行解码后放入到一个 数组中，ByteToMessageDecoder 会循环数组调用后面的 handler 方法，将数据一帧帧的发送到业务 handler 。完成这个的解码逻辑。</p><p>可以说，ByteToMessageDecoder 是解码器的核心，Netty 所有的解码器，都可以在此类上扩展，一切取决于 decode 的实现。只要遵守 ByteToMessageDecoder 的约定即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;netty学习系列笔记总结，解码器抽象父类-ByteToMessageDecoder源码浅析，错误之处欢迎指正, 共同学习&lt;/p&gt;
    
    </summary>
    
    
      <category term="Netty" scheme="https://blog.tolvyou.cn/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>netty内存管理-bytebuf总结</title>
    <link href="https://blog.tolvyou.cn/2018/11/19/netty-bytebuf-review/"/>
    <id>https://blog.tolvyou.cn/2018/11/19/netty-bytebuf-review/</id>
    <published>2018-11-19T10:13:27.000Z</published>
    <updated>2019-02-08T08:15:09.656Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>netty学习系列笔记总结，bytebuf总结，错误之处欢迎指正, 共同学习</p><h3 id="ByteBuf介绍"><a href="#ByteBuf介绍" class="headerlink" title="ByteBuf介绍"></a>ByteBuf介绍</h3><blockquote><p>内存分配负责把数据从底层 IO 读到 ByteBuf 传递应用程序，应用程序处理完之后再把数据封装成 ByteBuf 写回到 IO，ByteBuf 是直接与底层 IO 打交道的抽象</p></blockquote><a id="more"></a><h3 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Scratch</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        PooledByteBufAllocator allocator = PooledByteBufAllocator.DEFAULT;</span><br><span class="line">        <span class="comment">//int page = 1024 * 8;</span></span><br><span class="line">        <span class="comment">//allocator.directBuffer(2 * page);</span></span><br><span class="line">        <span class="comment">//allocator.directBuffer(16);</span></span><br><span class="line">        ByteBuf byteBuf = allocator.directBuffer(<span class="number">16</span>);</span><br><span class="line">        byteBuf.release();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ByteBuf结构以及重要api"><a href="#ByteBuf结构以及重要api" class="headerlink" title="ByteBuf结构以及重要api"></a>ByteBuf结构以及重要api</h3><p><strong>ByteBuf结构</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+-------------------+------------------+------------------+</span><br><span class="line">| discardable bytes |  readable bytes  |  writable bytes  |</span><br><span class="line">|                   |     (CONTENT)    |                  |</span><br><span class="line">+-------------------+------------------+------------------+</span><br><span class="line">|                   |                  |                  |</span><br><span class="line"><span class="number">0</span>      &lt;=      readerIndex   &lt;=   writerIndex    &lt;=    capacity</span><br><span class="line">               [读数据指针]         [写数据指针]</span><br></pre></td></tr></table></figure><p><strong>read，write，set方法</strong></p><p>read 方法读数据在当前 readerIndex 指针开始往后读， readByte()/readShort()/readInt()/readLong() 把 readerIndex 指针往前移一格，读 readerIndex 指针后面 1/2/4/8 个字节数据，write 方法把数据写到 ByteBuf， read/write 方法 readerIndex/writerIndex 指针往后移动，set 方法在当前指针设置成指定值，不会移动指针</p><p><strong>mark，reset方法</strong></p><p>mark 方法标记当前 readerIndex/writerIndex 指针，reset 方法还原之前读/写数据 readerIndex/writerIndex 指针，不会改变 readerIndex/writerIndex 指针。确保指针读/写完数据能够保持原样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">readableBytes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> writerIndex - readerIndex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">writableBytes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> capacity() - writerIndex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxWritableBytes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> maxCapacity() - writerIndex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>ByteBuf分类</strong></p><blockquote><p>AbstractByteBuf 抽象实现 ByteBuf。保存和标记读写指针，记录 ByteBuf 最多分配容量及抽象方法子类实现</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.Pooled 和 Unpooled</span><br><span class="line">Pooled 池化内存分配每次都是从预先分配好的一块内存取一段连续内存封装成 ByteBuf 提供给应用程序。</span><br><span class="line">Unpooled 非池化每次进行内存分配的时候直接调用系统 API 向操作系统申请一块内存，直接分配。</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>.Unsafe 和非Unsafe</span><br><span class="line">Unsafe 直接获取 ByteBuf 在 JVM 的内存地址，基于内存地址调用 JDK 的Unsafe 进行读写操作，使用 UnsafeByteBufUtil.getByte(memory, idx(index)) 通过 ByteBuf 底层分配内存首地址和当前指针基于内存偏移地址获取对应的值。</span><br><span class="line">非Unsafe 不依赖 JDK 底层 Unsafe 对象，使用 HeapByteBufUtil.getByte(array, index) 通过内存数组和索引获取对应的值。</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>.Heap 和 Direct</span><br><span class="line">Heap 在堆上进行内存分配，分配内存需要被 GC 管理无需手动释放内存，依赖底层<span class="keyword">byte</span> 数组。</span><br><span class="line">Direct 调用 JDK 的 API 进行内存分配，分配内存不受 JVM 控制。最终不会参与 GC 过程，需要手动释放内存避免造成内存无法释放，依赖 DirectByteBuffer 对象内存，分配工具: Unpooled$directBuffer()方法</span><br></pre></td></tr></table></figure><p><strong>ByteBufAllocator分析</strong></p><blockquote><p>ByteBuf 通过 ByteBufAllocator 内存分配管理器分配内存，内存分配管理器最顶层抽象负责分配所有类型的内存</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.ByteBufAllocator功能</span><br><span class="line">ByteBufAllocator 重载 buffer() 方法分配一块内存。buffer()方法分配内存是否为 Direct/Heap内存依赖具体实现。</span><br><span class="line">ioBuffer() 方法分配内存更希望是适合 IO 的 Direct Buffer，directBuffer()/headBuffer()方法堆内/堆外进行内存分配。</span><br><span class="line">compositeBuffer() 方法分配将两个 ByteBuf 合并变成CompositeByteBuf</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>.AbstractByteBufAllocator</span><br><span class="line">AbstractByteBufAllocator 抽象实现 ByteBufAllocator。</span><br><span class="line">buffer() 方法分配 Buffer 依赖实现分配内存，调用 directBuffer()/heapBuffer() 方法分配默认 Buffer 容量和最大扩充容量的ByteBuf。</span><br><span class="line">newDirectBuffer()/newHeapBuffer() 方法分配 Pooled/Unpooled 依赖底层实现</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>.ByteBufAllocator两个子类</span><br><span class="line">PooledByteBufAllocator 从预先分配好的内存取一段内存，UnpooledByteBufAllocator 调用系</span><br><span class="line">统API 分配内存，调用 hasUnsafe() 方法获取 Unsafe 决定分配 Unsafe/非Unsafe</span><br></pre></td></tr></table></figure><p><strong>UnPooledByteBufAllocator分析</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.heap内存的分配</span><br><span class="line">newHeapBuffer() 方法通过 hasUnsafe() 方法判断是否有 Unsafe。传递【initialCapacity容</span><br><span class="line">量，Byte数组】参数 setArray() 方法设置 array 以及 setIndex() 方法设置读/写指针创建</span><br><span class="line">UnpooledUnsafeHeapByteBuf/UnpooledHeapByteBuf，_get***() 方法通过 Unsafe 方式返回数</span><br><span class="line">组对象偏移量对应的数组索引方式返回 array 数组 index位置<span class="keyword">byte</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span>.direct内存的分配</span><br><span class="line">newDirectBuffer() 方法通过 hasUnsafe() 方法判断是否有 Unsafe。</span><br><span class="line">调用 allocateDirect(initialCapacity)创建Direct。ByteBuffer 使用 setByteBuffer() 方</span><br><span class="line">法设置  buffer[UnpooledUnsafeDirectByteBuf 使用 directBufferAddress() 方法获取 </span><br><span class="line">buffer 内存地址设置memoryAddress ]创建 UnpooledUnsafeDirectByteBuf/</span><br><span class="line">UnpooledDirectByteBuf，_get***()方法通过 addr() 方法 memoryAdress+index 计算内存地址</span><br><span class="line">Unsafe 获取对应这块内存的 <span class="keyword">byte</span>/ByteBuffer获取 buffer index位置对应的<span class="keyword">byte</span></span><br></pre></td></tr></table></figure><p><strong>PooledByteBufAllocator概述</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.拿到线程局部缓存PoolThreadCache-&gt;threadCache.get()</span><br><span class="line">通过 PoolThreadLocalCache 类型成员变量 threadCache 的 get() 方法获取当前线程的</span><br><span class="line">PoolThreadCache 局部缓存 cache，不同线程在对象内存堆上进行分配，PoolThreadLocalCache</span><br><span class="line">[继承FastThreadLocal]的 initialValue() 方法通过 heapArenas/directArenas 调用</span><br><span class="line">leastUsedArena() 方法获取 heapArena/directArena 数组，构造PoolThreadLocalCache</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>.在线程局部缓存的Arena上进行内存分配</span><br><span class="line">线程局部缓存 PoolThreadCache 维护两块内存：heapArena/directArena堆内/堆外内存，初始化</span><br><span class="line">PoolThreadLocalCache 通过 heapArenas/directArenas 调用 leastUsedArena() 方法获取用</span><br><span class="line">到最少的 heapArena/directArena 竞技场，heapArenas/directArenas 通过构造PooledByteBufAllocator 调用newArenaArray() 方法根据 DEFAULT_NUM_HEAP/DIRECT_ARENA[max(io.netty.allocator.numHeap/DirectArenas,min(runtime.availableProcessors()*<span class="number">2</span></span><br><span class="line">[默认使用<span class="number">2</span>倍CPU核数减少同步不用加锁分配],runtime.maxMemory()/io.netty.allocator.pageSize &lt;&lt; io.netty.allocator.maxOrder/<span class="number">2</span>/<span class="number">3</span>))]容量创建PoolArena数组遍历设置PoolArena的HeapArena/DirectArena</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>.PooledByteBufAllocator结构</span><br><span class="line">   --------      --------      --------      --------</span><br><span class="line">   |Thread|      |Thread|      |Thread|      |Thread|</span><br><span class="line">   --------      --------      --------      --------</span><br><span class="line">  -----|-------------|-------------|-------------|-----</span><br><span class="line">  | -------       -------       -------       ------- |</span><br><span class="line">  | |Arena|       |Arena|       |Arena|       |Arena| |</span><br><span class="line">  | -------       -------       -------       ------- |</span><br><span class="line">  | -----------------    tinyCacheSize                |</span><br><span class="line">  | |PoolThreadCache|    smallCacheSize               |</span><br><span class="line">  | -----------------    normalCacheSize              |</span><br><span class="line">  -----------------------------------------------------</span><br><span class="line">创建 ByteBuffer 通过 PoolThreadCache 获取 Arena 对象，PoolThreadCache 通过ThreadLocal 方式把内存分配器 Arena 塞到成员变量，每个线程调用 get()方法获取到对应</span><br><span class="line">的Arena，即线程与Arena绑定。或者通过底层维护的 ByteBuffer 缓存列表譬如创建<span class="number">1024</span>字节的</span><br><span class="line">ByteBuffer用完释放其他地方继续分配<span class="number">1024</span>字节内存通过ByteBuffer缓存列表返回，PooledByteBufAllocator 维护 tinyCacheSize、smallCacheSize 以及 normalCacheSize 缓存 ByteBuffer 的大小用来构造 PooledByteBufAllocator 使用 createSubPageCaches() 方法创建 MemoryRegionCache 数组缓存列表</span><br></pre></td></tr></table></figure><p><strong>directArena分配direct内存的流程</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.从对象池里面拿到PooledByteBuf进行复用</span><br><span class="line">调用 newByteBuf() 方法使用 PooledUnsafeDirectByteBuf/PooledDirectByteBuf 的</span><br><span class="line">newInstance()方法通过对象池 RECYCLER 的 get() 方法获取 PooledDirectByteBuf 对象。</span><br><span class="line">调用reuse() 方法复用，按照指定maxCapacity扩容，设置引用数量为<span class="number">1</span>以及设置readerIndex/</span><br><span class="line">writerIndex读/写指针为<span class="number">0</span>，重置markedReaderIndex/markedWriterIndex，标记读/写指针为<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span>.从缓存上进行内存分配</span><br><span class="line">ByteBuf 之前使用过并且被 release。分配差不多规格大小 ByteBuf 当 capacity&lt;pageSize </span><br><span class="line">或者capacity&lt;=chunkSize 调用 cache的allocateTiny()/allocateSmall()/allocateNormal() 方法在缓存上进行内存分配</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>.从内存堆里面进行内存分配</span><br><span class="line">未命中缓存当 capacity&lt;pageSize 或者 capacity&lt;=chunkSize 调用allocateNormal() 方法。</span><br><span class="line">当capacity&gt;chunkSize 调用 allocateHuge() 方法在内存堆里面进行内存分配</span><br></pre></td></tr></table></figure><p><strong>内存规格的介绍</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">0</span> &lt;-tiny-&gt;<span class="number">512</span>B&lt;-small-&gt;<span class="number">8</span>K&lt;-normal-&gt;<span class="number">16</span>M&lt;-huge-&gt;</span><br><span class="line">   |_____________________|            |</span><br><span class="line">           SubPage      Page        Chunk</span><br><span class="line"><span class="number">16</span>M 作为分界点对应的 Chunk，所有的内存申请以 Chunk 为单位向操作系统申请，内存分配在 Chunk 里面执行相应操作。</span><br><span class="line"><span class="number">16</span>M Chunk 按照 Page 进行切分为 <span class="number">2048</span> 个 Page，<span class="number">8</span>K Page 按照 SubPage 切分命中缓存的分配逻辑</span><br></pre></td></tr></table></figure><p><strong>缓存数据结构</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">  --------------------------MemoryRegionCache----------------------------</span><br><span class="line">  | queue:      Chunk&amp;Handler   Chunk&amp;Handler    .....   Chunk&amp;Handler  |</span><br><span class="line">  | sizeClass:   tiny(<span class="number">0</span>~<span class="number">512</span>B)   small(<span class="number">512</span>B~<span class="number">8</span>K)           normal(<span class="number">8</span>K~<span class="number">16</span>M) |</span><br><span class="line">  | size:           N*<span class="number">16</span>B       <span class="number">512</span>B、<span class="number">1</span>K、<span class="number">2</span>K、<span class="number">4</span>K           <span class="number">8</span>K、<span class="number">16</span>K、<span class="number">32</span>K  |</span><br><span class="line">  -----------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">queue 由 Entry[Chunk&amp;Handler，Handler指向唯一一段连续内存，Chunk+指向Chunk的一段连续内存确定 Entry 的内存大小和内存位置]组成Cache链。</span><br><span class="line">在缓存里查找有无对应的链定位到 queue 里面的 Entry，sizeClass即内存规格包括 tiny(<span class="number">0</span>~<span class="number">512</span>B)、small(<span class="number">512</span>B~<span class="number">8</span>K) 以及 normal(<span class="number">8</span>K~<span class="number">16</span>M)，size 即 MemoryRegionCache 缓存</span><br><span class="line">ByteBuf 的大小，同一个 MemoryRegionCache的queue 里面所有元素都是固定的大小，包括tiny</span><br><span class="line">(N*<span class="number">16</span>B)、small(<span class="number">512</span>B、<span class="number">1</span>K、<span class="number">2</span>K、<span class="number">4</span>K) 以及 normal(<span class="number">8</span>K、<span class="number">16</span>K、<span class="number">32</span>K)</span><br><span class="line"></span><br><span class="line">  --------------MemoryRegionCache-------------</span><br><span class="line">  | tiny[<span class="number">32</span>]   <span class="number">0</span>   <span class="number">16</span>B <span class="number">32</span>B <span class="number">48</span>B ... <span class="number">480</span>B <span class="number">496</span>B |</span><br><span class="line">  | small[<span class="number">4</span>]       <span class="number">512</span>B    <span class="number">1</span>K    <span class="number">2</span>K    <span class="number">4</span>K    |</span><br><span class="line">  | normal[<span class="number">3</span>]          <span class="number">8</span>K    <span class="number">16</span>K    <span class="number">32</span>K      |</span><br><span class="line">  --------------------------------------------</span><br><span class="line"></span><br><span class="line">queue 存储每种大小的 ByteBuf，sizeClass包括 Tiny、Small以及 Normal，同一个size 的</span><br><span class="line">ByteBuf有哪些可以直接利用，每个线程维护 PoolThreadCache 涵盖 tinySubPageHeap/DirectCaches、smallSubPageHeap/DirectCaches、normalHeap/DirectCaches 三种内存规格大小缓存 Cache，调用createSubPageCaches()/createNormalCaches() 方法创建MemoryRegionCache 数组</span><br></pre></td></tr></table></figure><p><strong>命中缓存的分配流程</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">申请内存调用 normalizeCapacity() 方法 reqCapacity 大于Tiny找<span class="number">2</span>的幂次方数值确保数值大于等于reqCapacity，Tiny内存规格以<span class="number">16</span>的倍数自增分段规格化，目的是为了缓存分配后续 release 放到缓存里面而不需要释放，调用cache 的 allocateTiny()/allocateSmall()/allocateNormal()方法分配缓存</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>.找到对应 size 的 MemoryRegionCache-&gt;cacheForTiny()/cacheForSmall()/cacheForNormal()调用cacheForTiny()/cacheForSmall()/cacheForNormal()方法使用PoolArena的tinyIdx()/smallIdx()/log2(normCapacity&gt;&gt;numShiftsNormalDirect/numShiftsNormalHeap)方法计算索引通过数组下标方式获取缓存节点MemoryRegionCache</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>.从queue中弹出一个entry[chunk连续内存]给ByteBuf初始化调用queue的poll()方法弹出个entry使用initBuf()方法根据entry的chunk和handle通过initBuf()/initBufWithSubpage()方法调用PooledByteBuf的init()方法设置ByteBuf的chunk和handle给ByteBuf初始化</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>.将弹出的entry扔到对象池进行复用-&gt;entry.recycle()调用entry的recycle()方法设置chunk为<span class="keyword">null</span>&amp;handle为-<span class="number">1</span>使用recyclerHandle的recycle()方法压到栈里扔到对象池后续ByteBuf回收从对象池获取entry将entry的chunk和handle指向被回收的ByteBuf进行复用减少GC以及减少对象重复创建和销毁</span><br></pre></td></tr></table></figure><p><strong>arena、chunk、page、subpage概念</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">  PoolThreadCache</span><br><span class="line">  -------------</span><br><span class="line">  | --------- |</span><br><span class="line">  | | Cache | |</span><br><span class="line">  | --------- |</span><br><span class="line">  | --------- |</span><br><span class="line">  | | Arena | |</span><br><span class="line">  | --------- |</span><br><span class="line">  -------------</span><br><span class="line">Arena划分开辟连续内存进行分配，Cache直接缓存连续内存进行分配</span><br><span class="line">                             Arena</span><br><span class="line">  -------------------------------------------------------------</span><br><span class="line">  | -------------         -------------         ------------- |</span><br><span class="line">  | | --------- |         | --------- |         | --------- | |</span><br><span class="line">  | | | Chunk | |         | | Chunk | |         | | Chunk | | |</span><br><span class="line">  | | --------- |         | --------  |         | --------- | |</span><br><span class="line">  | |    | |    |--------&gt;|    | |    |--------&gt;|    | |    | |</span><br><span class="line">  | | --------- |         | --------  |         | --------- | |</span><br><span class="line">  | | | Chunk | |         | | Chunk | |         | | Chunk | | |</span><br><span class="line">  | | --------- |         | --------  |         | --------- | |</span><br><span class="line">  | |    | |    |&lt;--------|    | |    |&lt;--------|    | |    | |</span><br><span class="line">  | | --------- |         | --------  |         | --------- | |</span><br><span class="line">  | | | Chunk | |         | | Chunk | |         | | Chunk | | |</span><br><span class="line">  | | --------- |         | --------  |         | --------- | |</span><br><span class="line">  | -------------         -------------         ------------- |</span><br><span class="line">  |   ChunkList              ChunkList             ChunkList  |</span><br><span class="line">  -------------------------------------------------------------</span><br><span class="line">Arena的ChunkList[每个节点都是Chunk]通过链表方式连接并且每个ChunkList里面有对应的Chunk进行双向链表连接是因为实时计算每个Chunk的分配情况按照内存使用率分别归为ChunkList</span><br><span class="line">PoolArena维护不同使用率的PoolChunkList即Chunk集合q100/q075/q050/q025/q000/qInit调用prevList()方法双向链表连接</span><br><span class="line"></span><br><span class="line"> ---------------------      ---------------------</span><br><span class="line">  | ------     ------ |      | ------     ------ |</span><br><span class="line">  | | <span class="number">8</span>K | ... | <span class="number">8</span>K | |      | | <span class="number">2</span>K | ... | <span class="number">2</span>K | |</span><br><span class="line">  | ------     ------ |      | ------     ------ |</span><br><span class="line">  | ------     ------ |      | ------     ------ |</span><br><span class="line">  | | <span class="number">8</span>K | ... | <span class="number">8</span>K | |      | | <span class="number">2</span>K | ... | <span class="number">2</span>K | |</span><br><span class="line">  | ------     ------ |      | ------     ------ |</span><br><span class="line">  ---------------------      ---------------------</span><br><span class="line">          Chunk                     SubPage[]</span><br><span class="line"></span><br><span class="line">Chunk以<span class="number">8</span>K大小划分为Page，Page以<span class="number">2</span>K大小划分为SubPage</span><br><span class="line">PoolArena维护PoolSubpage tinySubpagePools/smallSubpagePools，PoolSubpage的chunk表示子页SubPage从属Chunk，elemSize表示子页SubPage划分数值，bitmap记录子页SubPage内存分配情况[<span class="number">0</span>:未分配/<span class="number">1</span>:已分配]，prev/next表示子页SubPage以双向链表方式连接</span><br><span class="line"></span><br><span class="line">内存分配从线程的PoolThreadCache里面获取对应的Arena，Arena通过ChunkList获取Chunk进行内存分配,Chunk内存分配判断分配内存大小超过<span class="number">1</span>个Page以Page为单位分配，远远小于<span class="number">1</span>个Page获取Page切分成若干SubPage进行内存划分</span><br></pre></td></tr></table></figure><p><strong>page 级别内存分配</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.尝试在现有的chunk上分配</span><br><span class="line">调用PoolChunkList q050/q025/q000/qInit/q075的allocate()方法尝试在现有的chunk上分配，首次PoolChunkList为空无法在现有的chunk上分配，从head节点开始往下遍历每个chunk尝试分配获取handle，handle小于<span class="number">0</span>表示未分配指向next节点继续分配，handle大于<span class="number">0</span>调用chunk的initBuf()方法初始化PooledByteBuf并且判断chunk的使用率是否超过最大使用率从当前PoolChunk移除添加到nextList下一个链表</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>.创建一个chunk进行内存分配</span><br><span class="line">调用newChunk()方法创建PoolChunk对象，通过PoolChunk的allocate()方法分配normCapacity内存获取handle指向chunk里面一块连续内存，通过allocateDirect()方法获取直接内存使用PoolChunk构造方法创建<span class="number">1</span>&lt;&lt;maxOrder[<span class="number">11</span>]容量memoryMap和depthMap一次一级地向下移动在每个级别遍历左到右并将值设置为子深度创建PoolChunk对象，调用PoolChunk对象的allocate()方法使用allocateRun()方法计算分配深度通过allocateNode()方法分配节点[从<span class="number">0</span>层开始往下查询空闲节点即未使用且大小满足normCapacity的节点，调用setValue()方法标记节点为unusable[<span class="number">12</span>]即已被使用，使用updateParentsAlloc()方法逐层往上查询父节点标记已被使用在内存中分配索引</span><br><span class="line">  <span class="number">0</span>&lt;----------------------------<span class="number">0</span>~<span class="number">16</span>M</span><br><span class="line">  <span class="number">1</span>&lt;------------------------<span class="number">0</span>~<span class="number">8</span>M    <span class="number">8</span>~<span class="number">16</span>M</span><br><span class="line">  <span class="number">2</span>&lt;----------------<span class="number">0</span>~<span class="number">4</span>M    <span class="number">4</span>~<span class="number">8</span>M    <span class="number">8</span>~<span class="number">12</span>M    <span class="number">12</span>~<span class="number">16</span>M</span><br><span class="line">                                 ...</span><br><span class="line">  <span class="number">10</span>&lt;-----------------<span class="number">0</span>~<span class="number">16</span>K    <span class="number">16</span>K~<span class="number">32</span>K    <span class="number">32</span>K~<span class="number">48</span>K ...</span><br><span class="line">  <span class="number">11</span>&lt;---------------<span class="number">0</span>~<span class="number">8</span>K   <span class="number">8</span>K~<span class="number">16</span>K  <span class="number">16</span>K~<span class="number">24</span>K  <span class="number">24</span>K~<span class="number">32</span>K  ...</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>.初始化PooledByteBuf</span><br><span class="line">调用PoolChunk的initBuf()方法初始化PooledByteBuf即获取chunk的一块连续内存过后把对应的标记打到PooledByteBuf，调用memoryMapIdx()方法计算chunk连续内存在memoryMap的索引，使用bitmapIdx()方法计算chunk连续内存在bitMap的索引，通过runOffset(memoryMapIdx)计算偏移量以及runLength()方法计算最大长度调用PooledByteBuf的init()方法设置初始化PooledByteBuf</span><br></pre></td></tr></table></figure><p><strong>subpage 级别的内存分配</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">调用tinyIdx()方法计算normCapacity&gt;&gt;<span class="number">4</span>获取tinySubpagePools的索引tableIdx，根据tableIdx获取tinySubpagePools下标位置的PoolSubpage头节点head，默认情况头节点head无任何内存信息指向它自己表示当前头节点head为空,头节点head的后置节点next非头节点head本身调用initBufWithSubpage()方法初始化PooledByteBuf，反之调用allocateNormal()方法进行subpage级别的内存分配</span><br><span class="line"></span><br><span class="line">  -------------tinySubpagePools--------------</span><br><span class="line">  | tiny[<span class="number">32</span>]   <span class="number">0</span>  <span class="number">16</span>B <span class="number">32</span>B <span class="number">48</span>B ... <span class="number">480</span>B <span class="number">496</span>B |</span><br><span class="line">  -------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>.定位一个Subpage对象</span><br><span class="line">调用allocateNormal()方法内存分配通过PoolChunk对象的allocate()方法使用allocateSubpage()方法创建/初始化normCapacity容量新PoolSubpage添加到拥有此PoolChunk的PoolArena的子页面池里,调用arena的findSubpagePoolHead()方法获取PoolArena拥有的PoolSubPage池的头部并对头节点进行同步,子页面只能从页面分配根据maxOrder分配深度调用allocateNode()方法分配节点获取节点index,使用subpageIdx()方法获取SubPage的索引subpageIdx</span><br><span class="line"></span><br><span class="line">  ---------------------</span><br><span class="line">  | ------     ------ |</span><br><span class="line">  | | <span class="number">8</span>K | ... | <span class="number">8</span>K | |</span><br><span class="line">  | ------     ------ |</span><br><span class="line">  | ------     ------ |</span><br><span class="line">  | | <span class="number">8</span>K | ... | <span class="number">8</span>K | |</span><br><span class="line">  | ------     ------ |</span><br><span class="line">  ---------------------</span><br><span class="line">    Chunk中的SubPages</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>.初始化Subpage</span><br><span class="line">以SubPage的索引获取subpages数组subpageIdx位置的subpage,subpage为空调用PoolSubpage的构造方法创建PoolSubpage,使用init()方法pageSize/normCapacity计算最大SubPage划分数量初始化位图bitmap标识Subpage是否被分配初始化PoolSubpage,调用addToPool()方法把PoolSubpage添加到头节点head所在的链表子页面池,使用allocate()方法获取位图bitmap未被使用的Subpage,可用Subpage为<span class="number">0</span>从子页面池移除Subpage,调用toHandle()方法将bitmapIdx转成为handle[对应Chunk里面第几个节点第几个Subpage即一块内存里面的哪一块连续内存]把memoryMapIdx作为低<span class="number">32</span>位和bitmapIdx作为高<span class="number">32</span>位</span><br><span class="line">  -------------tinySubpagePools--------------</span><br><span class="line">  | tiny[<span class="number">32</span>]   <span class="number">0</span>  <span class="number">16</span>B <span class="number">32</span>B <span class="number">48</span>B ... <span class="number">480</span>B <span class="number">496</span>B |</span><br><span class="line">  |               | |                       |</span><br><span class="line">  |               <span class="number">16</span>B                       |</span><br><span class="line">  -------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>.初始化PooledByteBuf</span><br><span class="line">调用PoolChunk的initBuf()方法初始化PooledByteBuf即获取chunk的一块连续内存过后把对应的标记打到PooledByteBuf,调用memoryMapIdx()方法计算chunk连续内存在memoryMap的索引,使用bitmapIdx()方法计算chunk连续内存在bitMap的索引,调用initBufWithSubpage()方法通过runOffset(memoryMapIdx)+(bitmapIdx &amp; <span class="number">0x3FFFFFFF</span>)* subpage.elemSize计算偏移量以及Subpage划分数量调用PooledByteBuf的init()方法设置初始化PooledByteBuf</span><br></pre></td></tr></table></figure><p><strong>ByteBuf的回收</strong></p><blockquote><p>调用ByteBuf的release()方法使用AbstractReferenceCountedByteBuf的release0()方法判断引用数量是否等于decrement相等调用deallocate()方法设置handle为-1表示不指向任何一块内存以及memory设置为空</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.连续的内存区段加到缓存</span><br><span class="line">调用chunk.arena.free()方法通过PoolThreadCache的add()方法把连续的内存区段[chunk&amp;handle唯一标识]添加到缓存,使用PoolThreadCache的cache()方法获取MemoryRegionCache节点,调用MemoryRegionCache的add()方法把chunk和handle封装成Entry加到queue,通过newEntry()方法获取对象池RECYCLER的Entry调用queue的offer()方法添加到queue</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>.标记连续的内存区段为未使用</span><br><span class="line">调用freeChunk()方法使用chunk.parent.free()方法通过Chunk释放连续内存,memoryMapIdx()/bitmapIdx()方法获取连续内存的memoryMapIdx/bitmapIdx,bitmapIdx不等于<span class="number">0</span>表示释放SubPage子页面内存通过arena的findSubpagePoolHead()方法获取PoolSubPage头节点head调用subpage的free()方法释放把连续内存对应的位图标识为<span class="number">0</span>,非SubPage通过分配内存反向标记将连续内存标记为未使用,Page级别完全二叉树,SubPage级别位图</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>.ByteBuf加到对象池</span><br><span class="line">调用recycle()方法通过recyclerHandle的recycle()方法将ByteBuf加到对象池即PooledByteBuf被销毁之后在对象池里面</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.ByteBuf的api和分类</span><br><span class="line">read**()/write**() 方法，AbstractByteBuf 实现ByteBuf 的数据结构抽象出一系列和数据读写相关的api给子类实现。</span><br><span class="line">ByteBuf分类按照三个维度区分：堆、Unsafe、UnPooled</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>.分配Pooled内存的总步骤:</span><br><span class="line">首先现成私有变量 PoolThreadCache 维护的缓存空间查找之前使用过被释放的内存，有的话基于连续内存进行分配，没有的话用一定算法在预先分配好的Chunk进行内存分配。</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>.不同规格的pooled内存分配与释放:</span><br><span class="line">Page级别的内存分配和释放通过完全二叉树的标记查找某一段连续内存，Page级别以下的内存分配首先查找到 Page 然后把此 Page 按照 SubPage 大小进行划分。</span><br><span class="line">最后通过位图的方式进行内存分配和释放，内存被释放的时候可能被加入到不同级别的缓存队列供下次分配使用</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>.内存的类别有哪些?</span><br><span class="line">* 堆内[基于<span class="keyword">byte</span>字节内存数组分配]/堆外[基于JDK的DirectByteBuffer内存分配]</span><br><span class="line">* Unsafe[通过JDK的Unsafe对象基于物理内存地址进行数据读写]/非Unsafe[调用JDK的API进行读写]</span><br><span class="line">* UnPooled[每次分配内存申请内存]/Pooled[预先分配好一整块内存,分配的时候用一定算法从一整块内存取出一块连续内存]</span><br><span class="line"></span><br><span class="line"><span class="number">5</span>.如何减少多线程内存分配之间的竞争?</span><br><span class="line">PooledByteBufAllocator内存分配器结构维护Arena数组，所有的内存分配都在Arena上进行，通过PoolThreadCache对象将线程和Arena进行一一绑定。</span><br><span class="line">默认情况一个Nio线程管理一个Arena实现多线程内存分配相互不受影响减少多线程内存分配之间的竞争</span><br><span class="line"></span><br><span class="line"><span class="number">6</span>.不同大小的内存是如何进行分配的?</span><br><span class="line">Page 级别的内存分配和释放通过完全二叉树的标记查找某一段连续内存，Page级别以下的内存分配首先</span><br><span class="line">查找到Page然后把此Page按照SubPage大小进行划分最后通过位图的方式进行内存分配和释放，内存被释放的时候可能被加入到不同级别的缓存队列供下次分配使用</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;netty学习系列笔记总结，bytebuf总结，错误之处欢迎指正, 共同学习&lt;/p&gt;

&lt;h3 id=&quot;ByteBuf介绍&quot;&gt;&lt;a href=&quot;#ByteBuf介绍&quot; class=&quot;headerlink&quot; title=&quot;ByteBuf介绍&quot;&gt;&lt;/a&gt;ByteBuf介绍&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;内存分配负责把数据从底层 IO 读到 ByteBuf 传递应用程序，应用程序处理完之后再把数据封装成 ByteBuf 写回到 IO，ByteBuf 是直接与底层 IO 打交道的抽象&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Netty" scheme="https://blog.tolvyou.cn/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>netty异步回调机制及对耗时业务的处理</title>
    <link href="https://blog.tolvyou.cn/2018/11/16/netty-asyc-callback/"/>
    <id>https://blog.tolvyou.cn/2018/11/16/netty-asyc-callback/</id>
    <published>2018-11-16T13:39:35.000Z</published>
    <updated>2019-02-08T08:15:52.214Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>netty学习系列笔记总结，netty如何实现异步回调机制及对耗时业务的处理，错误之处欢迎指正, 共同学习</p><h3 id="耗时业务的处理"><a href="#耗时业务的处理" class="headerlink" title="耗时业务的处理"></a>耗时业务的处理</h3><ul><li>handler 种加入线程池</li><li>context 中添加线程池</li></ul><a id="more"></a><h5 id="handler-种加入线程池"><a href="#handler-种加入线程池" class="headerlink" title="handler 种加入线程池"></a>handler 种加入线程池</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ChannelHandler</span>.Sharable</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerBusinessThreadPoolHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">ByteBuf</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ChannelHandler INSTANCE = <span class="keyword">new</span> ServerBusinessThreadPoolHandler();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, ByteBuf msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ByteBuf data = Unpooled.directBuffer();</span><br><span class="line">        data.writeBytes(msg);</span><br><span class="line">        threadPool.submit(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//耗时的操作</span></span><br><span class="line">                Thread.sleep(<span class="number">1</span> * <span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            Object result = getResult(data);</span><br><span class="line">            ctx.channel().writeAndFlush(result);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>channelRead0 方法，我们模拟了一个耗时 1 秒的操作，于是，我们将这个任务提交到了一个自定义的业务线程池中，这样，就不会阻塞 Netty 的 IO 线程。</p><p>源码分析</p><blockquote><p>判定当 outbound 的 executor 线程不是当前线程的时候，会将当前的工作封装成 task ，然后放入 mpsc 队列中，等待 IO 任务执行完毕后执行队列中的任务</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(Object msg, <span class="keyword">boolean</span> flush, ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    EventExecutor executor = next.executor();</span><br><span class="line">    <span class="keyword">if</span> (executor.inEventLoop()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (flush) &#123;</span><br><span class="line">            next.invokeWriteAndFlush(m, promise);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            next.invokeWrite(m, promise);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">        safeExecute(executor, task, promise, m);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="context-中添加线程池"><a href="#context-中添加线程池" class="headerlink" title="context 中添加线程池"></a>context 中添加线程池</h5><blockquote><p>在添加 pipeline 中的 handler 时候，添加一个线程池<br>当我们在调用 addLast 方法添加线程池后，handler 将优先使用这个线程池，如果不添加，将使用 IO 线程。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">    EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">    EventLoopGroup businessGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    ServerBootstrap bootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">    bootstrap.group(bossGroup, workerGroup);</span><br><span class="line">    bootstrap.channel(NioServerSocketChannel.class);</span><br><span class="line">    bootstrap.childOption(ChannelOption.SO_REUSEADDR, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    bootstrap.childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> </span>&#123;</span><br><span class="line">            ch.pipeline().addLast(businessGroup, ServerBusinessHandler.INSTANCE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    bootstrap.bind(Constant.PORT).addListener((ChannelFutureListener) future -&gt; System.out.println(<span class="string">"bind success in port: "</span> + Constant.PORT));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>源码分析</p><blockquote><p>以下代码跟踪可参考 <a href="http://blog.tolvyou.cn/2018/11/04/netty-startup-details/">netty启动过程源码分析</a> 中 register0 方法</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> EventExecutor <span class="title">executor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (executor == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> channel().eventLoop();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> executor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 this.executor 为 null，就返回 channel().eventLoop()，这个是 io 读写线程,肯定是不能执行耗时任务的。而如果在调用 addLast 方法添加线程池后，handler 将优先使用这个线程池</p><h3 id="异步回调机制"><a href="#异步回调机制" class="headerlink" title="异步回调机制"></a>异步回调机制</h3><blockquote><p>假设有小王和小李2个同学。小王不断的从Task队列中取出一个Task, 如果队列为空, 那么小王就什么也不做, 如果该Task是一个耗时任务, 而小王执行该任务的话, 后面的Task会得不到执行, 于是, 小王可以将Task交给小李执行, 这样, 小王就可以继续执行下一个Task了, 而小李执行完毕后, 将执行结果作为了Task放入到小王的任务队列中去, 这样, 当小王执行到该任务时, 也就得到了结果</p></blockquote><h5 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String strFormat = <span class="string">" %s,这是一道%s的题"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//任务队列</span></span><br><span class="line">    BlockingQueue&lt;Runnable&gt; taskQueue;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Person</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        taskQueue = <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Runnable task = taskQueue.take();</span><br><span class="line">                task.run();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将任务提交到任务队列中去</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">submit</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line">        taskQueue.offer(task);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Person wang = <span class="keyword">new</span> Person(<span class="string">"小王"</span>);</span><br><span class="line">        <span class="keyword">final</span> Person li = <span class="keyword">new</span> Person(<span class="string">"小李"</span>);</span><br><span class="line">        <span class="comment">//启动小李</span></span><br><span class="line">        li.start();</span><br><span class="line">        <span class="comment">//启动小王</span></span><br><span class="line">        wang.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//提交一个简单的题</span></span><br><span class="line">        wang.submit(() -&gt; &#123;</span><br><span class="line">            System.out.println(</span><br><span class="line">                    Thread.currentThread().getName() + String.format(strFormat,<span class="number">1</span>,<span class="string">"简单"</span>));</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将复杂的题交给li来做</span></span><br><span class="line">        wang.submit(() -&gt; li.submit(() -&gt; &#123;</span><br><span class="line">            System.out.println(</span><br><span class="line">                    Thread.currentThread().getName() + String.format(strFormat,<span class="number">2</span>,<span class="string">"复杂"</span>));</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//做完之后将结果作为Task返回给wang</span></span><br><span class="line">            wang.submit(() -&gt; System.out.println(</span><br><span class="line">                    Thread.currentThread().getName() + <span class="string">" 得到复杂题执行结果"</span>));</span><br><span class="line">        &#125;));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//提交一个简单的题</span></span><br><span class="line">        wang.submit(() -&gt; System.out.println(</span><br><span class="line">                Thread.currentThread().getName() + String.format(strFormat,<span class="number">3</span>,<span class="string">"简单"</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">小王 <span class="number">1</span>,这是一道简单的题</span><br><span class="line">小王 <span class="number">3</span>,这是一道简单的题</span><br><span class="line">小李 <span class="number">2</span>,这是一道复杂的题</span><br><span class="line">小王 得到复杂题执行结果</span><br></pre></td></tr></table></figure><h5 id="Netty中的实现"><a href="#Netty中的实现" class="headerlink" title="Netty中的实现"></a>Netty中的实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyPerson</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String strFormat = <span class="string">" %s,这是一道%s的题"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> DefaultEventExecutor wang = <span class="keyword">new</span> DefaultEventExecutor();</span><br><span class="line">        <span class="keyword">final</span> DefaultEventExecutor li = <span class="keyword">new</span> DefaultEventExecutor();</span><br><span class="line"></span><br><span class="line">        wang.execute(() -&gt; System.out.println(</span><br><span class="line">                Thread.currentThread().getName() + String.format(strFormat,<span class="number">1</span>,<span class="string">"简单"</span>)));</span><br><span class="line"></span><br><span class="line">        wang.execute(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 生成一个promise</span></span><br><span class="line">            <span class="keyword">final</span> Promise&lt;Integer&gt; promise = wang.newPromise();</span><br><span class="line">            <span class="comment">// 为该promise注册一个listener, 当任务执行完后回调该listener.该listener在异步任务提交者线程中执行</span></span><br><span class="line">            promise.addListener(future -&gt; System.out.println(</span><br><span class="line">                    Thread.currentThread().getName() + <span class="string">" 复杂题执行结果"</span>));</span><br><span class="line">            <span class="comment">// 在另一个线程中执行一个异步任务, 执行完后, 将promise设置为成功</span></span><br><span class="line">            li.execute(() -&gt; &#123;</span><br><span class="line">                System.out.println(<span class="string">"执行计算任务的线程 "</span> + Thread.currentThread());</span><br><span class="line">                promise.setSuccess(<span class="number">10</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        wang.execute(() -&gt; System.out.println(</span><br><span class="line">                Thread.currentThread().getName() + String.format(strFormat,<span class="number">3</span>,<span class="string">"简单"</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">defaultEventExecutor-<span class="number">1</span>-<span class="number">1</span> <span class="number">1</span>,这是一道简单的题</span><br><span class="line">defaultEventExecutor-<span class="number">1</span>-<span class="number">1</span> <span class="number">3</span>,这是一道简单的题</span><br><span class="line">执行计算任务的线程 Thread[defaultEventExecutor-<span class="number">3</span>-<span class="number">1</span>,<span class="number">5</span>,main]</span><br><span class="line">defaultEventExecutor-<span class="number">1</span>-<span class="number">1</span> 复杂题执行结果</span><br></pre></td></tr></table></figure><p>源码分析<br>DefaultPromise.setSuccess(V result)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Promise&lt;V&gt; <span class="title">setSuccess</span><span class="params">(V result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (setSuccess0(result)) &#123;</span><br><span class="line">        notifyListeners();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"complete already: "</span> + <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DefaultPromise.notifyListeners()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果当前线程不是executor, 就将notifyListener包装成一个Task添加了executor的</span></span><br><span class="line"><span class="comment"> * taskqueue中执行, 如果是executor则直接在当前线程中执行.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 从上面的行为可以猜得到, executor成员的含义应该是异步任务的提交者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> EventExecutor <span class="title">executor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> executor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">notifyListeners</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    EventExecutor executor = executor();</span><br><span class="line">    <span class="keyword">if</span> (executor.inEventLoop()) &#123;</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">notifyListenersNow();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    safeExecute(executor, <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            notifyListenersNow();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DefaultEventExecutor.newPromise();</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 利用DefaultEventExecutor生成promise时, 将该executor赋值给promise.executor.</span></span><br><span class="line"><span class="keyword">public</span> &lt;V&gt; <span class="function">Promise&lt;V&gt; <span class="title">newPromise</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DefaultPromise&lt;V&gt;(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DefaultPromise</span><span class="params">(EventExecutor executor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.executor = checkNotNull(executor, <span class="string">"executor"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>handler 中加入线程池更加的自由，比如访问数据库等操作。</p><p>Context 中添加线程池，会将整个 handler 都交给业务线程池，不够灵活。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;netty学习系列笔记总结，netty如何实现异步回调机制及对耗时业务的处理，错误之处欢迎指正, 共同学习&lt;/p&gt;

&lt;h3 id=&quot;耗时业务的处理&quot;&gt;&lt;a href=&quot;#耗时业务的处理&quot; class=&quot;headerlink&quot; title=&quot;耗时业务的处理&quot;&gt;&lt;/a&gt;耗时业务的处理&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;handler 种加入线程池&lt;/li&gt;
&lt;li&gt;context 中添加线程池&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Netty" scheme="https://blog.tolvyou.cn/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>netty核心组件-pipeline解析(二)</title>
    <link href="https://blog.tolvyou.cn/2018/11/14/netty-pipeline-2nd/"/>
    <id>https://blog.tolvyou.cn/2018/11/14/netty-pipeline-2nd/</id>
    <published>2018-11-14T01:57:14.000Z</published>
    <updated>2018-11-16T10:06:21.619Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>netty学习系列笔记总结，Pipeline源码浅析，错误之处欢迎指正, 共同学习</p><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>在 <a href="http://blog.tolvyou.cn/2018/11/13/netty-pipeline-1st/">netty核心组件-pipeline解析(一)</a> 中我们了解了pipeline 的基本概念和初始化及节点添加与删除逻辑，知道了 Netty 是如何处理网络数据的，这篇分析 pipeline 的事件和异常的传播。</p><h3 id="pipeline中的inBound事件传播"><a href="#pipeline中的inBound事件传播" class="headerlink" title="pipeline中的inBound事件传播"></a>pipeline中的inBound事件传播</h3><p>在 <a href="http://blog.tolvyou.cn/2018/11/11/netty-accept-request/">netty-接受请求过程源码分析</a> 我们已经分析了新连接的建立过程。接着我们在 NioEventLoop 类的 processSelectedKey 方法中，监听 accpet 事件和 read 事件。</p><a id="more"></a><p>启动服务端<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">    EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">        b.group(bossGroup, workerGroup)</span><br><span class="line">                .channel(NioServerSocketChannel.class)</span><br><span class="line">                .childOption(ChannelOption.TCP_NODELAY, <span class="keyword">true</span>)</span><br><span class="line">                .childAttr(AttributeKey.newInstance(<span class="string">"childAttr"</span>), <span class="string">"childAttrValue"</span>)</span><br><span class="line">                .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> </span>&#123;</span><br><span class="line">                        ch.pipeline().addLast(<span class="keyword">new</span> InBoundHandlerA());</span><br><span class="line">                        ch.pipeline().addLast(<span class="keyword">new</span> InBoundHandlerB());</span><br><span class="line">                        ch.pipeline().addLast(<span class="keyword">new</span> InBoundHandlerC());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">        ChannelFuture f = b.bind(<span class="number">8880</span>).sync();</span><br><span class="line"></span><br><span class="line">        f.channel().closeFuture().sync();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        bossGroup.shutdownGracefully();</span><br><span class="line">        workerGroup.shutdownGracefully();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InBoundHandlerA</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"InBoundHandlerA: "</span> + msg);</span><br><span class="line">        ctx.fireChannelRead(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InBoundHandlerB</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"InBoundHandlerB: "</span> + msg);</span><br><span class="line">        ctx.fireChannelRead(msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">        ctx.channel().pipeline().fireChannelRead(<span class="string">"hello world"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InBoundHandlerC</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"InBoundHandlerC: "</span> + msg);</span><br><span class="line">        ctx.fireChannelRead(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过 telnet 来连接上面启动好的netty服务，断点打在 NioEventLoop 类的 processSelectedKey 方法中，监听 accpet 事件和 read 事件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((readyOps &amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != <span class="number">0</span> || readyOps == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">// AbstractNioMessageChannel$NioMessageUnsafe</span></span><br><span class="line">    unsafe.read();</span><br><span class="line">    <span class="keyword">if</span> (!ch.isOpen()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入的是 NioSocketChannelUnsafe 的抽象父类 AbstractNioMessageChannel 的 read 方法。精简过的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">assert</span> <span class="title">eventLoop</span><span class="params">()</span>.<span class="title">inEventLoop</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">final</span> ChannelConfig config = config();</span><br><span class="line">    <span class="keyword">final</span> ChannelPipeline pipeline = pipeline();</span><br><span class="line">    <span class="keyword">final</span> RecvByteBufAllocator.Handle allocHandle = unsafe().recvBufAllocHandle();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取数据到容器</span></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="comment">// 让 handler 处理容器中的数据</span></span><br><span class="line">pipeline.fireChannelRead(readBuf.get(i));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 告诉容器处理完毕了，触发完成事件</span></span><br><span class="line">    pipeline.fireChannelReadComplete();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先从 unsafe 中读取数据，然后，将读好的数据交给 pipeline，pipeline 调用 inbound 的 channelRead 方法，读取成功后，调用 inbound 的 handler 的 ChannelReadComplete 方法。</p><p>我们首先进入 pipeline 的 fireChannelRead 方法，这个方法是实现了 invoker 的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title">fireChannelRead</span><span class="params">(Object msg)</span> </span>&#123;</span><br><span class="line">    AbstractChannelHandlerContext.invokeChannelRead(head, msg);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内部调用的是 AbstractChannelHandlerContext.invokeChannelRead(head, msg) 静态方法，并传入了 head，我们知道入站数据都是从 head 开始的，以保证后面所有的 handler 都由机会处理数据流。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeChannelRead</span><span class="params">(<span class="keyword">final</span> AbstractChannelHandlerContext next, Object msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Object m = next.pipeline.touch(ObjectUtil.checkNotNull(msg, <span class="string">"msg"</span>), next);</span><br><span class="line">    EventExecutor executor = next.executor();</span><br><span class="line">    <span class="keyword">if</span> (executor.inEventLoop()) &#123;</span><br><span class="line">        next.invokeChannelRead(m);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        executor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                next.invokeChannelRead(m);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用这个 Context （也就是 head） 的 invokeChannelRead 方法，并传入数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeChannelRead</span><span class="params">(Object msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (invokeHandler()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ((ChannelInboundHandler) handler()).channelRead(<span class="keyword">this</span>, msg);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            notifyHandlerException(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fireChannelRead(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们知道, 在Handler处理完数据后, 要想将数据传递到后一个Handler中, 要调用Context的相关方法, 假如这里一个InBoundHandler处理完了一个数据, 调用了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ctx.fireChannelRead(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法将msg传递到下一个handler中, 而前面已经知道, 下一个handler可能运行在另一个executor中, 那么解答不同exexutor中handler间数据的传递就在这个方法中了. 下面看这个方法做了什么.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelHandlerContext <span class="title">fireChannelRead</span><span class="params">(<span class="keyword">final</span> Object msg)</span> </span>&#123;</span><br><span class="line">    invokeChannelRead(findContextInbound(), msg);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先调用的findContextInbound()</p><p><img src="http://lishq.oss-cn-beijing.aliyuncs.com/github.io/findContextInbound.png" alt=""></p><p>该方法很简单，找到当前 Context 的 next 节点（inbound 类型的）并返回。这样就能将请求传递给后面的 inbound handler 了。</p><p>重复上面的逻辑，最终到达我们自定义的 handler。</p><p>再看invokeChannelRead()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeChannelRead</span><span class="params">(<span class="keyword">final</span> AbstractChannelHandlerContext next, Object msg)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    EventExecutor executor = next.executor();</span><br><span class="line">    <span class="keyword">if</span> (executor.inEventLoop()) &#123;</span><br><span class="line">        next.invokeChannelRead(m);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        executor.execute(<span class="keyword">new</span> OneTimeTask() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                next.invokeChannelRead(m);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在真相大白了, 先返回下一个handler的executor, 然后利用</p><p>executor.inEventLoop()<br>判断当前handler的executort和下一个Handler的executor是不是相同, 如果是, 就直接在当前executor中执行, 如果不是, 则打包成一个Task, 加入到下一个executor的TaskQueue中执行.</p><p>而next.invokeChannelRead(msg)是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeChannelRead</span><span class="params">(Object msg)</span> </span>&#123;</span><br><span class="line">    ((ChannelInboundHandler) handler()).channelRead(<span class="keyword">this</span>, msg);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即, 调用handler的channelRead方法, 至此, msg传入到了下一个handler中</p><p>所以如果两个handler在不同executor中执行, 那么将msg传递到下一个handler是通过TaskQueue来进行了.</p><p>现在, 可以总结ChannelHandlerContext的作用了.</p><p>它将与处理数据无关的职能从handler中剥离了出去, 用来管理数据在pipeline中的传递.</p><p>TailContext节点<br>如果数据在 handler 传递过程中没有进行处理，最后传递到 TailContext 节点进行释放</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    onUnhandledInboundMessage(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对未处理inbound消息做最后的处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onUnhandledInboundMessage</span><span class="params">(Object msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        logger.debug(</span><br><span class="line">                <span class="string">"Discarded inbound message &#123;&#125; that reached at the tail of the pipeline. "</span> +</span><br><span class="line">                        <span class="string">"Please check your pipeline configuration."</span>, msg);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">// 对msg对象的引用数减1，当msg对象的引用数为0时，释放该对象的内存</span></span><br><span class="line">        ReferenceCountUtil.release(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台打印输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">InBoundHandlerA: hello world</span><br><span class="line">InBoundHandlerB: hello world</span><br><span class="line">InBoundHandlerC: hello world</span><br></pre></td></tr></table></figure><p><strong>SimpleChannelInboundHandler</strong></p><p>在前面的例子中，假如中间有一个ChannelHandler未对channelRead事件进行传播，就会导致消息对象无法得到释放，最终导致内存泄露。</p><p>我们还可以继承 SimpleChannelInboundHandler 来自定义ChannelHandler，它的channelRead方法，对消息对象做了msg处理，防止内存泄露。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">I</span>&gt; <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> release = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (acceptInboundMessage(msg)) &#123;</span><br><span class="line">                <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                I imsg = (I) msg;</span><br><span class="line">                channelRead0(ctx, imsg);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                release = <span class="keyword">false</span>;</span><br><span class="line">                ctx.fireChannelRead(msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (autoRelease &amp;&amp; release) &#123;</span><br><span class="line">                ReferenceCountUtil.release(msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="pipeline中的outBound事件传播"><a href="#pipeline中的outBound事件传播" class="headerlink" title="pipeline中的outBound事件传播"></a>pipeline中的outBound事件传播</h3><p>以后再补充吧(TODO)</p><h3 id="pipeline-中异常的传播"><a href="#pipeline-中异常的传播" class="headerlink" title="pipeline 中异常的传播"></a>pipeline 中异常的传播</h3><p>以后再补充吧(TODO)</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>以后再补充吧(TODO)</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;netty学习系列笔记总结，Pipeline源码浅析，错误之处欢迎指正, 共同学习&lt;/p&gt;

&lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;在 &lt;a href=&quot;http://blog.tolvyou.cn/2018/11/13/netty-pipeline-1st/&quot;&gt;netty核心组件-pipeline解析(一)&lt;/a&gt; 中我们了解了pipeline 的基本概念和初始化及节点添加与删除逻辑，知道了 Netty 是如何处理网络数据的，这篇分析 pipeline 的事件和异常的传播。&lt;/p&gt;
&lt;h3 id=&quot;pipeline中的inBound事件传播&quot;&gt;&lt;a href=&quot;#pipeline中的inBound事件传播&quot; class=&quot;headerlink&quot; title=&quot;pipeline中的inBound事件传播&quot;&gt;&lt;/a&gt;pipeline中的inBound事件传播&lt;/h3&gt;&lt;p&gt;在 &lt;a href=&quot;http://blog.tolvyou.cn/2018/11/11/netty-accept-request/&quot;&gt;netty-接受请求过程源码分析&lt;/a&gt; 我们已经分析了新连接的建立过程。接着我们在 NioEventLoop 类的 processSelectedKey 方法中，监听 accpet 事件和 read 事件。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Netty" scheme="https://blog.tolvyou.cn/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>netty核心组件-pipeline解析(一)</title>
    <link href="https://blog.tolvyou.cn/2018/11/13/netty-pipeline-1st/"/>
    <id>https://blog.tolvyou.cn/2018/11/13/netty-pipeline-1st/</id>
    <published>2018-11-13T08:53:06.000Z</published>
    <updated>2019-02-08T08:16:26.512Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>netty学习系列笔记总结，Pipeline源码浅析，错误之处欢迎指正, 共同学习</p><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>netty在服务端端口绑定和新连接建立的过程中会建立相应的channel，而与channel的动作密切相关的是pipeline这个概念，在使用Pipeline中自己也有如下不解。</p><p>1.ChannelHandlerContext的作用是什么，为什么每一个Handler需要包装一个ChannelHandlerContext</p><p>2.数据是如何在不同Handler中传递的</p><p>3.Handler在哪一个executor中执行呢? 可以为Handler指派不同的executor吗, 如果handler在不同的executor中执行, 那么数据又是怎么在handler中传递的呢?</p><p>4.HeadContext和TailContext的作用是什么?</p><p>5.InBound Event来OutBound Event到底是什么? 有什么不同呢? 在Handler中传递有什么区别呢?</p><p>下面我们通过源码分析回答这些问题。</p><a id="more"></a><h3 id="pipeline介绍"><a href="#pipeline介绍" class="headerlink" title="pipeline介绍"></a>pipeline介绍</h3><ul><li>ChannelPipeline</li><li>ChannelHandler</li><li>ChannelHandlerContext</li></ul><p>我们在之前的文章中知道，每当 ServerSocket 创建一个新的连接，就会创建一个 Socket，对应的就是目标客户端。而每一个新创建的 Socket 都将会分配一个全新的 ChannelPipeline（以下简称 pipeline），他们的关系是永久不变的；而每一个 ChannelPipeline 内部都含有多个 ChannelHandlerContext（以下简称 Context），他们一起组成了双向链表，这些 Context 用于包装我们调用 addLast 方法时添加的 ChannelHandler（以下简称 handler）。</p><p>所以说，他们的关系是这样的：</p><p>在运行过程中, 每一个NioSocketChannel对应的Pipeline实际是如下这样子</p><p><img src="http://lishq.oss-cn-beijing.aliyuncs.com/github.io/netty_pipeline.jpg" alt=""></p><p>仔细观察可以发现</p><p>Pipeline内部实际上是一个双向链表, 每个元素实际上是一个ChannelHandlerContext<br>每一个Handler被一个ChannelHandlerContext所包装<br>该Pipeline中隐含着两个Context, 一个是HeadContext, 另一个是TailContext, 通过源代码可以看出, 这两个Context也是Handler.</p><p>上图中：ChannelSocket 和 ChannelPipeline 是一对一的关联关系，而 pipeline 内部的多个 Context 形成了链表，Context 只是对 Handler 的封装。</p><p>pipeline里面有多个handler, 每个handler节点过滤在pipeline中流转的event, 如果判定需要自己处理这个event,则处理(用户可以在pipeline中添加自己的handler)</p><p>总的来说，当一个请求进来的时候，会进入 Socket 对应的 pipeline，并流经 pipeline 所有的 handler</p><p>知道了他们的概念，我们继续深入看看他们的设计。</p><h5 id="1-ChannelPipeline-作用及设计"><a href="#1-ChannelPipeline-作用及设计" class="headerlink" title="1.ChannelPipeline 作用及设计"></a>1.ChannelPipeline 作用及设计</h5><p>首先看 pipeline 的接口设计：</p><p><img src="http://lishq.oss-cn-beijing.aliyuncs.com/github.io/ChannelPipeline.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ChannelPipeline</span></span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">ChannelInboundInvoker</span>, <span class="title">ChannelOutboundInvoker</span>, <span class="title">Iterable</span>&lt;<span class="title">Entry</span>&lt;<span class="title">String</span>, <span class="title">ChannelHandler</span>&gt;&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">ChannelPipeline <span class="title">addFirst</span><span class="params">(String name, ChannelHandler handler)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">ChannelPipeline <span class="title">addLast</span><span class="params">(String name, ChannelHandler handler)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">ChannelPipeline <span class="title">addBefore</span><span class="params">(String baseName, String name, ChannelHandler handler)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">ChannelPipeline <span class="title">addAfter</span><span class="params">(String baseName, String name, ChannelHandler handler)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">ChannelPipeline <span class="title">remove</span><span class="params">(ChannelHandler handler)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">ChannelPipeline <span class="title">replace</span><span class="params">(ChannelHandler oldHandler, String newName, ChannelHandler newHandler)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 UML 图，可以看到该接口继承了 inBound，outBound，Iterable 接口，表示他可以调用当数据出站的方法和入站的方法，同时也能遍历内部的链表。</p><p>再看看他的几个具有代表性的方法，基本上都是针对 handler 链表的插入，追加，删除，替换操作，甚至，我们可以想象他就是一个 LinkedList。同时，他也能返回 channel（也就是 socket）。</p><p>handler 在 pipeline 中处理 I/O 事件的方式：</p><pre>--------------------------------------------------------------------                                            I/O Request                                            via Channel or                                        ChannelHandlerContext                                                    |+---------------------------------------------------+---------------+|                           ChannelPipeline         |               ||                                                  \|/              ||    +---------------------+            +-----------+----------+    ||    | Inbound Handler  N  |            | Outbound Handler  1  |    ||    +----------+----------+            +-----------+----------+    ||              /|\                                  |               ||               |                                  \|/              ||    +----------+----------+            +-----------+----------+    ||    | Inbound Handler N-1 |            | Outbound Handler  2  |    ||    +----------+----------+            +-----------+----------+    ||              /|\                                  .               ||               .                                   .               || ChannelHandlerContext.fireIN_EVT() ChannelHandlerContext.OUT_EVT()||        [ method call]                       [method call]         ||               .                                   .               ||               .                                  \|/              ||    +----------+----------+            +-----------+----------+    ||    | Inbound Handler  2  |            | Outbound Handler M-1 |    ||    +----------+----------+            +-----------+----------+    ||              /|\                                  |               ||               |                                  \|/              ||    +----------+----------+            +-----------+----------+    ||    | Inbound Handler  1  |            | Outbound Handler  M  |    ||    +----------+----------+            +-----------+----------+    ||              /|\                                  |               |+---------------+-----------------------------------+---------------+                |                                  \|/+---------------+-----------------------------------+---------------+|               |                                   |               ||       [ Socket.read() ]                    [ Socket.write() ]     ||                                                                   ||  Netty Internal I/O Threads (Transport Implementation)            |+-------------------------------------------------------------------+</pre><p><strong>注意：</strong></p><p>你的业务程序不能将线程阻塞，他将会影响 IO 的速度，进而影响整个 Netty 程序的性能。如果你的业务程序很快，就可以放在 IO 线程中，反之，你需要异步执行。或者在添加 handler 的时候添加一个线程池，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面这个任务执行的时候，将不会阻塞 IO 线程，执行的线程来自 group 线程池</span></span><br><span class="line">pipeline.addLast(group, <span class="string">"handler"</span>, <span class="keyword">new</span> MyBusinessLogicHandler());</span><br></pre></td></tr></table></figure><h5 id="2-ChannelHandler-作用及设计"><a href="#2-ChannelHandler-作用及设计" class="headerlink" title="2.ChannelHandler  作用及设计"></a>2.ChannelHandler  作用及设计</h5><p>首先看 ChannelHandler 的接口设计：</p><p><img src="http://lishq.oss-cn-beijing.aliyuncs.com/github.io/ChannelHandler-UML.png" alt=""></p><p>ChannelHandler 是一个顶级接口，没有继承任何接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ChannelHandler</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>定义了 3 个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ChannelHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当把 ChannelHandler 添加到 pipeline 时被调用</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handlerAdded</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当从 pipeline 中移除时调用</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handlerRemoved</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当处理过程中在 pipeline 发生异常时调用</span></span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总的来说，ChannelHandler 的作用就是处理 IO 事件或拦截 IO 事件，并将其转发给下一个处理程序 ChannelHandler。</p><p>从上面的代码中，可以看到，ChannelHandler 并没有提供很多的方法，因为 Handler 处理事件时分入站和出站的，两个方向的操作都是不同的，因此，Netty 定义了两个子接口继承 ChannelHandler。</p><p><strong>2.1. ChannelInboundHandler 入站事件接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ChannelInboundHandler</span> <span class="keyword">extends</span> <span class="title">ChannelHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">channelRegistered</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">channelUnregistered</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">channelInactive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">channelWritabilityChanged</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"deprecation"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你经常使用 Netty 程序，你会非常的熟悉这些方法，比如 channelActive 用于当 Channel 处于活动状态时被调用；channelRead —— 当从Channel 读取数据时被调用等等方法。通常我们需要重写一些方法，当发生关注的事件，我们需要在方法中实现我们的业务逻辑，因为当事件发生时，Netty 会回调对应的方法。</p><p>注意：当你重写了上面的 channelRead 方法时，你需要显示的释放与池化的 ByteBuf 实例相关的内存。Netty 为此提供了了一个使用方法 ReferenceCountUtil.release().</p><p><strong>2.2. ChannelOutboundHandler 出站事件接口</strong></p><p>ChannelOutboundHandler  负责出站操作和处理出站数据。接口方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ChannelOutboundHandler</span> <span class="keyword">extends</span> <span class="title">ChannelHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bind</span><span class="params">(ChannelHandlerContext ctx, SocketAddress localAddress, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">connect</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            ChannelHandlerContext ctx, SocketAddress remoteAddress,</span></span></span><br><span class="line"><span class="function"><span class="params">            SocketAddress localAddress, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">disconnect</span><span class="params">(ChannelHandlerContext ctx, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">(ChannelHandlerContext ctx, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deregister</span><span class="params">(ChannelHandlerContext ctx, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">flush</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大家可以熟悉熟悉这个接口，比如 bind 方法，当请求将 Channel 绑定到本地地址时调用，close 方法，当请求关闭 Channel 时调用等等，总的来说，出站操作都是一些连接和写出数据类似的方法。和入站操作有很大的不同。</p><p>总之，我们要区别入站方法和出站方法，这在 pipeline 中将会起很大的作用。</p><p><strong>2.3. ChannelDuplexHandler 处理出站和入站事件</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChannelDuplexHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> <span class="keyword">implements</span> <span class="title">ChannelOutboundHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">(ChannelHandlerContext ctx, SocketAddress localAddress,</span></span></span><br><span class="line"><span class="function"><span class="params">                     ChannelPromise promise)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ctx.bind(localAddress, promise);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(ChannelHandlerContext ctx, SocketAddress remoteAddress,</span></span></span><br><span class="line"><span class="function"><span class="params">                        SocketAddress localAddress, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ctx.connect(remoteAddress, localAddress, promise);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">disconnect</span><span class="params">(ChannelHandlerContext ctx, ChannelPromise promise)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ctx.disconnect(promise);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(ChannelHandlerContext ctx, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ctx.close(promise);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deregister</span><span class="params">(ChannelHandlerContext ctx, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ctx.deregister(promise);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ctx.read();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ctx.write(msg, promise);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flush</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ctx.flush();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码中可以看出 ChannelDuplexHandler 间接实现了入站接口并直接实现了出站接口。是一个通用的能够同时处理入站事件和出站事件的类。</p><p>介绍了完了  ChannelHandler 的设计，我们再来看看 ChannelHandlerContext 。</p><h5 id="3-ChannelHandlerContext-作用及设计"><a href="#3-ChannelHandlerContext-作用及设计" class="headerlink" title="3.ChannelHandlerContext 作用及设计"></a>3.ChannelHandlerContext 作用及设计</h5><p>实际上，从上面的代码中，我们已经看到了 Context 的用处，在 ChannelDuplexHandler 中，cxt 无处不在。事实上，以read 方法为例：调用 handler 的 read 方法，如果你不处理，就会调用 context 的 read 方法，context 再调用下一个 context 的 handler 的 read 方法。</p><p>我们看看 ChannelHandlerContext 的接口 UML :</p><p><img src="http://lishq.oss-cn-beijing.aliyuncs.com/github.io/ChannelHandlerContext.png" alt=""></p><p>ChannelHandlerContext  继承了出站方法调用接口和入站方法调用接口。那么， ChannelInboundInvoker 和 ChannelOutboundInvoker 又有哪些方法呢？</p><p>ChannelInboundInvoker.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ChannelInboundInvoker</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">ChannelInboundInvoker <span class="title">fireChannelRegistered</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">ChannelInboundInvoker <span class="title">fireChannelUnregistered</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">ChannelInboundInvoker <span class="title">fireChannelActive</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">ChannelInboundInvoker <span class="title">fireChannelInactive</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">ChannelInboundInvoker <span class="title">fireExceptionCaught</span><span class="params">(Throwable cause)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">ChannelInboundInvoker <span class="title">fireUserEventTriggered</span><span class="params">(Object event)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">ChannelInboundInvoker <span class="title">fireChannelRead</span><span class="params">(Object msg)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">ChannelInboundInvoker <span class="title">fireChannelReadComplete</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">ChannelInboundInvoker <span class="title">fireChannelWritabilityChanged</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>ChannelOutboundInvoker.java<br><img src="http://lishq.oss-cn-beijing.aliyuncs.com/github.io/ChannelOutboundInvoker.png" alt=""></p><p>可以看到，这两个 invoker 就是针对入站或出站方法来的，就是再 入站或出站 handler 的外层再包装一层，达到在方法前后拦截并做一些特定操作的目的。</p><p>而 ChannelHandlerContext 不仅仅时继承了他们两个的方法，同时也定义了一些自己的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ChannelHandlerContext</span> <span class="keyword">extends</span> <span class="title">AttributeMap</span>, <span class="title">ChannelInboundInvoker</span>, <span class="title">ChannelOutboundInvoker</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Channel <span class="title">channel</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">EventExecutor <span class="title">executor</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">ChannelHandler <span class="title">handler</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isRemoved</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">ChannelPipeline <span class="title">pipeline</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">ByteBufAllocator <span class="title">alloc</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些方法能够获取 Context 上下文环境中对应的比如 channel，executor，handler ，pipeline，内存分配器，关联的 handler 是否被删除。</p><p>我们可以认为，Context 就是包装了 handler 相关的一切，以方便 Context 可以在 pipeline 方便的操作 handler 相关的资源和行为。</p><h3 id="pipeline创建过程"><a href="#pipeline创建过程" class="headerlink" title="pipeline创建过程"></a>pipeline创建过程</h3><blockquote><p> 介绍完了 pipeline 的接口设计和一些方法，那么我们就看看，netty中的pipeline是怎么玩转起来的</p></blockquote><ul><li><p>pipeline 初始化</p></li><li><p>pipeline 添加节点</p></li><li><p>pipeline 删除节点</p></li></ul><h5 id="1-pipeline-初始化"><a href="#1-pipeline-初始化" class="headerlink" title="1.pipeline 初始化"></a>1.pipeline 初始化</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造AbstratChannel通过 newChannelPipeline()创建Channel对应的Pipeline,创建</span></span><br><span class="line"><span class="comment"> * TailContext tail节点和HeadContext head节点通过prev/next组成双向链表数据结构</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">AbstractChannel</span><span class="params">(Channel parent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.parent = parent;</span><br><span class="line">    id = newId();</span><br><span class="line">    unsafe = newUnsafe();</span><br><span class="line"><span class="comment">// Pipeline在创建Channel的时候被创建</span></span><br><span class="line">    pipeline = newChannelPipeline();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> DefaultChannelPipeline <span class="title">newChannelPipeline</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DefaultChannelPipeline(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">DefaultChannelPipeline</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line"><span class="comment">// pipeline中保存了channel的引用</span></span><br><span class="line">    <span class="keyword">this</span>.channel = ObjectUtil.checkNotNull(channel, <span class="string">"channel"</span>);</span><br><span class="line">    succeededFuture = <span class="keyword">new</span> SucceededChannelFuture(channel, <span class="keyword">null</span>);</span><br><span class="line">    voidPromise =  <span class="keyword">new</span> VoidChannelPromise(channel, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    tail = <span class="keyword">new</span> TailContext(<span class="keyword">this</span>);</span><br><span class="line">    head = <span class="keyword">new</span> HeadContext(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    head.next = tail;</span><br><span class="line">    tail.prev = head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>.Pipeline中的两大哨兵:head和tail</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>.TailContext tail节点继承AbstractChannelHandlerContext即为Pipeline节点数据结构</span><br><span class="line">ChannelHandlerContext,实现ChannelInboundHandler传播inBound事件即属于Inbound处理器</span><br><span class="line">ChannelHandler,exceptionCaught()/channelRead()方法用于异常未处理警告/Msg未处理建议处理收尾</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>.HeadContext head节点继承AbstractChannelHandlerContext即为Pipeline节点数据结构</span><br><span class="line">ChannelHandlerContext,实现ChannelOutboundHandler传播outBound事件即属于Outbound处理器</span><br><span class="line">ChannelHandler,使用pipeline.channel().unsafe()获取Channel的Unsafe实现底层数据读写,用于传播事件/读写事件委托Unsafe操作</span><br></pre></td></tr></table></figure><p>pipeline中的每个节点是一个ChannelHandlerContext对象，每个context节点保存了它包裹的执行器 ChannelHandler 执行操作所需要的上下文，其实就是pipeline，因为pipeline包含了channel的引用，可以拿到所有的context信息</p><p>默认情况下，一条pipeline会有两个节点，head和tail</p><h5 id="2-pipeline-添加节点"><a href="#2-pipeline-添加节点" class="headerlink" title="2.pipeline 添加节点"></a>2.pipeline 添加节点</h5><p>当将Handler添加到Pipeline中时, 最终调用的方法是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title">addLast</span><span class="params">(EventExecutorGroup group, String name, ChannelHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> AbstractChannelHandlerContext newCtx;</span><br><span class="line"><span class="comment">// 防止多线程并发操作pipeline底层的双向链表</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line"><span class="comment">// 检查是否有重复 handler</span></span><br><span class="line">        checkMultiplicity(handler);</span><br><span class="line"><span class="comment">// 创建节点</span></span><br><span class="line">        newCtx = newContext(group, filterName(name, handler), handler);</span><br><span class="line"><span class="comment">// 添加节点</span></span><br><span class="line">        addLast0(newCtx);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!registered) &#123;</span><br><span class="line">            newCtx.setAddPending();</span><br><span class="line">            callHandlerCallbackLater(newCtx, <span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 回调用户代码</span></span><br><span class="line">    callHandlerAdded0(newCtx);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.1. 检查是否有重复 handler</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">checkMultiplicity</span><span class="params">(ChannelHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (handler <span class="keyword">instanceof</span> ChannelHandlerAdapter) &#123;</span><br><span class="line">        ChannelHandlerAdapter h = (ChannelHandlerAdapter) handler;</span><br><span class="line">        <span class="keyword">if</span> (!h.isSharable() &amp;&amp; h.added) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ChannelPipelineException(</span><br><span class="line">                    h.getClass().getName() +</span><br><span class="line">                    <span class="string">" is not a @Sharable handler, so can't be added or removed multiple times."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        h.added = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 checkMultiplicity() 方法判断 ChannelHandler 是否为 ChannelHandlerAdapter 实例，ChannelHandler 强制转换 ChannelHandlerAdapter 判断是否可共享[isSharable()] &amp; 是否已经被添加过 [h.added] , ChannelHandlerAdapter 非共享并且已经被添加过抛出异常拒绝添加</p><p><strong>2.2. 创建节点</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> AbstractChannelHandlerContext <span class="title">newContext</span><span class="params">(EventExecutorGroup group, String name, ChannelHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DefaultChannelHandlerContext(<span class="keyword">this</span>, childExecutor(group), name, handler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法主要做了两件事</p><p>1.将handler包装一个ChannelHandlerContext<br>2.从group中取得一个childExecutor, 赋值给DefaultChannelHandlerContext的executor成员<br>3.根据该handler是InBoundHandler还是OutBoundHandler为该Context设置inbound或outbound</p><p>其中DefaultChannelHandlerContext的executor的含义是.</p><blockquote><p> 执行所包装的Handler的executor</p></blockquote><p>所以可以看出.</p><blockquote><p> Handler可以在不同的executor中执行, 如果不指定, 则该executor是NioEventLoop, 这就是默认情况下Handler在NioEventLoop中执行.</p></blockquote><p><strong>2.3. 添加节点</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addLast0</span><span class="params">(AbstractChannelHandlerContext newCtx)</span> </span>&#123;</span><br><span class="line">    AbstractChannelHandlerContext prev = tail.prev;</span><br><span class="line">    newCtx.prev = prev;</span><br><span class="line">    newCtx.next = tail;</span><br><span class="line">    prev.next = newCtx;</span><br><span class="line">    tail.prev = newCtx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用 addLast0() 方法获取 tail 节点的前置节点 prev ,将当前节点的前置节点 prev 置为 tail 节点的前置节点 prev ,当前节点的后置节点 next 置为 tail 节点, tail 节点的前置节点 prev 的后置节点 next 置为当前节点, tail 节点的前置节点 prev 置为当前节点,通过链表的方式添加到 Channel 的 Pipeline</p><p><strong>2.4. 回调用户代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">callHandlerAdded0</span><span class="params">(<span class="keyword">final</span> AbstractChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ctx.handler().handlerAdded(ctx);</span><br><span class="line">        ctx.setAddComplete();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>handlerAdded执行用户代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OutBoundHandlerB</span> <span class="keyword">extends</span> <span class="title">ChannelOutboundHandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerAdded</span><span class="params">(<span class="keyword">final</span> ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">        ctx.executor().schedule(() -&gt; &#123;</span><br><span class="line">            ctx.channel().write(<span class="string">"hello world"</span>);</span><br><span class="line">            ctx.write(<span class="string">"hello world"</span>);</span><br><span class="line">        &#125;, <span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>setAddComplete</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setAddComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> oldState = handlerState;</span><br><span class="line">        <span class="keyword">if</span> (oldState == REMOVE_COMPLETE || HANDLER_STATE_UPDATER.compareAndSet(<span class="keyword">this</span>, oldState, ADD_COMPLETE)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改节点的状态至：REMOVE_COMPLETE（说明该节点已经被移除） 或者 ADD_COMPLETE</p><h5 id="pipeline-删除节点"><a href="#pipeline-删除节点" class="headerlink" title="pipeline 删除节点"></a>pipeline 删除节点</h5><p>netty 有个最大的特性之一就是Handler可插拔，做到动态编织pipeline，比如在首次建立连接的时候，需要通过进行权限认证，在认证通过之后，就可以将此context移除，下次pipeline在传播事件的时候就就不会调用到权限认证处理器</p><p>下面是权限认证Handler最简单的实现，第一个数据包传来的是认证信息，如果校验通过，就删除此Handler，否则，直接关闭连接</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">ByteBuf</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, ByteBuf password)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (paas(password)) &#123;</span><br><span class="line">            ctx.pipeline().remove(<span class="keyword">this</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ctx.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">paas</span><span class="params">(ByteBuf password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title">remove</span><span class="params">(ChannelHandler handler)</span> </span>&#123;</span><br><span class="line">    remove(getContextOrDie(handler));</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 找到节点</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> AbstractChannelHandlerContext <span class="title">getContextOrDie</span><span class="params">(ChannelHandler handler)</span> </span>&#123;</span><br><span class="line">    AbstractChannelHandlerContext ctx = (AbstractChannelHandlerContext) context(handler);</span><br><span class="line">    <span class="keyword">if</span> (ctx == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException(handler.getClass().getName());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ctx;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从head节点的后置节点next遍历循环判断节点的Handler是否为指定ChannelHandler获取封装  </span></span><br><span class="line"><span class="comment"> * ChannelHandler的ChannelHandlerContext节点,ChannelHandlerContext节点为空抛异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelHandlerContext <span class="title">context</span><span class="params">(ChannelHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"handler"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AbstractChannelHandlerContext ctx = head.next;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ctx == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ctx.handler() == handler) &#123;</span><br><span class="line">            <span class="keyword">return</span> ctx;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ctx = ctx.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> AbstractChannelHandlerContext <span class="title">remove</span><span class="params">(<span class="keyword">final</span> AbstractChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> ctx != head &amp;&amp; ctx != tail;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        remove0(ctx);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!registered) &#123;</span><br><span class="line">            callHandlerCallbackLater(ctx, <span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">return</span> ctx;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前节点的ChannelHandler使用handlerRemove()方法回调删除Handler事件</span></span><br><span class="line">    callHandlerRemoved0(ctx);</span><br><span class="line">    <span class="keyword">return</span> ctx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>1.了解了pipeline 的接口设计和一些方法。Context 包装 handler，多个 Context 在 pipeline 中形成了双向链表，添加和删除节点均只需要调整链表结构。</p><p>2.pipeline中的每个节点包着具体的处理器ChannelHandler，节点根据ChannelHandler的类型是ChannelInboundHandler还是ChannelOutboundHandler来判断该节点属于in还是out或者两者都是</p><p>下一篇，总结 pipeline 的事件传播机制。</p><p><strong>参考</strong></p><blockquote><p><a href="https://www.jianshu.com/p/6efa9c5fa702" target="_blank" rel="noopener">https://www.jianshu.com/p/6efa9c5fa702</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;netty学习系列笔记总结，Pipeline源码浅析，错误之处欢迎指正, 共同学习&lt;/p&gt;

&lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;netty在服务端端口绑定和新连接建立的过程中会建立相应的channel，而与channel的动作密切相关的是pipeline这个概念，在使用Pipeline中自己也有如下不解。&lt;/p&gt;
&lt;p&gt;1.ChannelHandlerContext的作用是什么，为什么每一个Handler需要包装一个ChannelHandlerContext&lt;/p&gt;
&lt;p&gt;2.数据是如何在不同Handler中传递的&lt;/p&gt;
&lt;p&gt;3.Handler在哪一个executor中执行呢? 可以为Handler指派不同的executor吗, 如果handler在不同的executor中执行, 那么数据又是怎么在handler中传递的呢?&lt;/p&gt;
&lt;p&gt;4.HeadContext和TailContext的作用是什么?&lt;/p&gt;
&lt;p&gt;5.InBound Event来OutBound Event到底是什么? 有什么不同呢? 在Handler中传递有什么区别呢?&lt;/p&gt;
&lt;p&gt;下面我们通过源码分析回答这些问题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Netty" scheme="https://blog.tolvyou.cn/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>netty-接受请求过程源码分析</title>
    <link href="https://blog.tolvyou.cn/2018/11/11/netty-accept-request/"/>
    <id>https://blog.tolvyou.cn/2018/11/11/netty-accept-request/</id>
    <published>2018-11-11T14:13:23.000Z</published>
    <updated>2019-02-08T08:17:03.623Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>netty学习系列笔记总结，接受请求过程源码浅析，错误之处欢迎指正, 共同学习</p><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p><a href="http://blog.tolvyou.cn/2018/11/04/netty-startup-details/#more">netty启动过程源码分析</a>，我们得知，服务器最终注册了一个 Accept 事件等待客户端的连接。我们也知道，NioServerSocketChannel 将自己注册到了 boss 单例线程池（reactor 线程）上，也就是 EventLoop.</p><p><a href="http://blog.tolvyou.cn/2018/11/07/netty-nioEventLoop/#more">EventLoop</a>所做的事情均分为以下三个步骤</p><p>1.轮询注册在selector上的IO事件</p><p>2.处理IO事件</p><p>3.执行异步task</p><a id="more"></a><h3 id="新链接的建立"><a href="#新链接的建立" class="headerlink" title="新链接的建立"></a>新链接的建立</h3><ul><li>检测到有新的连接</li><li>将新的连接注册到worker线程组</li><li>注册新连接的读事件</li></ul><h5 id="1-检测新连接"><a href="#1-检测新连接" class="headerlink" title="1.检测新连接"></a>1.检测新连接</h5><ul><li>进入到 NioEventLoop 源码中,找到 processSelectedKey()方法设置断点</li><li>debug 启动 EchoServer 的 main 方法</li><li>建立一个新的连接：telnet 127.0.0.1 8888</li></ul><p><img src="https://lishq.oss-cn-beijing.aliyuncs.com/github.io/NioEventLoop-Read.png" alt=""></p><p>上面代码表示boos reactor线程已经轮询到 SelectionKey.OP_ACCEPT 事件，说明有新的连接进入，此时将调用channel的 unsafe来进行实际的操作。接下来，进入到它的read方法，进入新连接处理的第二步</p><h5 id="2-注册到reactor线程"><a href="#2-注册到reactor线程" class="headerlink" title="2.注册到reactor线程"></a>2.注册到reactor线程</h5><p><img src="http://lishq.oss-cn-beijing.aliyuncs.com/github.io/NioEventLoop-reactor.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.检查该 eventloop 线程是否是当前线程。</span><br><span class="line"><span class="number">2</span>.执行 doReadMessages 方法，并传入一个 readBuf 变量，这个变量是一个 List，也就是容器。</span><br><span class="line"><span class="number">3</span>.循环容器，执行 pipeline.fireChannelRead(readBuf.get(i));</span><br><span class="line"><span class="number">4</span>.清理容器，触发 pipeline.fireChannelReadComplete()</span><br></pre></td></tr></table></figure><p>进入 doReadMessages 方法</p><p><img src="http://lishq.oss-cn-beijing.aliyuncs.com/github.io/doReadMessage.png" alt=""></p><p>netty调用jdk底层 javaChannel().accept();由于netty中reactor线程第一步就扫描到有accept事件发生，因此，这里的accept方法是立即返回的，返回jdk底层nio创建的一条channel</p><p>netty将jdk的 SocketChannel 封装成自定义的 NioSocketChannel，添加到容器中，做后续处理</p><p><img src="http://lishq.oss-cn-beijing.aliyuncs.com/github.io/continueRead.png" alt=""></p><p>默认一次最多读取16条连接</p><p>创建NioSocketChannel</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">doReadMessages</span><span class="params">(List&lt;Object&gt; buf)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    SocketChannel ch = javaChannel().accept();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch != <span class="keyword">null</span>) &#123;</span><br><span class="line">            buf.add(<span class="keyword">new</span> NioSocketChannel(<span class="keyword">this</span>, ch));</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        logger.warn(<span class="string">"Failed to create a new channel from an accepted socket."</span>, t);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ch.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t2) &#123;</span><br><span class="line">            logger.warn(<span class="string">"Failed to close a socket."</span>, t2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ServerSocketChannel <span class="title">javaChannel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (ServerSocketChannel) <span class="keyword">super</span>.javaChannel();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法调用了 NioServerSocketChannel 中的 serverSocketChannel.accept() 方法。返回了一个 Nio 的通道，注意：这个通道，就是我们刚刚 Boss 线程监听到的 Accept 事件，相当于一个 Tcp 连接。<br><br>然后我们看 NioSocketChannel 的创建过程，其中参数 this 是 NioServerSocketChannel ，这个就是 SocketChannel 的 parent 属性，ch 是 SocketChannel 。构造方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioSocketChannel</span><span class="params">(Channel parent, SocketChannel socket)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(parent, socket);</span><br><span class="line">    config = <span class="keyword">new</span> NioSocketChannelConfig(<span class="keyword">this</span>, socket.socket());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NioSocketChannel的父类为 AbstractNioByteChannel</span></span><br><span class="line"><span class="comment">// 注册了SelectionKey.OP_READ，表示对channel的读感兴趣</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">AbstractNioByteChannel</span><span class="params">(Channel parent, SelectableChannel ch)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(parent, ch, SelectionKey.OP_READ);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//AbstractNioByteChannel的父类 AbstractNioChannel</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">AbstractNioChannel</span><span class="params">(Channel parent, SelectableChannel ch, <span class="keyword">int</span> readInterestOp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(parent);</span><br><span class="line">    <span class="keyword">this</span>.ch = ch;</span><br><span class="line"><span class="comment">// readInterestOp 表示该channel关心的事件是 SelectionKey.OP_READ，后续会将该事件注册到selector，之后设置该通道为非阻塞模式</span></span><br><span class="line">    <span class="keyword">this</span>.readInterestOp = readInterestOp;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ch.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ch.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">                logger.warn(</span><br><span class="line">                        <span class="string">"Failed to close a partially initialized socket."</span>, e2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ChannelException(<span class="string">"Failed to enter non-blocking mode."</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// super(parent)</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">AbstractChannel</span><span class="params">(Channel parent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.parent = parent;</span><br><span class="line">    id = newId();</span><br><span class="line">    unsafe = newUnsafe();<span class="comment">// NioSocketChannel$NioSocketChannelUnsafe</span></span><br><span class="line">    pipeline = newChannelPipeline();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Netty中的Channel的分类</p><p><img src="http://lishq.oss-cn-beijing.aliyuncs.com/github.io/ChannelType.png" alt=""></p><p><strong>1.Unsafe[实现Channel读写抽象]，服务端NioMessageUnsafe读连接,客户端NioByteUnsafe读数据<br><br>2.AbstractChannel用于实现channel的大部分方法，其中我们最熟悉的就是其构造函数中，创建出一条channel的基本组件<br><br>3.AbstractNioChannel基于AbstractChannel做了nio相关的一些操作，保存jdk底层的 SelectableChannel，并且在构造函数中设置channel为非阻塞<br><br>4.最后，就是两大channel，NioServerSocketChannel，NioSocketChannel对应着服务端接受新连接过程和新连接读写过程,分别创建NioServerSocketChannelConfig，NioSocketChannelConfig</strong></p><p>在创建出一条 NioSocketChannel之后，放置在List容器里面之后，就开始进行下一步操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> localRead = doReadMessages(readBuf);</span><br><span class="line">            <span class="comment">// ......</span></span><br><span class="line">        &#125; <span class="keyword">while</span> (allocHandle.continueReading());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> size = readBuf.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i ++) &#123;</span><br><span class="line">            readPending = <span class="keyword">false</span>;</span><br><span class="line">            pipeline.fireChannelRead(readBuf.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        readBuf.clear();</span><br><span class="line">        allocHandle.readComplete();</span><br><span class="line">        pipeline.fireChannelReadComplete();</span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>循环执行 pipeline.fireChannelRead 方法</p><p>DefaultChannelPipeline.fireChannelRead(NioSocketChannel)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里的Pipeline是NioServerSocketChannel的Pipeline, 此时Pipeline中有一个ServerBootstrapAcceptor, 所以会传递到ServerBootstrapAcceptor的channelRead方法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title">fireChannelRead</span><span class="params">(Object msg)</span> </span>&#123;</span><br><span class="line">    AbstractChannelHandlerContext.invokeChannelRead(head, msg);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>ServerBootstrapAcceptor.channelRead(ctx, msg)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(Channel channel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ch.eventLoop().execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            pipeline.addLast(<span class="keyword">new</span> ServerBootstrapAcceptor(</span><br><span class="line">                    ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化ServerBootstrapAcceptor时, 该Acceptor有四个属性是由ServerBootstrap传过来的.</span></span><br><span class="line"><span class="keyword">this</span>.childGroup = currentChildGroup;</span><br><span class="line"><span class="keyword">this</span>.childHandler = currentChildHandler;</span><br><span class="line"><span class="keyword">this</span>.childOptions = currentChildOptions;</span><br><span class="line"><span class="keyword">this</span>.childAttrs = currentChildAttrs;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里的childGroup就是subReactor, childHandler就是</span></span><br><span class="line">ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            b.group(bossGroup, workerGroup)</span><br><span class="line">.childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;...&#125;)</span><br><span class="line"></span><br><span class="line">这个ChannelInitializer是用来初始化NioSocketChannel所对应的Pipeline的.</span><br><span class="line"></span><br><span class="line"><span class="comment">// 来看ServerBootstrapAcceptor的read方法.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Channel child = (Channel) msg;</span><br><span class="line"></span><br><span class="line">    child.pipeline().addLast(childHandler);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        childGroup.register(child).addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (!future.isSuccess()) &#123;</span><br><span class="line">                    forceClose(child, future.cause());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        forceClose(child, t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong><br>拿到该channel，也就是我们之前new出来的 NioSocketChannel对应的pipeline，将用户代码中的<br>childHandler，添加到pipeline，然后进入到 childGroup.register(child)，这里的childGroup就是我们在启动代码中new出来的NioEventLoopGroup。之后, 触发channelRegister事件, 执行ChannelInitializer的initChannel方法, 进一步初始化NioSocketChannel所对应的pipeline.</strong></p><p>至此, 接收客户端并注册到NioEventLoop的过程完毕。</p><p>接下来重点看下childGroup.register方法，为什么是subReactor<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// next方法使用位运算获取数组中的EventLoop</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">register</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> next().register(channel);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">register</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> register(<span class="keyword">new</span> DefaultChannelPromise(channel, <span class="keyword">this</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">register</span><span class="params">(<span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    ObjectUtil.checkNotNull(promise, <span class="string">"promise"</span>);</span><br><span class="line">    promise.channel().unsafe().register(<span class="keyword">this</span>, promise);</span><br><span class="line">    <span class="keyword">return</span> promise;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">promise.channel() 方法返回的是 NioSocketChannel</span><br><span class="line">promise.channel().unsafe() NioSocketChannel$NioSocketChannelUnsafe</span><br><span class="line">所以最终调用的是 NioSocketChannel 的内部类的 register 方法。</span><br><span class="line">参数是当前的 EventLoop 和 promise</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(EventLoop eventLoop, <span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    AbstractChannel.<span class="keyword">this</span>.eventLoop = eventLoop;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (eventLoop.inEventLoop()) &#123;</span><br><span class="line">        register0(promise);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            eventLoop.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    register0(promise);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            <span class="comment">// ......</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// register0</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">register0</span><span class="params">(ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">        <span class="keyword">boolean</span> firstRegistration = neverRegistered;</span><br><span class="line">        doRegister();</span><br><span class="line">neverRegistered = <span class="keyword">false</span>;</span><br><span class="line">        registered = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Ensure we call handlerAdded(...) before we actually notify the promise. This is needed as the</span></span><br><span class="line">        <span class="comment">// user may already fire events through the pipeline in the ChannelFutureListener.</span></span><br><span class="line">        pipeline.invokeHandlerAddedIfNeeded();</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// doRegister(),真正的注册过程</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doRegister</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> selected = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            selectionKey = javaChannel().register(eventLoop().selector, <span class="number">0</span>, <span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CancelledKeyException e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!selected) &#123;</span><br><span class="line">                <span class="comment">// Force the Selector to select now as the "canceled" SelectionKey may still be</span></span><br><span class="line">                <span class="comment">// cached and not removed because no Select.select(..) operation was called yet.</span></span><br><span class="line">                eventLoop().selectNow();</span><br><span class="line">                selected = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// We forced a select operation on the selector before but the SelectionKey is still cached</span></span><br><span class="line">                <span class="comment">// for whatever reason. JDK bug ?</span></span><br><span class="line">                <span class="keyword">throw</span> e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">将该条channel绑定到一个selector上去，一个selector被一个reactor线程使用，</span><br><span class="line">后续该channel的事件轮询，以及事件处理，异步task执行都是由此reactor线程来负责</span><br><span class="line"></span><br><span class="line">绑定完reactor线程之后，调用 pipeline.invokeHandlerAddedIfNeeded()</span><br></pre></td></tr></table></figure></p><p>pipeline.invokeHandlerAddedIfNeeded();</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 该方法最终会调用到用户的initChannel方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">initChannel</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initMap.putIfAbsent(ctx, Boolean.TRUE) == <span class="keyword">null</span>) &#123; <span class="comment">// Guard against re-entrance.</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            initChannel((C) ctx.channel());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable cause) &#123;</span><br><span class="line">            <span class="comment">// Explicitly call exceptionCaught(...) as we removed the handler before calling initChannel(...).</span></span><br><span class="line">            <span class="comment">// We do so to prevent multiple calls to initChannel(...).</span></span><br><span class="line">            exceptionCaught(ctx, cause);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            remove(ctx);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也就是用户代码</span></span><br><span class="line">ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">b.group(bossGroup, workerGroup)</span><br><span class="line"> .channel(NioServerSocketChannel.class)</span><br><span class="line"> .option(ChannelOption.SO_BACKLOG, <span class="number">100</span>)</span><br><span class="line"> .handler(<span class="keyword">new</span> LoggingHandler(LogLevel.INFO))</span><br><span class="line"> .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">         ChannelPipeline p = ch.pipeline();</span><br><span class="line">         p.addLast(<span class="keyword">new</span> LoggingHandler(LogLevel.INFO));</span><br><span class="line">         p.addLast(<span class="keyword">new</span> EchoServerHandler());</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure><h5 id="3-注册读事件"><a href="#3-注册读事件" class="headerlink" title="3.注册读事件"></a>3.注册读事件</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">register0</span><span class="params">(ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line"><span class="comment">// 再调用一下业务pipeline中每个处理器的 ChannelHandlerAdded方法处理下回调</span></span><br><span class="line">        pipeline.fireChannelRegistered();</span><br><span class="line">        <span class="keyword">if</span> (isActive()) &#123;<span class="comment">// 在连接已经建立的情况下返回true</span></span><br><span class="line">            <span class="keyword">if</span> (firstRegistration) &#123;</span><br><span class="line">                pipeline.fireChannelActive();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (config().isAutoRead()) &#123;</span><br><span class="line">                beginRead();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doBeginRead</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// Channel.read() or ChannelHandlerContext.read() was called</span></span><br><span class="line">    <span class="keyword">final</span> SelectionKey selectionKey = <span class="keyword">this</span>.selectionKey;</span><br><span class="line">    <span class="keyword">if</span> (!selectionKey.isValid()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    readPending = <span class="keyword">true</span>;</span><br><span class="line"><span class="comment">// 将 SelectionKey.OP_READ事件注册到selector中去，表示这条通道已经可以开始处理read事件了</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> interestOps = selectionKey.interestOps();</span><br><span class="line">    <span class="keyword">if</span> ((interestOps &amp; readInterestOp) == <span class="number">0</span>) &#123;</span><br><span class="line">        selectionKey.interestOps(interestOps | readInterestOp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>1.boos reactor线程轮询到有新的连接进入<br>2.通过封装jdk底层的channel创建 NioSocketChannel以及一系列的netty核心组件<br>3.将该条连接通过chooser，选择一条worker reactor线程绑定上去<br>4.注册读事件，开始新连接的读写</p><p>问:Netty是在哪里检测有新连接接入的?<br>答:Boss线程通过服务端Channel绑定的Selector轮询OP_ACCEPT事件,通过JDK底层Channel的accept()方法获取JDK底层SocketChannel创建新连接</p><p>问:新连接是怎样注册到NioEventLoop线程的?<br>答:Worker线程调用Chooser的next()方法选择获取NioEventLoop绑定到客户端Channel,使用doRegister()方法将新连接注册到NioEventLoop的Selector上面</p><p>Netty新连接接入处理逻辑:<br>服务端Channel绑定的NioEventLoop即Boss线程轮询OP_ACCEPT事件,调用服务端Channel的accept()方法获取客户端Channel封装成NioSocketChannel,<br>封装创建组件Unsafe用来实现Channel读写和Pipeline负责数据处理业务逻辑链,服务端Channel通过连接接入器ServerBootstrapAcceptor给客户端Channel分配NioEventLoop,<br>将客户端Channel绑定到Selector上面,通过传播Channel Active方法将客户端Channel读事件注册到Selector</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;netty学习系列笔记总结，接受请求过程源码浅析，错误之处欢迎指正, 共同学习&lt;/p&gt;

&lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;http://blog.tolvyou.cn/2018/11/04/netty-startup-details/#more&quot;&gt;netty启动过程源码分析&lt;/a&gt;，我们得知，服务器最终注册了一个 Accept 事件等待客户端的连接。我们也知道，NioServerSocketChannel 将自己注册到了 boss 单例线程池（reactor 线程）上，也就是 EventLoop.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.tolvyou.cn/2018/11/07/netty-nioEventLoop/#more&quot;&gt;EventLoop&lt;/a&gt;所做的事情均分为以下三个步骤&lt;/p&gt;
&lt;p&gt;1.轮询注册在selector上的IO事件&lt;/p&gt;
&lt;p&gt;2.处理IO事件&lt;/p&gt;
&lt;p&gt;3.执行异步task&lt;/p&gt;
    
    </summary>
    
    
      <category term="Netty" scheme="https://blog.tolvyou.cn/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>netty-fastThreadLocal-源码分析</title>
    <link href="https://blog.tolvyou.cn/2018/11/09/netty-fastThreadLocal/"/>
    <id>https://blog.tolvyou.cn/2018/11/09/netty-fastThreadLocal/</id>
    <published>2018-11-09T03:15:21.000Z</published>
    <updated>2019-02-08T08:18:34.153Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>netty学习系列笔记总结，性能优化工具类之FastThreadLocal源码浅析，错误之处欢迎指正, 共同学习</p><a id="more"></a><h3 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    FastThreadLocal&lt;Object&gt; fastThreadLocal = <span class="keyword">new</span> FastThreadLocal&lt;Object&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Object <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Object();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onRemoval</span><span class="params">(Object value)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"onRemoval"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    System.out.println(fastThreadLocal.get());</span><br><span class="line">    fastThreadLocal.set(<span class="string">"lishq"</span>);</span><br><span class="line">    System.out.println(fastThreadLocal.get());</span><br><span class="line">    fastThreadLocal.remove();</span><br><span class="line">    System.out.println(fastThreadLocal.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Object<span class="meta">@b</span>6cbcc</span><br><span class="line">lishq</span><br><span class="line">onRemoval</span><br><span class="line">java.lang.Object<span class="meta">@a</span>7e666</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure><h3 id="构造方法解析"><a href="#构造方法解析" class="headerlink" title="构造方法解析"></a>构造方法解析</h3><p>Netty重新设计了更快的FastThreadLocal，主要实现涉及</p><ul><li>FastThreadLocalThread</li><li>FastThreadLocal</li><li>InternalThreadLocalMap</li></ul><p><strong>FastThreadLocalThread是Thread类的简单扩展，主要是为了扩展threadLocalMap属性<br><br>FastThreadLocal提供的接口和传统的ThreadLocal一致，主要是set和get方法，用法也一致<br><br>不同地方在于FastThreadLocal的值是存储在InternalThreadLocalMap这个结构里面的，传统的ThreadLocal性能槽点主要是在读写的时候hash计算和当hash没有命中的时候发生的遍历</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FastThreadLocal</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 初始化时分配一个全局唯一的index</span></span><br><span class="line">    index = InternalThreadLocalMap.nextVariableIndex();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Object[] indexedVariables;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取数组对应的下标</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextVariableIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index = nextIndex.getAndIncrement();</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        nextIndex.decrementAndGet();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"too many thread-local indexed variables"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> AtomicInteger nextIndex = <span class="keyword">new</span> AtomicInteger();</span><br></pre></td></tr></table></figure><p>nextIndex是InternalThreadLocalMap父类的一个全局静态的AtomicInteger类型的对象，这意味着所有的FastThreadLocal实例将共同依赖这个指针来生成唯一的索引，而且是线程安全的;</p><p>InternalThreadLocalMap实例和Thread对象一一对应;</p><p>该index也是绑定的FastThreadLocal对象的value在Object[]数组中的索引位置</p><h3 id="get方法解析"><a href="#get方法解析" class="headerlink" title="get方法解析"></a>get方法解析</h3><p>1.FastThreadLocal的获取</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取当前线程的InternalThreadLocalMap中的当前ftl的value</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">get</span><span class="params">(InternalThreadLocalMap threadLocalMap)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 直接采用index下标访问threadLocalMap中数组的指定位置元素,如果该索引处的value是有效值，不是占位值，则直接返回</span></span><br><span class="line">    Object v = threadLocalMap.indexedVariable(index);</span><br><span class="line">    <span class="keyword">if</span> (v != InternalThreadLocalMap.UNSET) &#123;</span><br><span class="line">        <span class="keyword">return</span> (V) v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有设置有效值，执行初始化操作，获取初始值</span></span><br><span class="line">    <span class="keyword">return</span> initialize(threadLocalMap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.获取InternalThreadLocalMap<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//获取到与当前线程关联的InternalThreadLocalMap, 通过该map来查询具体数据</span></span><br><span class="line">    <span class="keyword">return</span> get(InternalThreadLocalMap.get());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> InternalThreadLocalMap <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread thread = Thread.currentThread();</span><br><span class="line">    <span class="keyword">if</span> (thread <span class="keyword">instanceof</span> FastThreadLocalThread) &#123;</span><br><span class="line">        <span class="keyword">return</span> fastGet((FastThreadLocalThread) thread);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> slowGet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果当前线程是ftlt线程，则使用fastGet进行获取；否则使用slowGet进行获取。</p><p>fastGet:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//底层自己维护了一个ThreadLocalMap对象</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> InternalThreadLocalMap <span class="title">fastGet</span><span class="params">(FastThreadLocalThread thread)</span> </span>&#123;</span><br><span class="line">    InternalThreadLocalMap threadLocalMap = thread.threadLocalMap();</span><br><span class="line">    <span class="keyword">if</span> (threadLocalMap == <span class="keyword">null</span>) &#123;</span><br><span class="line">        thread.setThreadLocalMap(threadLocalMap = <span class="keyword">new</span> InternalThreadLocalMap());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> threadLocalMap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果该threadLocalMap已经实例化过，则直接返回，否则，先创建一个InternalThreadLocalMap实例，然后将该实例设置到ftlt的threadLocalMap属性中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 无效的value值（占位符），不使用null做无效值的原因是因为netty认为null也是一个有效值，</span></span><br><span class="line"><span class="comment"> * 例如：假设没有重写FastThreadLocal的initialValue()方法，则该方法返回为null，netty会将null作为有效值直接存储起来</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Object UNSET = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">InternalThreadLocalMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(newIndexedVariableTable());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化32size的数组，并将每一个元素初始化为UNSET</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Object[] newIndexedVariableTable() &#123;</span><br><span class="line">    Object[] array = <span class="keyword">new</span> Object[<span class="number">32</span>];</span><br><span class="line">    Arrays.fill(array, UNSET);</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>slowGet:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;InternalThreadLocalMap&gt; slowThreadLocalMap = <span class="keyword">new</span> ThreadLocal&lt;InternalThreadLocalMap&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> InternalThreadLocalMap <span class="title">slowGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ThreadLocal&lt;InternalThreadLocalMap&gt; slowThreadLocalMap = UnpaddedInternalThreadLocalMap.slowThreadLocalMap;</span><br><span class="line"><span class="comment">//这个过程比较慢？</span></span><br><span class="line">    InternalThreadLocalMap ret = slowThreadLocalMap.get();</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="keyword">null</span>) &#123;</span><br><span class="line">        ret = <span class="keyword">new</span> InternalThreadLocalMap();</span><br><span class="line">        slowThreadLocalMap.set(ret);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之所以成为slowGet的原因是因为：</p><p><strong>fastGet可以直接从当前线程的属性获取；而slowGet需要根据slowThreadLocalMap的索引值与数组长度进行计算之后进行获取，如果没有直接根据索引命中的话，还可能需要进行线性探测的向后循环查找操作，当然还可能有一些清理和整理逻辑。<br><br>fastGet设置InternalThreadLocalMap，直接给当前线程的属性赋值，而slowGet的set操作需要使用线性探测法进行设置，并会至少执行一次log级别的资源回收整理操作</strong></p><p>如上两点也是ftl比tl快的原因。但是可以看出tl在不断的回收无效的Entry使得新的Entry可以插入而不需要额外空间，但是ftl只能不断的增加index，不断向后增加，而index前边被remove掉的位置不能被重用，所以Object[]数组的size会越来越大,算是一种空间换时间的做法。</p><p>3.从InternalThreadLocalMap获取值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Object[] indexedVariables;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取指定位置的元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">indexedVariable</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    Object[] lookup = indexedVariables;</span><br><span class="line">    <span class="keyword">return</span> index &lt; lookup.length? lookup[index] : UNSET;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.初始化操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> V <span class="title">initialize</span><span class="params">(InternalThreadLocalMap threadLocalMap)</span> </span>&#123;</span><br><span class="line">    V v = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//获取初始值</span></span><br><span class="line">        v = initialValue();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        PlatformDependent.throwException(e);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 初始化后再设置，下次就不用再初始化</span></span><br><span class="line">    threadLocalMap.setIndexedVariable(index, v);</span><br><span class="line"><span class="comment">//添加当前的FastThreadLocal到InternalThreadLocalMap的Set&lt;FastThreadLocal&lt;?&gt;&gt;中</span></span><br><span class="line">    addToVariablesToRemove(threadLocalMap, <span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化参数：由子类复写</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> V <span class="title">initialValue</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置值</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if and only if a new thread-local variable has been created</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">setIndexedVariable</span><span class="params">(<span class="keyword">int</span> index, Object value)</span> </span>&#123;</span><br><span class="line">    Object[] lookup = indexedVariables;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; lookup.length) &#123;</span><br><span class="line">        Object oldValue = lookup[index];</span><br><span class="line">        lookup[index] = value;</span><br><span class="line">        <span class="keyword">return</span> oldValue == UNSET;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        expandIndexedVariableTableAndSet(index, value);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果索引小于indexedVariables.length，直接获取indexedVariables[index]；否则，进行扩容设置。</p><p>首先获取旧数组及其长度；然后进行新数组容量的计算（计算方式与1.8的HashMap一样：都是获取比给定值大的最小的2的n次方的数）；然后创建新数组并拷贝旧数组元素到新数组，最后对扩容多出来的元素初始化为UNSET，然后设置value值，最后将新数组赋值给indexedVariables成员变量。</p><p>到此为止设置值的操作就结束了，最后：添加当前的FastThreadLocal到InternalThreadLocalMap的Set&lt;FastThreadLocal&lt;?&gt;&gt;中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addToVariablesToRemove</span><span class="params">(InternalThreadLocalMap threadLocalMap, FastThreadLocal&lt;?&gt; variable)</span> </span>&#123;</span><br><span class="line">    Object v = threadLocalMap.indexedVariable(variablesToRemoveIndex);</span><br><span class="line">    Set&lt;FastThreadLocal&lt;?&gt;&gt; variablesToRemove;</span><br><span class="line"><span class="comment">//v搞成set集合，目的很简单，set里面不会放置重复的 threadLocal，放置同一个threadLocal多次 所有使用TheadLocal都会放到 variablesToRemoveIndex 数组中这个索引位置的</span></span><br><span class="line">    <span class="keyword">if</span> (v == InternalThreadLocalMap.UNSET || v == <span class="keyword">null</span>) &#123;</span><br><span class="line">        variablesToRemove = Collections.newSetFromMap(<span class="keyword">new</span> IdentityHashMap&lt;FastThreadLocal&lt;?&gt;, Boolean&gt;());</span><br><span class="line">        threadLocalMap.setIndexedVariable(variablesToRemoveIndex, variablesToRemove);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 如果拿到的不是 UNSET ，说明这是第二次操作了，因此可以强转为 Set</span></span><br><span class="line">        variablesToRemove = (Set&lt;FastThreadLocal&lt;?&gt;&gt;) v;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//放到要清除set里面</span></span><br><span class="line">    variablesToRemove.add(variable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法的目的是将 FastThreadLocal 对象保存到一个 Set 中，因为 Netty 的 Map 只是一个数组，没有键，所以保存到一个 Set 中，这样就可以判断是否 set 过这个 map，例如 Netty 的 isSet 方法就是根据这个判断的。</p><p>5.注册资源清理器<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当该ftl所在的线程不强可达时，清理其上当前ftl的value和set&lt;FastThreadLocal&lt;?&gt;&gt;中当前的ftl</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerCleaner</span><span class="params">(<span class="keyword">final</span> InternalThreadLocalMap threadLocalMap)</span> </span>&#123;</span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line"><span class="comment">//如果已经开启了自动清理功能 或者 已经对threadLocalMap中当前的FastThreadLocal开启了清理线程</span></span><br><span class="line">    <span class="keyword">if</span> (FastThreadLocalThread.willCleanupFastThreadLocals(current) || threadLocalMap.isCleanerFlagSet(index)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 设置是否已经开启了对当前的FastThreadLocal清理线程的标志</span></span><br><span class="line">    threadLocalMap.setCleanerFlag(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>获取当前线程，如果当前线程是 FastThreadLocalThread 类型 且 cleanupFastThreadLocals 是 true，则返回 true，直接return。也就是说，Netty 线程池里面创建的线程都符合这条件，只有用户自定义的线程池不符合。 当然还有一个条件：如果这个 ftl 的 index + 1 在 map 中的值不是空对象，则已经注册过了，也直接 return，不再重复注册。</p><h3 id="set方法解析"><a href="#set方法解析" class="headerlink" title="set方法解析"></a>set方法解析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果value是UNSET，表示删除当前的ThreadLocal对应的value；</span></span><br><span class="line"><span class="comment"> * 如果不是UNSET，则可能是修改，也可能是新增；</span></span><br><span class="line"><span class="comment"> * 如果是修改，修改value结束后返回;</span></span><br><span class="line"><span class="comment"> * 如果是新增，则先新增value，然后新增ThreadLocal到Set中，最后注册Cleaner清除线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value != InternalThreadLocalMap.UNSET) &#123;</span><br><span class="line">        InternalThreadLocalMap threadLocalMap = InternalThreadLocalMap.get();</span><br><span class="line">        <span class="keyword">if</span> (setKnownNotUnset(threadLocalMap, value)) &#123;</span><br><span class="line">            registerCleaner(threadLocalMap);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 如果设置的值是UNSET，表示清除该FastThreadLocal的value</span></span><br><span class="line">        remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">setKnownNotUnset</span><span class="params">(InternalThreadLocalMap threadLocalMap, V value)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 新增value</span></span><br><span class="line">    <span class="keyword">if</span> (threadLocalMap.setIndexedVariable(index, value)) &#123;</span><br><span class="line"><span class="comment">//添加清除map的线程，针对使用Jdk的Thread，防止内存泄漏</span></span><br><span class="line">        addToVariablesToRemove(threadLocalMap, <span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 修改value</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="remove方法解析"><a href="#remove方法解析" class="headerlink" title="remove方法解析"></a>remove方法解析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//清除当前的FastThreadLocal</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    remove(InternalThreadLocalMap.getIfSet());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(InternalThreadLocalMap threadLocalMap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (threadLocalMap == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 InternalThreadLocalMap 中删除当前的FastThreadLocal对应的value</span></span><br><span class="line">    Object v = threadLocalMap.removeIndexedVariable(index);</span><br><span class="line"><span class="comment">// 从 InternalThreadLocalMap 中的Set&lt;FastThreadLocal&lt;?&gt;&gt;中删除当前的FastThreadLocal对象</span></span><br><span class="line">    removeFromVariablesToRemove(threadLocalMap, <span class="keyword">this</span>);</span><br><span class="line"><span class="comment">//如果删除的是有效值，则进行onRemove方法的回调</span></span><br><span class="line">    <span class="keyword">if</span> (v != InternalThreadLocalMap.UNSET) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            onRemoval((V) v);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            PlatformDependent.throwException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">removeFromVariablesToRemove</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            InternalThreadLocalMap threadLocalMap, FastThreadLocal&lt;?&gt; variable)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Object v = threadLocalMap.indexedVariable(variablesToRemoveIndex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (v == InternalThreadLocalMap.UNSET || v == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    Set&lt;FastThreadLocal&lt;?&gt;&gt; variablesToRemove = (Set&lt;FastThreadLocal&lt;?&gt;&gt;) v;</span><br><span class="line">    variablesToRemove.remove(variable);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除指定位置的对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">removeIndexedVariable</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    Object[] lookup = indexedVariables;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; lookup.length) &#123;</span><br><span class="line">        Object v = lookup[index];</span><br><span class="line">        lookup[index] = UNSET;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> UNSET;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="removeAll方法解析"><a href="#removeAll方法解析" class="headerlink" title="removeAll方法解析"></a>removeAll方法解析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">removeAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    InternalThreadLocalMap threadLocalMap = InternalThreadLocalMap.getIfSet();</span><br><span class="line">    <span class="keyword">if</span> (threadLocalMap == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 从indexedVariables[VARIABLES_TO_REMOVE_INDEX]获取目前InternalThreadLocalMap存储的有效的FastThreadLocal的值，之后遍历Set，进行remove操作</span></span><br><span class="line">        <span class="comment">// 注意：这也是为什么我们会将有效的FastThreadLocal存储在一个Set中的原因（另外，如果没有Set&lt;FastThreadLocal&lt;?&gt;&gt;这个集合的话，我们需要直接去遍历整个indexedVariables数组，可能其中有效的并不多，影响效率）</span></span><br><span class="line">        Object v = threadLocalMap.indexedVariable(variablesToRemoveIndex);</span><br><span class="line">        <span class="keyword">if</span> (v != <span class="keyword">null</span> &amp;&amp; v != InternalThreadLocalMap.UNSET) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            Set&lt;FastThreadLocal&lt;?&gt;&gt; variablesToRemove = (Set&lt;FastThreadLocal&lt;?&gt;&gt;) v;</span><br><span class="line"><span class="comment">//将set先转换为数组,set的for-remove模式会报并发修改异常，array不会</span></span><br><span class="line">            FastThreadLocal&lt;?&gt;[] variablesToRemoveArray =</span><br><span class="line">                    variablesToRemove.toArray(<span class="keyword">new</span> FastThreadLocal[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">for</span> (FastThreadLocal&lt;?&gt; tlv: variablesToRemoveArray) &#123;</span><br><span class="line">                tlv.remove(threadLocalMap);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">//删除当前线程的InternalThreadLocalMap</span></span><br><span class="line">        InternalThreadLocalMap.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread thread = Thread.currentThread();</span><br><span class="line">    <span class="keyword">if</span> (thread <span class="keyword">instanceof</span> FastThreadLocalThread) &#123;</span><br><span class="line">        ((FastThreadLocalThread) thread).setThreadLocalMap(<span class="keyword">null</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        slowThreadLocalMap.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先获取当前线程map，然后获取 Set，将 Set 转成数组，遍历数组，调用 ftl 的 remove 方法。最后，删除线程中 的 map 属性。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>ftl使用了单纯的数组操作来替代了tl的hash表操作，所以在高并发的情况下，ftl操作速度更快。</p><p>ftl直接根据index进行数组set，而tl需要先根据tl的hashcode计算数组下标（而ftl是直接获取），然后再根据线性探测法进行set操作，其间如果发生hash冲突且有无效的Entry时，还要进行Entry的清理和整理操作。最后不管是否冲突，都要进行一次log级别的Entry回收操作，所以慢了。</p><p>ftl相较于tl不好的地方就是内存占用大，不会重复利用已经被删除（用UNSET占位）的数组位置，只会一味增大，是典型的“空间换时间”的操作。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;netty学习系列笔记总结，性能优化工具类之FastThreadLocal源码浅析，错误之处欢迎指正, 共同学习&lt;/p&gt;
    
    </summary>
    
    
      <category term="Netty" scheme="https://blog.tolvyou.cn/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>netty核心组件-nioEventLoop解析</title>
    <link href="https://blog.tolvyou.cn/2018/11/07/netty-nioEventLoop/"/>
    <id>https://blog.tolvyou.cn/2018/11/07/netty-nioEventLoop/</id>
    <published>2018-11-07T11:32:29.000Z</published>
    <updated>2019-02-08T08:19:00.099Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>netty学习系列笔记总结，NioEventLoop源码浅析，错误之处欢迎指正, 共同学习</p><a id="more"></a><h3 id="NioEventLoop创建"><a href="#NioEventLoop创建" class="headerlink" title="NioEventLoop创建"></a>NioEventLoop创建</h3><p>NioEventLoop 的继承图</p><p><img src="http://lishq.oss-cn-beijing.aliyuncs.com/github.io/NioEventLoop.png" alt=""></p><ul><li><p>new NioEventLoopGroup()[线程组，默认2*cpu]</p></li><li><p>new ThreadPerTaskExecutor()[线程创建器]:线程执行器的作用是负责创建NioEventLoopGroup对应底层线程</p></li><li><p>创建NioEventLoop对象数组，for循环创建每个NioEventLoop,调用newChild()配置NioEventLoop核心参数</p></li><li><p>chooserFactory.newChooser()[线程选择器]:给每个新连接分配NioEventLoop线程</p></li></ul><p>1.IO线程组的创建:NioEventLoopGroup</p><ul><li><p>nThreads: Group内产生nTreads个NioEventLoop对象，每个EventLoop都绑定一个线程, 默认值为cpu cores * 2</p></li><li><p>executor: 每个EventLoop在一次run方法调用的生命周期内都是绑定在一个Thread身上(EventLoop父类SingleThreadEventExecutor中的thread实例变量)</p></li><li><p>每个EventLoop都绑定了一个Thread</p></li><li><p>selectorProvider: group内每一个EventLoop都要持有一个selector</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioEventLoopGroup</span><span class="params">(<span class="keyword">int</span> nThreads, Executor executor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(nThreads, executor, SelectorProvider.provider());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">MultithreadEventLoopGroup</span><span class="params">(<span class="keyword">int</span> nThreads, Executor executor, Object... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(nThreads == <span class="number">0</span> ? DEFAULT_EVENT_LOOP_THREADS : nThreads, executor, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">MultithreadEventExecutorGroup</span><span class="params">(<span class="keyword">int</span> nThreads, Executor executor,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            EventExecutorChooserFactory chooserFactory, Object... args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (executor == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//创建线程执行器,线程执行器的作用是负责创建NioEventLoopGroup对应底层线程,// 默认使用线程工厂是 DefaultThreadFactory</span></span><br><span class="line">        executor = <span class="keyword">new</span> ThreadPerTaskExecutor(newDefaultThreadFactory());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//getClass获取到当前类，当前类是一个NIOEventloop</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ThreadFactory <span class="title">newDefaultThreadFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DefaultThreadFactory(getClass());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    children = <span class="keyword">new</span> EventExecutor[nThreads];</span><br><span class="line"><span class="comment">//产生nTreads个NioEventLoop对象保存在children数组中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nThreads; i ++) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> success = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建NioEventLoop对象数组,配置NioEventLoop核心参数</span></span><br><span class="line">            children[i] = newChild(executor, args);</span><br><span class="line">            success = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> Think about if this is a good exception type</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// ......</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程选择器，给每个新连接分配NioEventLoop线程</span></span><br><span class="line">    chooser = chooserFactory.newChooser(children);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.ThreadPerTaskThread</p><ul><li><p>通过构造ThreadFactory，每次执行任务创建线程然后运行线程</p></li><li><p>每次执行任务都会创建一个线程实体FastThreadLocalThread;</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Thread <span class="title">newThread</span><span class="params">(Runnable r, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FastThreadLocalThread(threadGroup, r, name);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>3.创建NioEventLoop线程</p><ul><li><p>newChild():创建NioEventLoop线程</p></li><li><p>保持线程执行器ThreadPerTaskExecutor</p></li><li><p>创建一个MpscQueue:taskQueue用于外部线程执行Netty任务的时候，如果判断不是在NioEventLoop对应线程里面执行，而直接塞到任务队列里面，由NioEventLoop对应线程执行，PlatformDependent.newMpscQueue(maxPendingTasks)创建MpscQueue保存异步任务队列;</p></li><li><p>创建一个selector:provider.openSelector()创建selector轮询初始化连接</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> EventLoop <span class="title">newChild</span><span class="params">(Executor executor, Object... args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> NioEventLoop(<span class="keyword">this</span>, executor, (SelectorProvider) args[<span class="number">0</span>],</span><br><span class="line">            ((SelectStrategyFactory) args[<span class="number">1</span>]).newSelectStrategy(), (RejectedExecutionHandler) args[<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">NioEventLoop(NioEventLoopGroup parent, Executor executor, SelectorProvider selectorProvider,</span><br><span class="line">                 SelectStrategy strategy, RejectedExecutionHandler rejectedExecutionHandler) &#123;</span><br><span class="line">        <span class="keyword">super</span>(parent, executor, <span class="keyword">false</span>, DEFAULT_MAX_PENDING_TASKS, rejectedExecutionHandler);</span><br><span class="line">        <span class="keyword">if</span> (selectorProvider == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"selectorProvider"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (strategy == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"selectStrategy"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        provider = selectorProvider;</span><br><span class="line">        selector = openSelector();</span><br><span class="line">        selectStrategy = strategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">SingleThreadEventExecutor</span><span class="params">(EventExecutorGroup parent, Executor executor,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        <span class="keyword">boolean</span> addTaskWakesUp, <span class="keyword">int</span> maxPendingTasks,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        RejectedExecutionHandler rejectedHandler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(parent);</span><br><span class="line">        <span class="keyword">this</span>.addTaskWakesUp = addTaskWakesUp;</span><br><span class="line">        <span class="keyword">this</span>.maxPendingTasks = Math.max(<span class="number">16</span>, maxPendingTasks);</span><br><span class="line">        <span class="keyword">this</span>.executor = ObjectUtil.checkNotNull(executor, <span class="string">"executor"</span>);</span><br><span class="line">        taskQueue = newTaskQueue(<span class="keyword">this</span>.maxPendingTasks);</span><br><span class="line">        rejectedExecutionHandler = ObjectUtil.checkNotNull(rejectedHandler, <span class="string">"rejectedHandler"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Queue&lt;Runnable&gt; <span class="title">newTaskQueue</span><span class="params">(<span class="keyword">int</span> maxPendingTasks)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// This event loop never calls takeTask()</span></span><br><span class="line">        <span class="keyword">return</span> PlatformDependent.newMpscQueue(maxPendingTasks);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><p>4.创建线程选择器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用chooser.next()方法给新连接绑定对应的NioEventLoop</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> EventExecutor <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> chooser.next();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> EventExecutorChooser <span class="title">newChooser</span><span class="params">(EventExecutor[] executors)</span> </span>&#123;</span><br><span class="line"><span class="comment">//判断是否是2的幂</span></span><br><span class="line">    <span class="keyword">if</span> (isPowerOfTwo(executors.length)) &#123;</span><br><span class="line"><span class="comment">//优化：NioEventLoop索引下标=index++&amp;(length-1)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PowerOfTowEventExecutorChooser(executors);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//普通：NioEventLoop索引下标=abs(index++%length)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> GenericEventExecutorChooser(executors);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="NioEventLoop启动"><a href="#NioEventLoop启动" class="headerlink" title="NioEventLoop启动"></a>NioEventLoop启动</h3><p>1.NioEventLoop启动触发器:</p><ul><li><p>服务端启动绑定端口</p></li><li><p>新连接接入通过chooser绑定一个NioEventLoop</p></li></ul><p>bind-&gt;execute(task)[入口]:调用bind()方法把具体绑定端口操作封装成Task,通过eventLoop()方法获取channelRegistered()注册绑定NioEventLoop执行NioEventLoop的execute()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doBind0</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> ChannelFuture regFuture, <span class="keyword">final</span> Channel channel,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> SocketAddress localAddress, <span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This method is invoked before channelRegistered() is triggered.  Give user handlers a chance to set up</span></span><br><span class="line">    <span class="comment">// the pipeline in its channelRegistered() implementation.</span></span><br><span class="line">    <span class="comment">// 提交了一个绑定任务到 eventLoop</span></span><br><span class="line">    <span class="comment">// 在eventLoop 中对于新的任务的策略是：</span></span><br><span class="line">    <span class="comment">// 判断当前线程是否为该NioEventLoop所关联的线程，如果是，则添加任务到任务队列中</span></span><br><span class="line">    <span class="comment">// 如果不是，则先启动线程，然后添加任务到任务队列中去</span></span><br><span class="line">    channel.eventLoop().execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (regFuture.isSuccess()) &#123;</span><br><span class="line">                <span class="comment">// bind 的实现是在 AbstractChannel 里面</span></span><br><span class="line">                channel.bind(localAddress, promise).addListener(ChannelFutureListener.CLOSE_ON_FAILURE);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                promise.setFailure(regFuture.cause());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"task"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断当前调用execute()方法线程是否为NioEventLoop线程,通过startThread()方法创建启动线程</span></span><br><span class="line">    <span class="keyword">boolean</span> inEventLoop = inEventLoop();</span><br><span class="line">    <span class="keyword">if</span> (inEventLoop) &#123;</span><br><span class="line">        addTask(task);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        startThread();</span><br><span class="line">        addTask(task);</span><br><span class="line">        <span class="keyword">if</span> (isShutdown() &amp;&amp; removeTask(task)) &#123;</span><br><span class="line">            reject();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!addTaskWakesUp &amp;&amp; wakesUpForTask(task)) &#123;</span><br><span class="line">        wakeup(inEventLoop);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.创建线程</p><ul><li><p>ThreadPerTaskExecutor.execute():通过线程执行器ThreadPerTaskExecutor执行任务创建并启动FastThreadLocalThread线程</p></li><li><p>thread = Thread.currentThread():NioEventLoop保存当前创建FastThreadLocalThread线程,保存的目的是为了判断后续对NioEventLoop相关执行的线程是否为本身,如果不是则封装成Task扔到TaskQueue串行执行实现线程安全</p></li><li><p>NioEventLoop.run()[启动]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这一个 if 判断就是为了在线程刚创建的时候起作用，也就是线程刚创建才能进到这里</span></span><br><span class="line">    <span class="keyword">if</span> (STATE_UPDATER.get(<span class="keyword">this</span>) == ST_NOT_STARTED) &#123;</span><br><span class="line">        <span class="keyword">if</span> (STATE_UPDATER.compareAndSet(<span class="keyword">this</span>, ST_NOT_STARTED, ST_STARTED)) &#123;</span><br><span class="line">            delayedTaskQueue.add(<span class="keyword">new</span> ScheduledFutureTask&lt;Void&gt;(<span class="keyword">this</span>, delayedTaskQueue, Executors.&lt;Void&gt;callable(<span class="keyword">new</span> PurgeTask(), <span class="keyword">null</span>), ScheduledFutureTask.deadlineNanos(SCHEDULE_PURGE_INTERVAL), -SCHEDULE_PURGE_INTERVAL));</span><br><span class="line">            <span class="comment">// 线程启动了</span></span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doStartThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> thread == <span class="keyword">null</span>;</span><br><span class="line">    executor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            thread = Thread.currentThread();</span><br><span class="line">            <span class="keyword">if</span> (interrupted) &#123;</span><br><span class="line">                thread.interrupt();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">boolean</span> success = <span class="keyword">false</span>;</span><br><span class="line">            updateLastExecutionTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                SingleThreadEventExecutor.<span class="keyword">this</span>.run();</span><br><span class="line">                success = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                logger.warn(<span class="string">"Unexpected exception from an event executor: "</span>, t);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                    <span class="keyword">int</span> oldState = STATE_UPDATER.get(SingleThreadEventExecutor.<span class="keyword">this</span>);</span><br><span class="line">                    <span class="keyword">if</span> (oldState &gt;= ST_SHUTTING_DOWN || STATE_UPDATER.compareAndSet(</span><br><span class="line">                            SingleThreadEventExecutor.<span class="keyword">this</span>, oldState, ST_SHUTTING_DOWN)) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Check if confirmShutdown() was called at the end of the loop.</span></span><br><span class="line">                <span class="keyword">if</span> (success &amp;&amp; gracefulShutdownStartTime == <span class="number">0</span>) &#123;</span><br><span class="line">                    logger.error(<span class="string">"Buggy "</span> + EventExecutor.class.getSimpleName() + <span class="string">" implementation; "</span> +</span><br><span class="line">                            SingleThreadEventExecutor.class.getSimpleName() + <span class="string">".confirmShutdown() must be called "</span> +</span><br><span class="line">                            <span class="string">"before run() implementation terminates."</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// Run all remaining tasks and shutdown hooks.</span></span><br><span class="line">                    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (confirmShutdown()) &#123;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        cleanup();</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        STATE_UPDATER.set(SingleThreadEventExecutor.<span class="keyword">this</span>, ST_TERMINATED);</span><br><span class="line">                        threadLock.release();</span><br><span class="line">                        <span class="keyword">if</span> (!taskQueue.isEmpty()) &#123;</span><br><span class="line">                            logger.warn(</span><br><span class="line">                                    <span class="string">"An event executor terminated with "</span> +</span><br><span class="line">                                            <span class="string">"non-empty task queue ("</span> + taskQueue.size() + <span class="string">')'</span>);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        terminationFuture.setSuccess(<span class="keyword">null</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="NioEventLoop执行逻辑"><a href="#NioEventLoop执行逻辑" class="headerlink" title="NioEventLoop执行逻辑"></a>NioEventLoop执行逻辑</h3><p>1.检测IO事件</p><ul><li><p>首先执行delayNanos(currentTimeNanos), 这个方法是做什么的呢?</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a)每个EventLoop都有一个延迟执行任务的队列</span><br><span class="line">b)delayNanos就是去这个延迟队列里面瞄一眼是否有非IO任务未执行, 如果没有则返回<span class="number">1</span>秒钟</span><br><span class="line">c)如果很不幸延迟队列里面有任务, delayNanos的计算结果就等于这个task的deadlineNanos到来之前的这段时间, 也即是说select在这个task按预约到期执行的时候就返回了, 不会耽误这个task.</span><br><span class="line">d)如果最终计算出来的可以无忧无虑select的时间(selectDeadLineNanos - currentTimeNanos)小于<span class="number">500000L</span>纳秒, 就认为这点时间是干不出啥大事业的, 还是selectNow一下直接返回吧, 以免耽误了延迟队列里预约好的task.</span><br><span class="line">e)如果大于<span class="number">500000L</span>纳秒, 表示很乐观, 就以<span class="number">1000000L</span>纳秒为时间片, 放肆的去执行阻塞的select了, 阻塞时间就是timeoutMillis(n * <span class="number">1000000L</span>纳秒时间片).</span><br></pre></td></tr></table></figure></li><li><p>阻塞的select返回后,如果遇到以下几种情况则立即返回</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a)如果select到了就绪连接(selectedKeys &gt; <span class="number">0</span>)</span><br><span class="line">b)被用户waken up了（wakeUp标识当前select操作是否为唤醒状态,每次select操作把wakeUp设置为<span class="keyword">false</span>标识此次需要进行select操作并且是未唤醒状态;）</span><br><span class="line">c)任务队列(上面介绍的那个MPSC)来了一个任务</span><br><span class="line">d)延迟队列里面有个预约任务到期需要执行了</span><br></pre></td></tr></table></figure></li><li><p>如果上面情况都不满足, 代表select返回0了, 并且还有时间继续愉快的玩耍</p></li><li><p>这其中有一个统计select次数的计数器selectCnt, select过多并且都返回0, 默认512就代表过多了, 这表示需要调用rebuildSelector()重建selector了, 达到512可能是触发了nio的epoll cpu 100%的bug, 避免下次JDK空轮询继续发生</p></li><li><p>rebuildSelector的实际工作就是:<br>重新打开一个selector, 将原来的那个selector中已注册的所有channel重新注册到新的selector中, 并将老的selectionKey全部cancel掉, 最后将旧的selector关闭</p></li><li><p>重建selector后, 不死心的再selectNow一下</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//select()[检查是否有io事件]:轮询注册到selector上面的io事件</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">select</span><span class="params">(<span class="keyword">boolean</span> oldWakenUp)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Selector selector = <span class="keyword">this</span>.selector;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> selectCnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> currentTimeNanos = System.nanoTime();</span><br><span class="line">        <span class="keyword">long</span> selectDeadLineNanos = currentTimeNanos + delayNanos(currentTimeNanos);</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">long</span> timeoutMillis = (selectDeadLineNanos - currentTimeNanos + <span class="number">500000L</span>) / <span class="number">1000000L</span>;</span><br><span class="line">            <span class="keyword">if</span> (timeoutMillis &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (selectCnt == <span class="number">0</span>) &#123;</span><br><span class="line">                    selector.selectNow();</span><br><span class="line">                    selectCnt = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> selectedKeys = selector.select(timeoutMillis);</span><br><span class="line">            selectCnt ++;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (selectedKeys != <span class="number">0</span> || oldWakenUp || wakenUp.get() || hasTasks() || hasScheduledTasks()) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">                selectCnt = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">long</span> time = System.nanoTime();</span><br><span class="line">            <span class="keyword">if</span> (time - TimeUnit.MILLISECONDS.toNanos(timeoutMillis) &gt;= currentTimeNanos) &#123;</span><br><span class="line">                selectCnt = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (SELECTOR_AUTO_REBUILD_THRESHOLD &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">                    selectCnt &gt;= SELECTOR_AUTO_REBUILD_THRESHOLD) &#123;</span><br><span class="line">                rebuildSelector();</span><br><span class="line">                selector = <span class="keyword">this</span>.selector;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Select again to populate selectedKeys.</span></span><br><span class="line">                selector.selectNow();</span><br><span class="line">                selectCnt = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            currentTimeNanos = time;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (CancelledKeyException ignored) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.处理外部线程扔到TaskQueue里面的任务</p><ul><li><p>EventLoop的大致数据结构是：一个任务队列，一个延迟任务队列(schedule)。分别存放在普通任务队列MpscQueue和定时任务队列ScheduledTaskQueue</p></li><li><p>普通任务队列MpscQueue在创建NioEventLoop构造的,外部线程调用NioEventLoop的execute()方法使用addTask()方法向TaskQueue添加task;</p></li><li><p>定时任务队列ScheduledTaskQueue在调用NioEventLoop的schedule()方法将Callable任务封装成ScheduledFutureTask,判断是否为当前NioEventLoop发起的schedule还是外部线程发起的schedule,当前NioEventLoop发起的schedule直接添加定时任务,外部线程发起的schedule为了保证线程安全(ScheduledTaskQueue是PriorityQueue非线程安全)添加定时任务操作当做普通任务Task保证对于定时任务队列操作都在NioEventLoop实现</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">runAllTasks</span><span class="params">(<span class="keyword">long</span> timeoutNanos)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//先是fetchFromScheduledTaskQueue, 将延迟任务队列中已到期的task拿到非IO任务的队列中,此队列即为上文中提到的MPSC队列.</span></span><br><span class="line">    fetchFromScheduledTaskQueue();</span><br><span class="line">    <span class="comment">//task即是从MPSC queue中弹出的任务</span></span><br><span class="line">    Runnable task = pollTask();</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//又是计算一个deadline</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> deadline = ScheduledFutureTask.nanoTime() + timeoutNanos;</span><br><span class="line">    <span class="keyword">long</span> runTasks = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> lastExecutionTime;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            task.run();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            logger.warn(<span class="string">"A task raised an exception."</span>, t);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        runTasks ++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check timeout every 64 tasks because nanoTime() is relatively expensive.</span></span><br><span class="line">        <span class="comment">// <span class="doctag">XXX:</span> Hard-coded value - will make it configurable if it is really a problem.</span></span><br><span class="line"><span class="comment">//每执行64个任务就检查下时间, 如果到了deadline, 就退出, 没办法, IO任务是亲生的, 非IO任务是后妈生的, 资源肯定要先紧IO任务用.</span></span><br><span class="line">我们使用netty时也要注意, 不要产生大量耗时的非IO任务, 以免影响了IO任务</span><br><span class="line">        <span class="keyword">if</span> ((runTasks &amp; <span class="number">0x3F</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            lastExecutionTime = ScheduledFutureTask.nanoTime();</span><br><span class="line">            <span class="keyword">if</span> (lastExecutionTime &gt;= deadline) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        task = pollTask();</span><br><span class="line">        <span class="keyword">if</span> (task == <span class="keyword">null</span>) &#123;</span><br><span class="line">            lastExecutionTime = ScheduledFutureTask.nanoTime();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.lastExecutionTime = lastExecutionTime;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">fetchFromScheduledTaskQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> nanoTime = AbstractScheduledEventExecutor.nanoTime();</span><br><span class="line">    Runnable scheduledTask  = pollScheduledTask(nanoTime);</span><br><span class="line">    <span class="comment">//while循环获取定时任务队列(按照截止时间&amp;添加时间排序)截止时间为nanoTime的定时任务(截止时间最小)添加到普通任务队列,如果添加失败则重新将定时任务添加到定时任</span></span><br><span class="line">    <span class="keyword">while</span> (scheduledTask != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!taskQueue.offer(scheduledTask)) &#123;</span><br><span class="line">            <span class="comment">// No space left in the task queue add it back to the scheduledTaskQueue so we pick it up again.</span></span><br><span class="line">            scheduledTaskQueue().add((ScheduledFutureTask&lt;?&gt;) scheduledTask);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        scheduledTask  = pollScheduledTask(nanoTime);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>select过后, 对读写等事件的处理优化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processSelectedKeysOptimized</span><span class="params">(SelectionKey[] selectedKeys)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;; i ++) &#123;</span><br><span class="line">        <span class="keyword">final</span> SelectionKey k = selectedKeys[i];</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 每次拿到一个之后SelectionKey立即释放array对这个key的强引用,help gc</span></span><br><span class="line">        selectedKeys[i] = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">final</span> Object a = k.attachment();</span><br><span class="line">        <span class="keyword">if</span> (a <span class="keyword">instanceof</span> AbstractNioChannel) &#123;</span><br><span class="line">            processSelectedKey(k, (AbstractNioChannel) a);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            NioTask&lt;SelectableChannel&gt; task = (NioTask&lt;SelectableChannel&gt;) a;</span><br><span class="line">            processSelectedKey(k, task);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (needsToSelectAgain) &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">if</span> (selectedKeys[i] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                selectedKeys[i] = <span class="keyword">null</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            selectAgain();</span><br><span class="line">            selectedKeys = <span class="keyword">this</span>.selectedKeys.flip();</span><br><span class="line">            i = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用数组替换HashSet<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a.避免了HashSet的频繁自动扩容。</span><br><span class="line">b.屏蔽了remove、contains、iterator这些不需要的功能。</span><br><span class="line">c.对于selectedKeys, 最重要的操作是遍历全部元素，遍历数组效率高于遍历Hashset</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectedSelectionKeySet</span> <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">SelectionKey</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    SelectionKey[] keys;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    SelectedSelectionKeySet() &#123;</span><br><span class="line">        keys = <span class="keyword">new</span> SelectionKey[<span class="number">1024</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(SelectionKey o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        keys[size++] = o;</span><br><span class="line">        <span class="keyword">if</span> (size == keys.length) &#123;</span><br><span class="line">            increaseCapacity();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>用户代码创建Boss/Worker Group NioEventLoop创建,默认创建2倍cpu核数个NioEventLoop,每个NioEventLoop都有线程选择器chooser线程分配并且优化NioEventLoop个数,构造NioEventLoop创建Selector和定时任务队列,创建Selector通过反射使用数组实现替换Selector HashSet数据结构;NioEventLoop调用execute()方法启动FastThreadLocalThread线程,创建线程保存到成员变量;NioEventLoop执行逻辑在run()方法包括检测io事件、处理io事件、执行任务队列</p><p>问:默认情况下,Netty服务端起多少线程?何时启动?<br>答:默认2<em>cpu即Runtime.getRuntime().availableProcessors()</em>2]线程,调用execute()方法判断当前是否在本线程,如果是在本线程说明线程已经启动,如果是在外部线程调用execute()方法,首先调用startThread()方法判断当前线程是否启动,未启动就启动此线程</p><p>问:Netty是如何解决JDK空轮询Bug?<br>答:判断阻塞select操作是否阻塞timeoutMillis时间,未阻塞timeoutMillis时间表示可能触发JDK空轮询;判断触发JDK空轮询的次数是否超过阈值(默认512),超过阈值调用rebuildSelector()方法重建Selector把之前的Selector上面所有的Key重新移到新的Selector避免JDK空轮询的Bug</p><p>问:Netty如何保证异步串行无锁化?<br>答:外部线程调用EventLoop或者Channel方法通过inEventLoop()方法判断得出是外部线程,所有操作封装成Task丢到普通任务队列MpscQueue,异步执行普通任务队列MpscQueue待执行任务</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;netty学习系列笔记总结，NioEventLoop源码浅析，错误之处欢迎指正, 共同学习&lt;/p&gt;
    
    </summary>
    
    
      <category term="Netty" scheme="https://blog.tolvyou.cn/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>netty启动过程源码分析</title>
    <link href="https://blog.tolvyou.cn/2018/11/04/netty-startup-details/"/>
    <id>https://blog.tolvyou.cn/2018/11/04/netty-startup-details/</id>
    <published>2018-11-04T07:38:02.000Z</published>
    <updated>2019-02-08T08:19:27.431Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>netty学习系列笔记总结，服务端启动流程源码浅析，错误之处欢迎指正, 共同学习</p><a id="more"></a><h3 id="服务端启动代码示例"><a href="#服务端启动代码示例" class="headerlink" title="服务端启动代码示例"></a>服务端启动代码示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">        b.group(bossGroup, workerGroup)</span><br><span class="line">         .channel(NioServerSocketChannel.class)</span><br><span class="line">         .option(ChannelOption.SO_BACKLOG, <span class="number">100</span>)</span><br><span class="line">         .handler(<span class="keyword">new</span> LoggingHandler(LogLevel.INFO))</span><br><span class="line">         .childHandler(<span class="keyword">new</span> ChannelInitializer;SocketChannel() &#123;</span><br><span class="line">             <span class="meta">@Override</span></span><br><span class="line">             <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                 ChannelPipeline p = ch.pipeline();</span><br><span class="line">                 p.addLast(<span class="keyword">new</span> EchoServerHandler());</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;);</span><br><span class="line">        <span class="comment">// Start the server.</span></span><br><span class="line">        ChannelFuture f = b.bind(PORT).sync();</span><br><span class="line">        <span class="comment">// Wait until the server socket is closed.</span></span><br><span class="line">        f.channel().closeFuture().sync();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// Shut down all event loops to terminate all threads.</span></span><br><span class="line">        bossGroup.shutdownGracefully();</span><br><span class="line">        workerGroup.shutdownGracefully();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="服务端Channel的创建"><a href="#服务端Channel的创建" class="headerlink" title="服务端Channel的创建"></a>服务端Channel的创建</h3><ul><li>创建底层JDK Channel</li><li>封装JDK Channel</li><li>创建基本组件绑定Channel;</li></ul><p>1.bind(port)[用户代码入口]:serverBootstrap.bind(port)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Configure the server.</span></span><br><span class="line">      EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">      EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">      <span class="keyword">final</span> EchoServerHandler serverHandler = <span class="keyword">new</span> EchoServerHandler();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">          b.group(bossGroup, workerGroup)</span><br><span class="line">           .channel(NioServerSocketChannel.class)</span><br><span class="line">           .option(ChannelOption.SO_BACKLOG, <span class="number">100</span>)</span><br><span class="line">           .handler(<span class="keyword">new</span> LoggingHandler(LogLevel.INFO))</span><br><span class="line">           .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">               <span class="meta">@Override</span></span><br><span class="line">               <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                   ChannelPipeline p = ch.pipeline();</span><br><span class="line">                   <span class="keyword">if</span> (sslCtx != <span class="keyword">null</span>) &#123;</span><br><span class="line">                       p.addLast(sslCtx.newHandler(ch.alloc()));</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="comment">//p.addLast(new LoggingHandler(LogLevel.INFO));</span></span><br><span class="line">                   p.addLast(serverHandler);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// Start the server.</span></span><br><span class="line">          ChannelFuture f = b.bind(PORT).sync();</span><br><span class="line"></span><br><span class="line">          <span class="comment">// Wait until the server socket is closed.</span></span><br><span class="line">          f.channel().closeFuture().sync();</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          <span class="comment">// Shut down all event loops to terminate all threads.</span></span><br><span class="line">          bossGroup.shutdownGracefully();</span><br><span class="line">          workerGroup.shutdownGracefully();</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></p><p>2.initAndRegister()[初始化并注册]<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> ChannelFuture <span class="title">initAndRegister</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Channel channel = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            channel = channelFactory.newChannel();</span><br><span class="line">            init(channel);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            <span class="keyword">if</span> (channel != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// channel can be null if newChannel crashed (eg SocketException("too many open files"))</span></span><br><span class="line">                channel.unsafe().closeForcibly();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// as the Channel is not registered yet we need to force the usage of the GlobalEventExecutor</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> DefaultChannelPromise(channel, GlobalEventExecutor.INSTANCE).setFailure(t);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ChannelFuture regFuture = config().group().register(channel);</span><br><span class="line">        <span class="keyword">if</span> (regFuture.cause() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (channel.isRegistered()) &#123;</span><br><span class="line">                channel.close();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                channel.unsafe().closeForcibly();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> regFuture;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>3.newChannel()[创建服务端Channel]</p><p>通过serverBootstrap.channel()方法传入NioServerSocketChannel类,构造ReflectiveChannelFactory实例将NioServerSocketChannel类设置为反射类; channelFactory.newChannel()通过clazz.newInstance()调用反射类构造方法反射创建服务端Channel</p><p>4.channelFactory在哪里初始化？<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//首先channelFactory在开篇示例代码b.channel(NioServerSocketChannel.class)中被设置成new ReflectiveChannelFactory&lt;C&gt;(NioServerSocketChannel.class)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> B <span class="title">channel</span><span class="params">(Class&lt;? extends C&gt; channelClass)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (channelClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"channelClass"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> channelFactory(<span class="keyword">new</span> ReflectiveChannelFactory&lt;C&gt;(channelClass));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//factory通过反射创建一个NioServerSocketChannel对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectiveChannelFactory</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Channel</span>&gt; <span class="keyword">implements</span> <span class="title">ChannelFactory</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;? extends T&gt; clazz;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReflectiveChannelFactory</span><span class="params">(Class&lt;? extends T&gt; clazz)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (clazz == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"clazz"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.clazz = clazz;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">newChannel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> clazz.newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ChannelException(<span class="string">"Unable to create Channel from class "</span> + clazz, t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>5.通过JDK底层创建socketChannel(服务端Channel创建过程)</p><ul><li>反射创建服务端Channel:NioServerSocketChannel默认构造方法调用newSocket()使用provider.openServerSocketChannel()创建服务端Socket<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> SelectorProvider DEFAULT_SELECTOR_PROVIDER = SelectorProvider.provider();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioServerSocketChannel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(newSocket(DEFAULT_SELECTOR_PROVIDER));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在newSocket()中创建了开篇提到的监听套接字ServerSocketChannel</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ServerSocketChannel <span class="title">newSocket</span><span class="params">(SelectorProvider provider)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> provider.openServerSocketChannel();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ChannelException(<span class="string">"Failed to open a server socket."</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>6.NioServerSocketChannelConfig()[TCP参数配置类]:设置底层JDK Channel TCP参数配置<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SelectionKey.OP_ACCEPT标志就是监听套接字所感兴趣的事件了(但是还没注册进去)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioServerSocketChannel</span><span class="params">(ServerSocketChannel channel)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="keyword">null</span>, channel, SelectionKey.OP_ACCEPT);</span><br><span class="line">        config = <span class="keyword">new</span> NioServerSocketChannelConfig(<span class="keyword">this</span>, javaChannel().socket());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>7.configureBlocking(false)[阻塞模式]:设置非阻塞模式<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//NioServerSocketChannel父类构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">AbstractNioChannel</span><span class="params">(Channel parent, SelectableChannel ch, <span class="keyword">int</span> readInterestOp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(parent);</span><br><span class="line">        <span class="keyword">this</span>.ch = ch;</span><br><span class="line">        <span class="keyword">this</span>.readInterestOp = readInterestOp;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//将ServerSocketChannel设置为非阻塞模式, NIO开始</span></span><br><span class="line">            ch.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ch.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e2) &#123;</span><br><span class="line">                <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">                    logger.warn(</span><br><span class="line">                            <span class="string">"Failed to close a partially initialized socket."</span>, e2);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ChannelException(<span class="string">"Failed to enter non-blocking mode."</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>8.AbstractChannel()[创建id,unsafe,pipeline]<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//继续父类构造方法</span></span><br><span class="line"><span class="number">1</span>)构造一个unsafe绑定在serverChanel上,newUnsafe()由子类AbstractNioMessageChannel实现, unsafe的类型为NioMessageUnsafe,NioMessageUnsafe类型专为serverChanel服务, 专门处理accept连接</span><br><span class="line"><span class="number">2</span>)创建用于NioServerSocketChannel的管道 boss pipeline   </span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">AbstractChannel</span><span class="params">(Channel parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.parent = parent;</span><br><span class="line">        id = newId();</span><br><span class="line">        unsafe = newUnsafe();</span><br><span class="line">        pipeline = newChannelPipeline();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>)head和tail是pipeline的两头, head是outbound event的末尾, tail是inbound event的末尾.</span><br><span class="line">按照上行事件(inbound)顺序来看, 现在pipeline中的顺序是head--&gt;tail</span><br><span class="line">DefaultChannelPipeline(AbstractChannel channel) &#123;</span><br><span class="line">    <span class="keyword">this</span>.channel = channel;</span><br><span class="line"></span><br><span class="line">    tail = <span class="keyword">new</span> TailContext(<span class="keyword">this</span>);</span><br><span class="line">    head = <span class="keyword">new</span> HeadContext(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    head.next = tail;</span><br><span class="line">    tail.prev = head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="服务端Channel的初始化"><a href="#服务端Channel的初始化" class="headerlink" title="服务端Channel的初始化"></a>服务端Channel的初始化</h3><ul><li>init()[初始化服务端channel,初始化入口]</li><li>set ChildOptions,ChildAttrs:提供给通过服务端Channel创建的新连接Channel,每次accept新连接都配置用户自定义的两个属性配置</li><li>config handler[配置服务端Pipeline]</li><li>add ServerBootstrapAcceptor[添加连接器]:提供给accept接入的新连接分配NIO线程</li><li>保存用户自定义基本属性,通过配置属性创建连接接入器,连接接入器每次accept新连接使用自定义属性配置新连接</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.设置NioServerSocketChannel的options和attrs.</span></span><br><span class="line"><span class="comment">//2.预先复制好将来要设置给NioSocketChannel的options和attrs.</span></span><br><span class="line"><span class="comment">//3.init做的第二件事就是在boss pipeline添加一个ChannelInitializer,</span></span><br><span class="line"><span class="comment">//4.那么现在pipeline中的顺序变成了head--&gt;ChannelInitializer--&gt;tail(注意head和tail永远在两头, addLast方法对他俩不起作用)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(Channel channel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">        p.addLast(<span class="keyword">new</span> ChannelInitializer&lt;Channel&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(Channel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">final</span> ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">                ChannelHandler handler = config.handler();</span><br><span class="line">                <span class="keyword">if</span> (handler != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    pipeline.addLast(handler);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                ch.eventLoop().execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        pipeline.addLast(<span class="keyword">new</span> ServerBootstrapAcceptor(</span><br><span class="line">                                currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="注册Selector"><a href="#注册Selector" class="headerlink" title="注册Selector"></a>注册Selector</h3><p>将底层JDK Channel注册到事件轮询器Selector上面,并把服务端Channel作为Attachment绑定在对应底层JDK Channel</p><ul><li><p>AbstractChannel.register(channel)[注册Selector入口]</p></li><li><p>doRegister()</p></li><li><p>调用JDK底层注册:JDK Channel注册Selector调用javaChannel().register(eventLoop().selector, 0, this),将服务端Channel通过Attachment绑定到Selector</p></li><li><p>invokeHandlerAddedIfNeeded():事件回调,触发Handler</p></li><li><p>fireChannelRegistered()[传播事件]</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(EventLoop eventLoop, <span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//赋值操作，后续所有的IO操作交给eventLoop处理</span></span><br><span class="line">            AbstractChannel.<span class="keyword">this</span>.eventLoop = eventLoop;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (eventLoop.inEventLoop()) &#123;</span><br><span class="line"><span class="comment">//实际的注册</span></span><br><span class="line">                register0(promise);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    eventLoop.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                            register0(promise);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                    <span class="comment">// ......</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>register0()<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">register0</span><span class="params">(ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">1.在doRegister()之后还调用了pipeline.fireChannelRegistered(), 触发ChannelInitializer#channelRegistered()方法.</span><br><span class="line">        doRegister();</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">        safeSetSuccess(promise); </span><br><span class="line">        pipeline.fireChannelRegistered();</span><br><span class="line">        <span class="comment">// Only fire a channelActive if the channel has never been registered. This prevents firing</span></span><br><span class="line">        <span class="comment">// multiple channel actives if the channel is deregistered and re-registered.</span></span><br><span class="line">        <span class="keyword">if</span> (firstRegistration &amp;&amp; isActive()) &#123;</span><br><span class="line">            pipeline.fireChannelActive();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>doRegister()<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//javaChannel().register(), 这里先把interestOps注册为0</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doRegister</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> selected = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            selectionKey = javaChannel().register(((NioEventLoop) eventLoop().unwrap()).selector, <span class="number">0</span>, <span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CancelledKeyException e) &#123;</span><br><span class="line">            <span class="comment">// ......</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="服务端口的绑定"><a href="#服务端口的绑定" class="headerlink" title="服务端口的绑定"></a>服务端口的绑定</h3><ul><li><p>AbstractUnsafe.bind()[端口绑定]</p></li><li><p>doBind():javaChannel().bind()[JDK动态绑定]</p></li><li><p>pipeline.fireChannelActive()[传播事件]:HeadContext.readIfIsAutoRead()将注册Selector的事件重新绑定为OP_ACCEPT事件,有新连接接入Selector轮询到OP_ACCEPT事件最终将连接交给Netty处理</p></li><li><p>绑定OP_ACCEPT事件:当端口完成绑定触发active事件,active事件最终调用channel的read事件,read对于服务器来说可以读新连接</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ChannelFuture <span class="title">doBind</span><span class="params">(<span class="keyword">final</span> SocketAddress localAddress)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ChannelFuture regFuture = initAndRegister();</span><br><span class="line">        <span class="keyword">final</span> Channel channel = regFuture.channel();</span><br><span class="line">        <span class="keyword">if</span> (regFuture.cause() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> regFuture;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (regFuture.isDone()) &#123;</span><br><span class="line">            <span class="comment">// At this point we know that the registration was complete and successful.</span></span><br><span class="line">            ChannelPromise promise = channel.newPromise();</span><br><span class="line">            doBind0(regFuture, channel, localAddress, promise);</span><br><span class="line">            <span class="keyword">return</span> promise;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Registration future is almost always fulfilled already, but just in case it's not.</span></span><br><span class="line">            <span class="keyword">final</span> PendingRegistrationPromise promise = <span class="keyword">new</span> PendingRegistrationPromise(channel);</span><br><span class="line">            regFuture.addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    Throwable cause = future.cause();</span><br><span class="line">                    <span class="keyword">if</span> (cause != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// Registration on the EventLoop failed so fail the ChannelPromise directly to not cause an</span></span><br><span class="line">                        <span class="comment">// IllegalStateException once we try to access the EventLoop of the Channel.</span></span><br><span class="line">                        promise.setFailure(cause);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// Registration was successful, so set the correct executor to use.</span></span><br><span class="line">                        <span class="comment">// See https://github.com/netty/netty/issues/2586</span></span><br><span class="line">                        promise.registered();</span><br><span class="line"></span><br><span class="line">                        doBind0(regFuture, channel, localAddress, promise);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">return</span> promise;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>AbstractChannel</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">(<span class="keyword">final</span> SocketAddress localAddress, <span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">boolean</span> wasActive = isActive();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                doBind(localAddress);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                safeSetFailure(promise, t);</span><br><span class="line">                closeIfClosed();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!wasActive &amp;&amp; isActive()) &#123;</span><br><span class="line">                invokeLater(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//JDK底层绑定成功，调用fireChannelActive传播</span></span><br><span class="line">                        pipeline.fireChannelActive();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            safeSetSuccess(promise);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//上面的doBind()调用的是NioServerSocketChannel的实现:</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doBind</span><span class="params">(SocketAddress localAddress)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    javaChannel().socket().bind(localAddress, config.getBacklog());</span><br><span class="line">&#125;</span><br><span class="line">第二个参数backlog的重要性:</span><br><span class="line">在linux内核中TCP握手过程总共会有两个队列:</span><br><span class="line"><span class="number">1</span>)一个俗称半连接队列, 装着那些握手一半的连接(syn queue)</span><br><span class="line"><span class="number">2</span>)另一个是装着那些握手成功但是还没有被应用层accept的连接的队列(accept queue)</span><br><span class="line">backlog的大小跟这两个队列的容量之和息息相关, backlog的值也不是你设置多少它就是多少的</span><br><span class="line"></span><br><span class="line">扩展：对于TCP连接的ESTABLISHED状态, 并不需要应用层accept, 只要在accept queue里就已经变成状态ESTABLISHED</span><br></pre></td></tr></table></figure><p>NioServerSocketChannel</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doBind</span><span class="params">(SocketAddress localAddress)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (PlatformDependent.javaVersion() &gt;= <span class="number">7</span>) &#123;</span><br><span class="line">            javaChannel().bind(localAddress, config.getBacklog());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            javaChannel().socket().bind(localAddress, config.getBacklog());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>AbstractNioChannel端口绑定成功，告诉selector需要关心accept事件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doBeginRead</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// Channel.read() or ChannelHandlerContext.read() was called</span></span><br><span class="line">        <span class="keyword">final</span> SelectionKey selectionKey = <span class="keyword">this</span>.selectionKey;</span><br><span class="line">        <span class="keyword">if</span> (!selectionKey.isValid()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        readPending = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> interestOps = selectionKey.interestOps();</span><br><span class="line">        <span class="keyword">if</span> ((interestOps &amp; readInterestOp) == <span class="number">0</span>) &#123;</span><br><span class="line">            selectionKey.interestOps(interestOps | readInterestOp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Netty服务端启动:</p><ul><li><p>创建服务端Channel:创建底层JDK Channel,封装JDK Channel,创建基本组件绑定Channel;</p></li><li><p>初始化服务端Channel:设置Channel基本属性,添加逻辑处理器;</p></li><li><p>注册Selector:将底层JDK Channel注册到事件轮询器Selector上面,并把服务端Channel作为Attachment绑定在对应底层JDK Channel;</p></li><li><p>端口绑定:实现本地端口监听,绑定成功重新向Selector注册OP_ACCEPT事件接收新连接</p><p></p></li></ul><p>服务端Socket在哪里初始化?<br>反射创建服务端Channel:NioServerSocketChannel默认构造方法调用newSocket()使用provider.openServerSocketChannel()创建服务端Socket</p><p>在哪里accept连接?<br>端口绑定:Pipeline调用fireChannelActive()传播active事件,HeadContext使用readIfIsAutoRead()重新绑定OP_ACCEPT事件,新连接接入Selector轮询到OP_ACCEPT事件处理</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;netty学习系列笔记总结，服务端启动流程源码浅析，错误之处欢迎指正, 共同学习&lt;/p&gt;
    
    </summary>
    
    
      <category term="Netty" scheme="https://blog.tolvyou.cn/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>闪电侠netty小册阅读总结</title>
    <link href="https://blog.tolvyou.cn/2018/11/01/netty-study-review/"/>
    <id>https://blog.tolvyou.cn/2018/11/01/netty-study-review/</id>
    <published>2018-11-01T02:23:40.000Z</published>
    <updated>2019-02-08T08:20:07.002Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p><a href="https://juejin.im/book/5b4bc28bf265da0f60130116/section/5b6a1a9cf265da0f87595521" target="_blank" rel="noopener">Netty 入门与实战：仿写微信 IM 即时通讯系统</a>阅读总结<br><img src="https://lishq.oss-cn-beijing.aliyuncs.com/github.io/Netty%E7%BB%93%E6%9E%84%E4%B8%AD%E8%8B%B1%E5%AF%B9%E7%85%A7%E7%89%88.png" alt="Netty结构中英对照版"></p><a id="more"></a><h3 id="编程模型"><a href="#编程模型" class="headerlink" title="编程模型"></a>编程模型</h3><p>1.传统IO编程</p><p>每个连接创建成功之后都需要一个线程来维护，每个线程包含一个 while 死循环，那么 1w 个连接对应 1w 个线程，继而 1w 个 while 死循环</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">* 线程资源受限：线程是操作系统中非常宝贵的资源，同一时刻有大量的线程处于阻塞状态是非常严重的资源浪费，操作系统耗不起</span><br><span class="line"></span><br><span class="line">* 线程切换效率低下：单机 CPU 核数固定，线程爆炸之后操作系统频繁进行线程切换，应用性能急剧下降</span><br><span class="line"></span><br><span class="line">* 数据读写是以字节流为单位</span><br></pre></td></tr></table></figure><p>2.NIO编程模型</p><p>NIO 编程模型中，新来一个连接不再创建一个新的线程，而是可以把这条连接直接绑定到某个固定的线程，然后这条连接所有的读写都由这个线程来负责</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">* NIO 模型中通常会有两个线程，每个线程绑定一个轮询器 selector ，serverSelector负责轮询是否有新的连接，clientSelector负责轮询连接是否有数据可读</span><br><span class="line"></span><br><span class="line">* 服务端监测到新的连接之后，不再创建一个新的线程，而是直接将新连接绑定到clientSelector上，这样就不用 IO 模型中 <span class="number">1</span>w 个 <span class="keyword">while</span> 循环在死等</span><br><span class="line"></span><br><span class="line">* clientSelector被一个 <span class="keyword">while</span> 死循环包裹着，如果在某一时刻有多条连接有数据可读，那么通过 clientSelector.select(<span class="number">1</span>)方法可以轮询出来，进而批量处理</span><br><span class="line"></span><br><span class="line">* 数据的读写面向 Buffer</span><br></pre></td></tr></table></figure><h3 id="Netty编程"><a href="#Netty编程" class="headerlink" title="Netty编程"></a>Netty编程</h3><p>1.服务端启动流程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">* 创建一个引导类，然后给他指定线程模型，IO模型，连接读写处理逻辑，绑定端口之后，服务端就启动起来了</span><br><span class="line"></span><br><span class="line">* 通过给 bind 方法添加监听器，用以实现自动绑定递增端口</span><br><span class="line"></span><br><span class="line">* attr 方法，为每条连接增加属性，相当于给NioServerSocketChannel维护一个map</span><br><span class="line"></span><br><span class="line">* handler()用于指定在服务端启动过程中的一些逻辑</span><br><span class="line"></span><br><span class="line">* childOption 方法，用于指定处理新连接数据的读写处理逻辑。设置一些TCP底层相关的属性。</span><br><span class="line"></span><br><span class="line">* 关于 TCP连接的优化，SO_KEEPALIVE 底层心跳，TCP_NODELAY （是否开启Nagle算法）延迟发送，SO_BACKLOG （临时存放已完成三次握手的请求的队列的最大长度）等待队列</span><br></pre></td></tr></table></figure><p>2.客户端启动流程<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">* 与服务端启动类似。调用 connect 方法进行连接，返回Future，异步监听是否连接成功。可以增加</span><br><span class="line"></span><br><span class="line">* 重试不在主线程，定时任务是调用 bootstrap.config().group().schedule()</span><br><span class="line"> </span><br><span class="line">* 重连优化：实现指数退避重连逻辑，位运算。</span><br><span class="line"></span><br><span class="line">* option() 方法CONNECT_TIMEOUT_MILLIS 属性</span><br></pre></td></tr></table></figure></p><p>3.客户端与服务端双向通信<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">* initChannel() 方法添加逻辑处理器</span><br><span class="line"></span><br><span class="line">* 调用 ch.pipeline().addLast() 方法 添加一个逻辑处理器。其中ch.pipeline() 返回的是和这条连接相关的逻辑处理链，采用了责任链模式</span><br><span class="line"></span><br><span class="line">* 建立成功之后，会调用channelActive()方法,读取数据用channelRead()方法</span><br><span class="line"></span><br><span class="line">* 客户端与服务端交互的二进制数据载体为 ByteBuf，ByteBuf 通过连接的内存管理器创建，字节数据填充到 ByteBuf 之后才能写到对端</span><br></pre></td></tr></table></figure></p><p>4.ByteBuf<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* 基于读写指针和容量、最大可扩容容量，衍生出一系列的读写方法</span><br><span class="line"></span><br><span class="line">* 多个 ByteBuf 可以引用同一段内存，这段内存可以是堆内也可以是堆外的。通过引用计数来控制内存的释放，遵循谁 retain() 谁 release() 的原则</span><br></pre></td></tr></table></figure></p><p>5.客户端与服务端通信协议编解码。扩展阅读<a href="www.baidu.com">RPC 消息协议</a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">自定义通信协议</span><br><span class="line">* <span class="number">4</span>字节魔数校验</span><br><span class="line">* 版本号，预留字段，用于协议升级</span><br><span class="line">* 序列化算法，表示序列化方式</span><br><span class="line">* <span class="number">1</span>字节指令，每一种指令都会有相应的处理逻辑</span><br><span class="line">* <span class="number">4</span>字节数据长度，用于拆包粘包</span><br><span class="line">* N字节数据内容</span><br></pre></td></tr></table></figure></p><p>6.实现客户端与服务端收发消息<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* channel 的 attr() 绑定属性来设置某些状态，获取某些状态，不需要额外的 map 来维持。</span><br><span class="line">* hannel.attr(Attributes.LOGIN).set(<span class="keyword">true</span>)绑定登陆标识</span><br></pre></td></tr></table></figure></p><p>7.pipeline 与 channelHandler<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* ChannelPipeline 是一个双向链表结构，他和 Channel 之间是一对一的关系。</span><br><span class="line">* ChannelPipeline 里面每个节点都是一个 ChannelHandlerContext 对象，这个对象能够拿到和 Channel 相关的所有的上下文信息，然后这个对象包着一个重要的对象，那就是逻辑处理器ChannelHandler。</span><br></pre></td></tr></table></figure></p><p>8.构建客户端与服务端 pipeline<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* 基于 SimpleChannelInboundHandler，不再需要强转，不再有冗长乏味的 <span class="keyword">if</span> <span class="keyword">else</span> 逻辑，不需要手动传递对象。(对比ChannelInboundHandlerAdapter 和 ChannelOutboundHandlerAdapter理解)</span><br><span class="line"></span><br><span class="line">* 基于 MessageToByteEncoder，我们可以实现自定义编码，而不用关心 ByteBuf 的创建，内存释放。</span><br></pre></td></tr></table></figure></p><p>9.拆包粘包理论与解决方案<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">* <span class="number">1</span>. 固定长度的拆包器 FixedLengthFrameDecoder</span><br><span class="line">  <span class="number">2</span>. 行拆包器 LineBasedFrameDecoder</span><br><span class="line">  <span class="number">3</span>. 分隔符拆包器 DelimiterBasedFrameDecoder</span><br><span class="line">  <span class="number">4</span>. 基于长度域拆包器 LengthFieldBasedFrameDecoder</span><br><span class="line"></span><br><span class="line">* LengthFieldBasedFrameDecoder是最通用的一种拆包器，只要你的自定义协议中包含长度域字段，均可以使用这个拆包器来实现应用层拆包。</span><br><span class="line"></span><br><span class="line">* 扩展LengthFieldBasedFrameDecoder 通过魔数校验尽早屏蔽非本协议的客户端</span><br></pre></td></tr></table></figure></p><p>10.channelHandler 的生命周期<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">* ChannelHandler 启动时回调方法的执行顺序为：handlerAdded() -&gt; channelRegistered() -&gt; channelActive() -&gt; channelRead() -&gt; channelReadComplete()</span><br><span class="line"></span><br><span class="line">* ChannelHandler 关闭时回调方法的执行顺序为：channelInactive() -&gt; channelUnregistered() -&gt; handlerRemoved()</span><br><span class="line"></span><br><span class="line">* channelActive() 与 channelInActive()统计单机的增减连接数</span><br><span class="line"></span><br><span class="line">* channelReadComplete()调用ctx.channel().flush() 批量刷新提升性能</span><br></pre></td></tr></table></figure></p><p>11.使用 channelHandler 的热插拔实现客户端身份校验<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">* 如果有很多业务逻辑的 handler 都要进行某些相同的操作，我们完全可以抽取出一个 handler 来单独处理</span><br><span class="line"></span><br><span class="line">* ctx.pipeline().remove(<span class="keyword">this</span>)移除自身。通过 ChannelHandler 的热插拔机制来实现动态删除逻辑</span><br><span class="line"></span><br><span class="line">* handlerRemoved()通知移除事件</span><br></pre></td></tr></table></figure></p><p>12.客户端互聊原理与实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">* channel.attr(Attributes.SESSION).set(session) 绑定session</span><br><span class="line"></span><br><span class="line">* channel.attr(Attributes.SESSION).set(<span class="keyword">null</span>) 删除 session</span><br><span class="line"></span><br><span class="line">* channel.attr(Attributes.SESSION).get() 拿到 session</span><br><span class="line"></span><br><span class="line">* 通过Map实例化userId -&gt; channel 的映射</span><br></pre></td></tr></table></figure></p><p>13.群聊的发起与通知<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* ChannelGroup channelGroup = <span class="keyword">new</span> DefaultChannelGroup(ctx.executor());</span><br><span class="line">* ChannelGroup：它可以把多个 chanel 的操作聚合在一起，可以往它里面添加删除 channel，可以进行 channel 的批量读写，关闭等操作</span><br></pre></td></tr></table></figure></p><h3 id="性能优化篇"><a href="#性能优化篇" class="headerlink" title="性能优化篇"></a>性能优化篇</h3><p>1.Netty性能优化<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">* 共享 handler</span><br><span class="line">  <span class="number">1</span>.无状态handler直接单例模式，提高效率，也避免了创建很多小的对象。</span><br><span class="line">  <span class="number">2</span>.加上注解标识<span class="meta">@ChannelHandler</span>.Sharable，表明该 handler 是可以多个 channel 共享的</span><br><span class="line"></span><br><span class="line">* 压缩 handler - 合并编解码器——&gt;MessageToMessageCodec</span><br><span class="line"></span><br><span class="line">* 缩短事件传播路径</span><br><span class="line">  <span class="number">1</span>.压缩 handler - 合并平行 handler。定义一个通用handler，依然是可以写成一个单例模式的类。内部维护 map，存放指令到各个指令处理器的映射，回调时通过指令找到具体的 handler</span><br><span class="line">  <span class="number">2</span>.更改事件传播源。ctx.writeAndFlush()对比ctx.channel().writeAndFlush() </span><br><span class="line"></span><br><span class="line">* 减少阻塞主线程的操作</span><br><span class="line">  <span class="number">1</span>.对于数据库或者网络等一些耗时操作，丢到业务线程池处理</span><br><span class="line">  <span class="number">2</span>.计算耗时，使用回调 Future</span><br></pre></td></tr></table></figure></p><p>2.心跳与空闲检测<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* 空闲检测 IdleStateHandler ，连接假死之后会回调 channelIdle() 方法</span><br><span class="line">* 定时心跳 ctx.executor().scheduleAtFixedRate</span><br><span class="line">* 通常空闲检测时间要比发送心跳的时间的两倍要长一些，为了排除偶发的公网抖动，防止误判。</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://juejin.im/book/5b4bc28bf265da0f60130116/section/5b6a1a9cf265da0f87595521&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Netty 入门与实战：仿写微信 IM 即时通讯系统&lt;/a&gt;阅读总结&lt;br&gt;&lt;img src=&quot;https://lishq.oss-cn-beijing.aliyuncs.com/github.io/Netty%E7%BB%93%E6%9E%84%E4%B8%AD%E8%8B%B1%E5%AF%B9%E7%85%A7%E7%89%88.png&quot; alt=&quot;Netty结构中英对照版&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Netty" scheme="https://blog.tolvyou.cn/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>设计模式总结</title>
    <link href="https://blog.tolvyou.cn/2018/10/29/design-mode-review/"/>
    <id>https://blog.tolvyou.cn/2018/10/29/design-mode-review/</id>
    <published>2018-10-29T10:26:17.000Z</published>
    <updated>2018-11-14T01:47:49.942Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>设计模式总结<br><br>项目地址：<a href="https://github.com/lishq/java-pattern-demo" target="_blank" rel="noopener">https://github.com/lishq/java-pattern-demo</a><br></p><h3 id="六大原则"><a href="#六大原则" class="headerlink" title="六大原则"></a>六大原则</h3><h5 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h5><ul><li><p>可以降低类的复杂度，一个类只负责一项职责，其逻辑肯定要比负责多项职责简单的多；</p></li><li><p>提高类的可读性，提高系统的可维护性；</p></li><li><p>变更引起的风险降低，变更是必然的，如果单一职责原则遵守的好，当修改一个功能时，可以显著降低对其他功能的影响。</p></li></ul><a id="more"></a><h5 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h5><ul><li><p>子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。</p></li><li><p>子类中可以增加自己特有的方法。</p></li><li><p>当子类的方法重载父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松。</p></li><li><p>当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。</p></li></ul><h5 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h5><ul><li><p>低层模块尽量都要有抽象类或接口，或者两者都有。</p></li><li><p>变量的声明类型尽量是抽象类或接口。</p></li><li><p>使用继承时遵循里氏替换原则。</p></li></ul><h5 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h5><ul><li><p>接口尽量小，但是要有限度。对接口进行细化可以提高程序设计灵活性是不挣的事实，但是如果过小，则会造成接口数量过多，使设计复杂化。所以一定要适度。</p></li><li><p>为依赖接口的类定制服务，只暴露给调用的类它需要的方法，它不需要的方法则隐藏起来。只有专注地为一个模块提供定制服务，才能建立最小的依赖关系。</p></li><li><p>提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。</p></li></ul><h5 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h5><ul><li><p>一个对象应该对其他对象保持最少的了解。</p></li><li><p>如果类与类的关系越紧密，耦合度越大，当一个类发生改变时，对另一个类的影响也越大，尽量降低类之间的耦合。</p></li><li><p>迪米特法则的初衷是降低类之间的耦合，由于每个类都减少了不必要的依赖，因此的确可以降低耦合关系，可以避免与非直接类的通信，但是通信需要通过中介类，会产生大量的中介类，导致系统变复杂。所以设计时，既要做到结构清晰，又要高内聚，低耦合。</p></li></ul><h5 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h5><ul><li><p>一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。</p></li><li><p>只要我们对前面5项原则遵守的好了，设计出的软件自然是符合开闭原则的</p></li></ul><p>一句话概括:单一职责原则告诉我们实现类要职责单一；里氏替换原则告诉我们不要破坏继承体系；依赖倒置原则告诉我们要面向接口编程；接口隔离原则告诉我们在设计接口的时候要精简单一；迪米特法则告诉我们要降低耦合。而开闭原则是总纲，他告诉我们要对扩展开放，对修改关闭。</p><h3 id="设计模式分类"><a href="#设计模式分类" class="headerlink" title="设计模式分类"></a>设计模式分类</h3><h5 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h5><ul><li>简单工厂模式（Simple Factory）</li><li>工厂方法模式（Factory Method）</li><li>抽象工厂模式（Abstract Factory）</li><li>创建者模式（Builder）</li><li>原型模式（Prototype）</li><li>单例模式（Singleton）</li></ul><p>因为对象的创建会消耗掉系统的很多资源，所以单独对对象的创建进行研究，从而能够高效地创建对象就是创建型模式要探讨的问题。<br><br>创建型模式(Creational Pattern)对类的实例化过程进行了抽象，能够将软件模块中对象的创建和对象的使用分离。为了使软件的结构更加清晰，外界对于这些对象只需要知道它们共同的接口，而不清楚其具体的实现细节，使整个系统的设计更加符合单一职责原则。<br><br>创建型模式在创建什么(What)，由谁创建(Who)，何时创建(When)等方面都为软件设计者提供了尽可能大的灵活性。创建型模式隐藏了类的实例的创建细节，通过隐藏对象如何被创建和组合在一起达到使整个系统独立的目的。</p><h5 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h5><ul><li>外观模式/门面模式（Facade门面模式）</li><li>适配器模式（Adapter）</li><li>代理模式（Proxy）</li><li>装饰模式（Decorator）</li><li>桥梁模式/桥接模式（Bridge）</li><li>组合模式（Composite）</li><li>享元模式（Flyweight）</li></ul><p>在解决了对象的创建问题之后，对象的组成以及对象之间的依赖关系就成了开发人员关注的焦点，因为如何设计对象的结构、继承和依赖关系会影响到后续程序的维护性、代码的健壮性、耦合性等。对象结构的设计很容易体现出设计人员水平的高低<br><br>结构型模式(Structural Pattern)描述如何将类或者对象结合在一起形成更大的结构，就像搭积木，可以通过简单积木的组合形成复杂的、功能更为强大的结构。<br><br>类结构型模式关心类的组合，由多个类可以组合成一个更大的系统，在类结构型模式中一般只存在继承关系和实现关系。对象结构型模式关心类与对象的组合，通过关联关系使得在一个类中定义另一个类的实例对象，然后通过该对象调用其方法。 根据“合成复用原则”，在系统中尽量使用关联关系来替代继承关系，因此大部分结构型模式都是对象结构型模式。</p><h5 id="行为模式"><a href="#行为模式" class="headerlink" title="行为模式"></a>行为模式</h5><ul><li>模板方法模式（Template Method）</li><li>观察者模式（Observer）</li><li>状态模式（State）</li><li>策略模式（Strategy）</li><li>职责链模式（Chain of Responsibility）</li><li>命令模式（Command）</li><li>访问者模式（Visitor）</li><li>调停者模式（Mediator）</li><li>备忘录模式（Memento）</li><li>迭代器模式（Iterator）</li><li>解释器模式（Interpreter）</li></ul><p>在对象的结构和对象的创建问题都解决了之后，就剩下对象的行为问题了，如果对象的行为设计的好，那么对象的行为就会更清晰，它们之间的协作效率就会提高<br><br>行为型模式(Behavioral Pattern)是对在不同的对象之间划分责任和算法的抽象化。<br><br>行为型模式不仅仅关注类和对象的结构，而且重点关注它们之间的相互作用。通过行为型模式，可以更加清晰地划分类与对象的职责，并研究系统在运行时实例对象之间的交互。在系统运行时，对象并不是孤立的，它们可以通过相互通信与协作完成某些复杂功能，一个对象在运行时也将影响到其他对象的运行。<br><br>类行为型模式：类的行为型模式使用继承关系在几个类之间分配行为，类行为型模式主要通过多态等方式来分配父类与子类的职责。<br><br>对象行为型模式：对象的行为型模式则使用对象的聚合关联关系来分配行为，对象行为型模式主要是通过对象关联等方式来分配两个或多个类的职责。根据“合成复用原则”，系统中要尽量使用关联关系来取代继承关系，因此大部分行为型设计模式都属于对象行为型设计模式。</p><blockquote><p>参考：<br><a href="http://www.uml.org.cn/sjms/201211023.asp" target="_blank" rel="noopener">http://www.uml.org.cn/sjms/201211023.asp</a><br>《设计模式》《设计模式之禅》《大话设计模式》</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h3&gt;&lt;p&gt;设计模式总结&lt;br&gt;&lt;br&gt;项目地址：&lt;a href=&quot;https://github.com/lishq/java-pattern-demo&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/lishq/java-pattern-demo&lt;/a&gt;&lt;br&gt;&lt;/p&gt;


&lt;h3 id=&quot;六大原则&quot;&gt;&lt;a href=&quot;#六大原则&quot; class=&quot;headerlink&quot; title=&quot;六大原则&quot;&gt;&lt;/a&gt;六大原则&lt;/h3&gt;&lt;h5 id=&quot;单一职责原则&quot;&gt;&lt;a href=&quot;#单一职责原则&quot; class=&quot;headerlink&quot; title=&quot;单一职责原则&quot;&gt;&lt;/a&gt;单一职责原则&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;可以降低类的复杂度，一个类只负责一项职责，其逻辑肯定要比负责多项职责简单的多；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;提高类的可读性，提高系统的可维护性；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;变更引起的风险降低，变更是必然的，如果单一职责原则遵守的好，当修改一个功能时，可以显著降低对其他功能的影响。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Design" scheme="https://blog.tolvyou.cn/tags/Design/"/>
    
  </entry>
  
  <entry>
    <title>框架设计原则</title>
    <link href="https://blog.tolvyou.cn/2018/10/27/design-framework-principles/"/>
    <id>https://blog.tolvyou.cn/2018/10/27/design-framework-principles/</id>
    <published>2018-10-27T13:21:39.000Z</published>
    <updated>2018-11-14T01:43:45.999Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>好的架构和设计可以增加系统健壮性同时也便于维护。面向对象的设计过程中，需要先进行泛化，抽象。然后对具体的对象进行窄化，细化。<br><br>了解框架设计思想不但可以开阔思维，增加阅读开源项目源码的能力。更能提升一个程序员对程序的抽象和管理能力。<br><br>以下设计理念来源于Dubbo作者梁飞的总结，很有参考学习意义。总结整理以供学习</p><h3 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h3><ul><li>模块分包原则 </li><li>框架扩展原则 </li><li>领域划分原则 </li><li>接口分离原则 </li><li>组件协作原则 </li><li>功能演进原则</li></ul><a id="more"></a><h5 id="模块分包原则"><a href="#模块分包原则" class="headerlink" title="模块分包原则"></a>模块分包原则</h5><p><img src="http://lishq.oss-cn-beijing.aliyuncs.com/github.io/af61105e18efadd4fed58d2046dd2edc.png" alt=""></p><p>对业务进行抽象建模，业务数据与业务逻辑解耦，平台和产品解耦，系统各部件解耦。模块、组件高内聚，低耦合。</p><p>稳定度：各模块被依赖的包应该保持稳定，或者说，被依赖者应当比依赖者稳定，且不能成环状依赖。如果不稳定，将会影响其他的包。</p><p>抽象度，越抽象，越稳定。越具体，越容易变化。</p><h5 id="框架扩展原则"><a href="#框架扩展原则" class="headerlink" title="框架扩展原则"></a>框架扩展原则</h5><p><img src="http://lishq.oss-cn-beijing.aliyuncs.com/github.io/672a888437e529fb6a98044d17372392.png" alt=""></p><p>微核插件式，平等对待第三方。<br>比如Eclipse的微核是OSGi， Spring的微核是BeanFactory，Maven的微核是Plexus，通常核心是不应该带有功能性的，而是一个生命周期和集成容器，这样各功能可以通过相同的方式交互及扩展，并且任何功能都可以被替换， 如果做不到微核，至少要平等对待第三方。</p><p>外置生命周期，尽量引用外部对象的实例，而不类元。尽量使用IOC注入，减少静态工厂方法调用<br>也就是说，框架只负责管理对象，对象的出生和死亡不由框架负责。即，用户应将实例注册到框架中。<br>以服务、数据为中心，构建服务化、组件化架构，具备灵活，按需组合的能力。<br>但Spring就是负责管理对象的生命周期的框架，这个我认为还是在于框架对于自身的定位问题。要灵活对待。</p><p>最少化概念模型，这个其实是一种优化，保持尽可能少的概念，有助于理解。另外，各接口都使用一致的概念模型，能相互指引，并减少模型转换 。</p><p>一致化数据模型：例如 URL 这种对象，就是一致化数据模型，拒绝使用 String 拼接，解析。</p><h5 id="领域划分原则"><a href="#领域划分原则" class="headerlink" title="领域划分原则"></a>领域划分原则</h5><p><img src="http://lishq.oss-cn-beijing.aliyuncs.com/github.io/e428cb260d5059e2b76eb829b20d76f1.png" alt=""></p><p>任何框架或组件，总会有核心领域模型，比如： Spring的Bean，Struts的Action，Dubbo的Service等等。<br>这个核心领域模型及其组成部分称为实体域，它代表着我们要操作的目标本身，实体域通常是线程安的，不管是通过不变类，同步状态，或复制的方式。<br>服务域也就是行为域，它是组件的功能集，同时也负责实体域和会话域的生命周期管理，比如Spring的ApplicationContext，Dubbo的ServiceManager等。 </p><p>领域模型划分优势：</p><ul><li>结构清晰，可直接套用</li><li>充血模型，实体域带行为。</li><li>可变与不可变状态分离，可变状态集中</li><li>所有领域线程安全，不需要加锁</li></ul><p>只有保证领域模型线程安全性设计，可变和不可变状态分离，可变状态集中。才能实现无锁编程。同时，设计一定要轻量。否则，对 GC 来说，将是很大的压力。</p><p>通常实体域都是只读的，即不变状态。会话域都是可变状态。</p><p>服务域无状态，天生线程安全，只需单一实例运行。<br>实体域属性只读，或整个类应用替换，线程安全。<br>会话域只在线程栈中使用，没有竞争，线程安全。</p><h5 id="接口分离原则"><a href="#接口分离原则" class="headerlink" title="接口分离原则"></a>接口分离原则</h5><p><img src="http://lishq.oss-cn-beijing.aliyuncs.com/github.io/46554fc0da119db1baad976dfc723974.png" alt=""></p><ul><li>接口分离，单一职责原则的实现。</li><li>API 面向用户，SPI 面向开发者。两者必须分离。</li><li>声明式 API 和过程式 SPI</li><li>API 可配置，一定可编程</li><li>区分命令和查询，例如，不应该有 updateAndGet 这个方法（不包括原子类），应该分成 2 个方法，保证 get 方法幂等。</li><li>对称性接口：有 get 方法，就应该有 set 方法，有 add 就由 remove，称之为对称性和完备性。这样用户能自行推导出接口。</li><li>兼容性：如果接口加方法，应该是增加子接口的方式。</li></ul><h5 id="组件协作原则"><a href="#组件协作原则" class="headerlink" title="组件协作原则"></a>组件协作原则</h5><p><img src="http://lishq.oss-cn-beijing.aliyuncs.com/github.io/cb6a0ca958c2985d429cc45abac5f32d.png" alt=""></p><p>首先Dubbo 是管道式设计。一个 Invoker 贯通整个流程，比如Netty的EventLoop、pipeline</p><p>关于派发，比如Spring 的 dispatchServlet</p><p>Dubbo 暴露、引用、调用事件，都预留了监听器。</p><p>关键路径，即在管道使用责任连模式进行拦截，保证每个拦截器职责单一。</p><p>非关键路径，采用后置事件派发，不能影响主流程运行。</p><p>防御性编程。</p><ul><li>防止空指针和下标越界，我认为这类问题是最不应该出现的，每敲一行代码都要考虑到 </li><li>保证线程安全性和可见性，防止高并发下出现莫名其妙的问题</li><li>尽早失败和前置断言，这样报错后，其实内部状态可能已经混乱</li><li>分离可靠操作和不可靠操作，比如，写入一个线程安全的Map，可以认为是可靠的，而写入数据库等，可以认为是不可靠的，不可靠操作要增加容错</li><li>异常防御，但不忽略异常 </li><li>缩小可变域和尽量final </li><li>降低修改时的误解性，不埋雷 一个原则就是永远不要区分null引用和empty值。 </li><li>提高代码的可测性 </li></ul><h5 id="功能演进原则"><a href="#功能演进原则" class="headerlink" title="功能演进原则"></a>功能演进原则</h5><p><img src="http://lishq.oss-cn-beijing.aliyuncs.com/github.io/6fcd66cafe23063ceed105eb3d56301a.png" alt=""></p><ul><li>开闭原则，微核心加插件机制。 软件质量的下降，来源于修改。</li><li>每个扩展点只封装一个变化因子，最大化复用。</li><li>全管道式设计，框架自身逻辑，均使用截面拦截实现。 </li><li>加功能的姿势：应该是增量式，而不是扩充式，即不在原有基础上修改，而是新增加功能。</li><li>关于高阶：顶层接口尽量抽象，且不能依赖底层实现。这样，当底层实现变化时，高层无需变化。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="http://lishq.oss-cn-beijing.aliyuncs.com/github.io/2b5587c1a1f805391fec5bd2aba7b2ac.png" alt=""></p><blockquote><p>参考：<a href="http://javatar.iteye.com/blog/706098" target="_blank" rel="noopener">http://javatar.iteye.com/blog/706098</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h3&gt;&lt;p&gt;好的架构和设计可以增加系统健壮性同时也便于维护。面向对象的设计过程中，需要先进行泛化，抽象。然后对具体的对象进行窄化，细化。&lt;br&gt;&lt;br&gt;了解框架设计思想不但可以开阔思维，增加阅读开源项目源码的能力。更能提升一个程序员对程序的抽象和管理能力。&lt;br&gt;&lt;br&gt;以下设计理念来源于Dubbo作者梁飞的总结，很有参考学习意义。总结整理以供学习&lt;/p&gt;

&lt;h3 id=&quot;大纲&quot;&gt;&lt;a href=&quot;#大纲&quot; class=&quot;headerlink&quot; title=&quot;大纲&quot;&gt;&lt;/a&gt;大纲&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;模块分包原则 &lt;/li&gt;
&lt;li&gt;框架扩展原则 &lt;/li&gt;
&lt;li&gt;领域划分原则 &lt;/li&gt;
&lt;li&gt;接口分离原则 &lt;/li&gt;
&lt;li&gt;组件协作原则 &lt;/li&gt;
&lt;li&gt;功能演进原则&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Design" scheme="https://blog.tolvyou.cn/tags/Design/"/>
    
  </entry>
  
  <entry>
    <title>redis的集群模式</title>
    <link href="https://blog.tolvyou.cn/2018/10/16/redis-cluster/"/>
    <id>https://blog.tolvyou.cn/2018/10/16/redis-cluster/</id>
    <published>2018-10-16T03:58:00.000Z</published>
    <updated>2019-02-08T08:21:16.402Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>Redis 集群是一个提供在多个Redis间节点间共享数据的程序集<br>Redis 集群方案： Codis、Cluster（去中心化）</p><a id="more"></a><h3 id="cluster-集群"><a href="#cluster-集群" class="headerlink" title="cluster 集群"></a>cluster 集群</h3><ul><li>自动分割数据到不同的节点上</li><li>整个集群的部分节点失败或者不可达的情况下能够继续处理命令。</li><li>不支持处理多个keys的命令,因为这需要在不同的节点间移动数据</li><li>在执行故障转移期间， 集群可能会丢失写命令。<br><img src="http://lishq.oss-cn-beijing.aliyuncs.com/github.io/ca055e87a773c7e1cb8505333e0f340b.png" alt=""><br>如图所示，该集群有三个 Redis 节点组成，每个节点负责整个集群的一部分数据，每个节点负责的数据多少可能不一样。这三个节点相互连接组成一个对等的集群，它们之间通过一种特殊的二进制协议相互交互集群信息。</li></ul><h3 id="槽位定位算法"><a href="#槽位定位算法" class="headerlink" title="槽位定位算法"></a>槽位定位算法</h3><p>Cluster 默认会对 key 值使用 crc16 算法进行 hash 得到一个整数值，然后用这个整数值对 16384 进行取模来得到具体槽位。</p><p>Cluster 还允许用户强制某个 key 挂在特定槽位上</p><p>这种设计对增删节点友好，不会停止服务。</p><p>增加节点时：将部分节点数据移动到新加的节点；<br>删除节点时：将需要删除的节点数据移动到其他节点上。</p><h3 id="容错"><a href="#容错" class="headerlink" title="容错"></a>容错</h3><p>Redis Cluster 可以为每个主节点设置若干个从节点，单主节点故障时，集群会自动将其中某个从节点提升为主节点。如果某个主节点没有从节点，那么当它发生故障时，集群将完全处于不可用状态。不过 Redis 也提供了一个参数cluster-require-full-coverage可以允许部分节点故障，其它节点还可以继续提供对外访问。</p><h3 id="Redis-一致性保证"><a href="#Redis-一致性保证" class="headerlink" title="Redis 一致性保证"></a>Redis 一致性保证</h3><p>Redis 并不能保证数据的强一致性：<br>1.集群使用了异步复制<br>2.集群出现了网络抖动<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Redis 集群的一个重要的配置选项</span><br><span class="line">cluster-node-timeout</span><br><span class="line">cluster-slave-validity-factor</span><br></pre></td></tr></table></figure></p><p>cluster-node-timeout，表示当某个节点持续 timeout 的时间失联时，才可以认定该节点出现故障，需要进行主从切换。如果没有这个选项，网络抖动会导致主从频繁切换 (数据的重新复制)。</p><p>cluster-slave-validity-factor作为倍乘系数来放大这个超时时间来宽松容错的紧急程度。如果这个系数为零，那么主从切换是不会抗拒网络抖动的。如果这个系数大于 1，它就成了主从切换的松弛系数</p><h3 id="可能下线与确定下线"><a href="#可能下线与确定下线" class="headerlink" title="可能下线与确定下线"></a>可能下线与确定下线</h3><p>因为 Redis Cluster 是去中心化的，一个节点认为某个节点失联了并不代表所有的节点都认为它失联了。所以集群还得经过一次协商的过程，只有当大多数节点都认定了某个节点失联了，集群才认为该节点需要进行主从切换来容错。</p><p>Redis 集群节点采用 <a href="http://kaiyuan.me/2015/07/08/Gossip/" target="_blank" rel="noopener">Gossip协议</a>来广播自己的状态以及自己对整个集群认知的改变</p><blockquote><p>参考：<a href="http://redis.cn/topics/sentinel.html" target="_blank" rel="noopener">http://redis.cn/topics/sentinel.html</a><br><a href="http://redis.cn/topics/cluster-spec.html" target="_blank" rel="noopener">http://redis.cn/topics/cluster-spec.html</a><br>《redis设计与实现（第二版）》</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h3&gt;&lt;p&gt;Redis 集群是一个提供在多个Redis间节点间共享数据的程序集&lt;br&gt;Redis 集群方案： Codis、Cluster（去中心化）&lt;/p&gt;
    
    </summary>
    
    
      <category term="Redis" scheme="https://blog.tolvyou.cn/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>redis的sentinel模式</title>
    <link href="https://blog.tolvyou.cn/2018/10/16/redis-sentinel/"/>
    <id>https://blog.tolvyou.cn/2018/10/16/redis-sentinel/</id>
    <published>2018-10-16T02:15:06.000Z</published>
    <updated>2018-10-29T11:12:04.285Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><ul><li>Redis Sentinel 是一个分布式系统，用于管理多个 Redis 服务器（instance），本质上只是一个运行在特殊模式下的 Redis 服务器，提供高可用性(HA)解决方案</li></ul><h3 id="Sentinel"><a href="#Sentinel" class="headerlink" title="Sentinel"></a>Sentinel</h3><ul><li>监控： Sentinel 会不断地检查你的主服务器和从服务器是否运作正常。</li><li>提醒： 当被监控的某个 Redis 服务器出现问题时， Sentinel 可以通过 API 向管理员或者其他应用程序发送通知。</li><li>自动故障迁移： 当一个主服务器不能正常工作时， Sentinel 会开始一次自动故障迁移操作， 它会将失效主服务器的其中一个从服务器升级为新的主服务器， 并让失效主服务器的其他从服务器改为复制新的主服务器； 当客户端试图连接失效的主服务器时， 集群也会向客户端返回新主服务器的地址， 使得集群可以使用新主服务器代替失效服务器。</li></ul><a id="more"></a><h3 id="消息丢失"><a href="#消息丢失" class="headerlink" title="消息丢失"></a>消息丢失</h3><ul><li>Redis 主从采用异步复制</li><li>Sentinel 无法保证消息完全不丢失，可以通过限制主从延迟过大，尽可能保证消息少丢失。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">min-slaves-to-write <span class="number">1</span></span><br><span class="line">min-slaves-max-lag <span class="number">10</span></span><br></pre></td></tr></table></figure><p>第一个参数表示主节点必须至少有一个从节点在进行正常复制，否则就停止对外写服务，丧失可用性。<br><br>第二个参数单位是秒，表示如果 10s 没有收到从节点的反馈，就意味着从节点同步不正常，要么网络断开了，要么一直没有给反馈。</p><h3 id="Sentinel作为服务器的命令表"><a href="#Sentinel作为服务器的命令表" class="headerlink" title="Sentinel作为服务器的命令表"></a>Sentinel作为服务器的命令表</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisCommand</span> <span class="title">sentinelcmds</span>[] = &#123;</span></span><br><span class="line">    &#123;<span class="string">"ping"</span>,pingCommand,<span class="number">1</span>,<span class="string">""</span>,<span class="number">0</span>,<span class="literal">NULL</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"sentinel"</span>,sentinelCommand,<span class="number">-2</span>,<span class="string">""</span>,<span class="number">0</span>,<span class="literal">NULL</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"subscribe"</span>,subscribeCommand,<span class="number">-2</span>,<span class="string">""</span>,<span class="number">0</span>,<span class="literal">NULL</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"unsubscribe"</span>,unsubscribeCommand,<span class="number">-1</span>,<span class="string">""</span>,<span class="number">0</span>,<span class="literal">NULL</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"psubscribe"</span>,psubscribeCommand,<span class="number">-2</span>,<span class="string">""</span>,<span class="number">0</span>,<span class="literal">NULL</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"punsubscribe"</span>,punsubscribeCommand,<span class="number">-1</span>,<span class="string">""</span>,<span class="number">0</span>,<span class="literal">NULL</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"info"</span>,sentinelInfoCommand,<span class="number">-1</span>,<span class="string">""</span>,<span class="number">0</span>,<span class="literal">NULL</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="自动发现"><a href="#自动发现" class="headerlink" title="自动发现"></a>自动发现</h3><p>当Sentinel发现主服务器有新的从服务器出现时，Sentinel除了会为这个新的从服务器创建相应的实例结构之外，Sentinel还会创建连接到从服务器的命令连接和订阅服务</p><p>无需设置sentinel对应其他sentinel的地址，通过发布，订阅功能来自动发现正在监视相同主服务器的其他sentinel，这一功能是通过想频道 sentinel:hello发送信息来实现的。</p><ul><li><p>默认情况下，Sentinel会以每两秒一次的频率，通过命令连接向所有被监视的主服务器和从服务器发送命令，包含sentinel的ip，端口，pid</p></li><li><p>每个sentinel都会订阅被他监视服务的 sentinel:hello频道，如果有新的sentinel加入，更新自己的sentinel列表</p></li><li><p>对于监视同一个服务器的多个Sentinel来说，一个Sentinel发送的信息会被其它Sentinel<br>接收到，用于更新自己的sentinel列表</p></li><li><p>添加新的sentinel时，先检查列表中是否已存在相同id或者相同地址的sentinel，如有，先移除</p></li><li>Sentinel之间不会创建订阅连接</li></ul><h3 id="主观-客观下线状态检查"><a href="#主观-客观下线状态检查" class="headerlink" title="主观/客观下线状态检查"></a>主观/客观下线状态检查</h3><ul><li>主观下线（SDOWN）指的是单个 Sentinel 实例对服务器做出的下线判断。</li><li>客观下线（ODOWN）指的是多个 Sentinel 实例在对同一个服务器做出 SDOWN 判断， 并且通过 SENTINEL is-master-down-by-addr 命令互相交流之后， 得出的服务器下线判断。</li></ul><p>服务器对 PING 命令的有效回复包含：</p><ul><li>+PONG</li><li>-LOADING</li><li>-MASTERDOWN</li></ul><p>对于主服务器：主观下线状态切换到客观下线状态，使用<a href="http://kaiyuan.me/2015/07/08/Gossip/" target="_blank" rel="noopener">Gossip协议</a>，在sentinel给定的时间内，从sentinel收集到了足够数量的主服务器下线报告，状态改成客观下线。</p><p>客观下线只适合主服务器。</p><p>其他类型的redis实例，sentinel判断下线无需协商。</p><h5 id="每个-Sentinel-都需要定期执行的任务"><a href="#每个-Sentinel-都需要定期执行的任务" class="headerlink" title="每个 Sentinel 都需要定期执行的任务"></a>每个 Sentinel 都需要定期执行的任务</h5><ul><li>每个 Sentinel 以每秒钟一次的频率向它所知的主从服务器以及其他 Sentinel 实例发送一个 PING 命令。</li><li>如果一个实例（instance）距离最后一次有效回复 PING 命令的时间超过 down-after-milliseconds 选项所指定的值， 那么这个实例会被 Sentinel 标记为主观下线。 </li><li>如果一个主服务器被标记为主观下线， 那么正在监视这个主服务器的所有 Sentinel 要以每秒一次的频率确认主服务器的确进入了主观下线状态。</li><li>如果一个主服务器被标记为主观下线， 并且有足够数量的 Sentinel （配置文件指定的数量）在指定的时间范围内同意这一判断， 那么这个主服务器被标记为客观下线。</li><li>主服务器被 Sentinel 标记为客观下线时， Sentinel 向下线主服务器的所有从服务器发送 INFO 命令的频率会从 10 秒一次改为每秒一次。</li><li>当没有足够数量的 Sentinel 同意主服务器已经下线， 主服务器的客观下线状态就会被移除。 当主服务器重新向 Sentinel 的 PING 命令返回有效回复时， 主服务器的主管下线状态就会被移除。</li></ul><h3 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h3><ul><li>在已下线主服务器的所有从服务器里面，挑选出一个从服务器，并将其转换为<br>主服务器。</li><li>让已下线主服务器属下的所有从服务器改为复制新的主服务器</li><li>将已下线主服务器设置为新的主服务器的从服务器，当这个旧的主服务器重新上线时，它就会<br>成为新的主服务器的从服务器</li></ul><h5 id="新的主服务器是怎么挑选出来的"><a href="#新的主服务器是怎么挑选出来的" class="headerlink" title="新的主服务器是怎么挑选出来的"></a>新的主服务器是怎么挑选出来的</h5><p>领头Sentinel会将已下线主服务器的所有从服务器保存到一个列表里面</p><ul><li>删除处于下线或者断线状态的从服务器</li><li>删除最近 5s 内没有回复过领头Sentinel的INFO命令的从服务器</li><li>删除与已下线主服务器连接断开超过down-after-milliseconds * 10 ms 的从服务器</li><li>剩下的，选择优先级最高、复制偏移量最大的从服务器，如果复制偏移量不可用，选择运行ID最小的从服务器升级为主服务器</li></ul><blockquote><p>参考：<a href="http://redis.cn/topics/sentinel.html" target="_blank" rel="noopener">http://redis.cn/topics/sentinel.html</a><br>《redis设计与实现（第二版）》</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Redis Sentinel 是一个分布式系统，用于管理多个 Redis 服务器（instance），本质上只是一个运行在特殊模式下的 Redis 服务器，提供高可用性(HA)解决方案&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;Sentinel&quot;&gt;&lt;a href=&quot;#Sentinel&quot; class=&quot;headerlink&quot; title=&quot;Sentinel&quot;&gt;&lt;/a&gt;Sentinel&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;监控： Sentinel 会不断地检查你的主服务器和从服务器是否运作正常。&lt;/li&gt;
&lt;li&gt;提醒： 当被监控的某个 Redis 服务器出现问题时， Sentinel 可以通过 API 向管理员或者其他应用程序发送通知。&lt;/li&gt;
&lt;li&gt;自动故障迁移： 当一个主服务器不能正常工作时， Sentinel 会开始一次自动故障迁移操作， 它会将失效主服务器的其中一个从服务器升级为新的主服务器， 并让失效主服务器的其他从服务器改为复制新的主服务器； 当客户端试图连接失效的主服务器时， 集群也会向客户端返回新主服务器的地址， 使得集群可以使用新主服务器代替失效服务器。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Redis" scheme="https://blog.tolvyou.cn/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>redis数据结构之『跳跃列表』</title>
    <link href="https://blog.tolvyou.cn/2018/10/15/redis-data-structure-skiplist/"/>
    <id>https://blog.tolvyou.cn/2018/10/15/redis-data-structure-skiplist/</id>
    <published>2018-10-15T07:57:29.000Z</published>
    <updated>2018-10-29T07:51:05.677Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>跳跃表在 Redis 中不如链表和字典等数据结构的应用广泛，只有两个地方用到。一是实现有序集合键，另一个是在集群节点中用作内部数据结构。 </p><p>项目地址：<a href="https://github.com/lishq/redis-base-demo" target="_blank" rel="noopener">https://github.com/lishq/redis-base-demo</a></p><ul><li>Redis 的 zset 是一个复合结构</li><li>需要hash存储value和score的关系</li><li>需要提供按照 score 来排序的功能</li><li>需要能够指定 score 的范围来获取 value 列表的功能，「跳跃列表」</li></ul><p><img src="http://lishq.oss-cn-beijing.aliyuncs.com/github.io/6f55aaf8f7a2a2932bc26af41b10ff95.png" alt=""></p><a id="more"></a><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p><img src="http://lishq.oss-cn-beijing.aliyuncs.com/github.io/b9ea9798c55317dc4af25ef559ab6029.png" alt=""></p><ul><li>Redis 的跳跃表共有 64 层</li><li>最底层双向链表，保证数据存储，有序排列</li><li>不同的 kv 层高可能不一样，层数越高的 kv 越少</li><li>每一个层元素的遍历都是从 kv header 出发</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zslnode</span> &#123;</span></span><br><span class="line">  <span class="built_in">string</span> value;</span><br><span class="line">  <span class="keyword">double</span> score;</span><br><span class="line">  zslnode*[] forwards;  <span class="comment">// 多层连接指针</span></span><br><span class="line">  zslnode* backward;  <span class="comment">// 回溯指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zsl</span> &#123;</span></span><br><span class="line">  zslnode* header; <span class="comment">// 跳跃列表头指针</span></span><br><span class="line">  <span class="keyword">int</span> maxLevel; <span class="comment">// 跳跃列表当前的最高层</span></span><br><span class="line">  <span class="built_in">map</span>&lt;<span class="built_in">string</span>, zslnode*&gt; ht; <span class="comment">// hash 结构的所有键值对</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查找过程"><a href="#查找过程" class="headerlink" title="查找过程"></a>查找过程</h3><p><img src="http://lishq.oss-cn-beijing.aliyuncs.com/github.io/41b6036f2249e072eff9f749e27c409b.png" alt=""></p><ul><li>二分查找</li><li>逐层下降，搜索路径</li></ul><h3 id="随机层数"><a href="#随机层数" class="headerlink" title="随机层数"></a>随机层数</h3><ul><li>对于每一个新插入的节点，都需要调用一个随机算法给它分配一个合理的层数。直观上期望的目标是 50% 的 Level1，25% 的 Level2。</li><li>跳跃列表会记录一下当前的最高层数maxLevel，遍历时从这个 maxLevel 开始遍历</li></ul><h3 id="插入过程"><a href="#插入过程" class="headerlink" title="插入过程"></a>插入过程</h3><ul><li>查找到位置，如果score相等判断value</li><li>创建节点，分配随机层数</li><li>将搜索路径上的节点和新节点通过前后指针串起来</li></ul><h3 id="删除过程"><a href="#删除过程" class="headerlink" title="删除过程"></a>删除过程</h3><ul><li>类似插入过程</li><li>同时还要注意更新一下最高层数maxLevel</li></ul><h3 id="排名计算"><a href="#排名计算" class="headerlink" title="排名计算"></a>排名计算</h3><ul><li>每一个 forward 指针都增加了 span 属性</li><li>将「搜索路径」上的经过的所有节点的跨度 span 值进行叠加就可以算出元素的最终 rank 值</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h3&gt;&lt;p&gt;跳跃表在 Redis 中不如链表和字典等数据结构的应用广泛，只有两个地方用到。一是实现有序集合键，另一个是在集群节点中用作内部数据结构。 &lt;/p&gt;
&lt;p&gt;项目地址：&lt;a href=&quot;https://github.com/lishq/redis-base-demo&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/lishq/redis-base-demo&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Redis 的 zset 是一个复合结构&lt;/li&gt;
&lt;li&gt;需要hash存储value和score的关系&lt;/li&gt;
&lt;li&gt;需要提供按照 score 来排序的功能&lt;/li&gt;
&lt;li&gt;需要能够指定 score 的范围来获取 value 列表的功能，「跳跃列表」&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://lishq.oss-cn-beijing.aliyuncs.com/github.io/6f55aaf8f7a2a2932bc26af41b10ff95.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Redis" scheme="https://blog.tolvyou.cn/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>redis数据结构之『快速列表』</title>
    <link href="https://blog.tolvyou.cn/2018/10/15/redis-data-structure-quicklist/"/>
    <id>https://blog.tolvyou.cn/2018/10/15/redis-data-structure-quicklist/</id>
    <published>2018-10-15T07:17:15.000Z</published>
    <updated>2019-02-08T08:21:50.139Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>Redis 早期版本存储 list 列表数据结构使用的是压缩列表 ziplist 和普通的双向链表 linkedlist，也就是元素少时用 ziplist，元素多时用 linkedlist。</p><p>项目地址：<a href="https://github.com/lishq/redis-base-demo" target="_blank" rel="noopener">https://github.com/lishq/redis-base-demo</a></p><a id="more"></a><h3 id="linkedlist"><a href="#linkedlist" class="headerlink" title="linkedlist"></a>linkedlist</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 链表的节点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">listNode</span>&lt;T&gt; &#123;</span></span><br><span class="line">    listNode* prev;</span><br><span class="line">    listNode* next;</span><br><span class="line">    T value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 链表</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list</span> &#123;</span></span><br><span class="line">    listNode *head;</span><br><span class="line">    listNode *tail;</span><br><span class="line">    <span class="keyword">long</span> length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>考虑到链表的附加空间相对太高，prev 和 next 指针就要占去 16 个字节 (64bit 系统的指针是 8 个字节)，另外每个节点的内存都是单独分配，会加剧内存的碎片化，影响内存管理效率。后续版本对列表数据结构进行了改造，使用 quicklist 代替了 ziplist 和 linkedlist。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; rpush lishq:test redis mongodb spark</span><br><span class="line">(integer) <span class="number">3</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; debug object lishq:test</span><br><span class="line">Value at:<span class="number">0x7f3bd7e285b0</span> refcount:<span class="number">1</span> encoding:quicklist serializedlength:<span class="number">36</span> lru:<span class="number">12861819</span> lru_seconds_idle:<span class="number">22</span> ql_nodes:<span class="number">1</span> ql_avg_node:<span class="number">3.00</span> ql_ziplist_max:<span class="number">-2</span> ql_compressed:<span class="number">0</span> ql_uncompressed_size:<span class="number">34</span></span><br></pre></td></tr></table></figure><h3 id="quicklist"><a href="#quicklist" class="headerlink" title="quicklist"></a>quicklist</h3><p>quicklist 是 ziplist 和 linkedlist 的混合体，它将 linkedlist 按段切分，每一段使用 ziplist 来紧凑存储，多个 ziplist 之间使用双向指针串接起来。<br><img src="http://lishq.oss-cn-beijing.aliyuncs.com/github.io/2b47a047f227087f9116bed2e28dbdcf.PNG" alt=""></p><ul><li>为了进一步节约空间，Redis 还会对 ziplist 进行压缩存储，使用 LZF 算法压缩，可以选择压缩深度。</li></ul><h3 id="压缩深度"><a href="#压缩深度" class="headerlink" title="压缩深度"></a>压缩深度</h3><ul><li>quicklist 内部默认单个 ziplist 长度为 8k 字节，超出了这个字节数，就会新起一个 ziplist。ziplist 的长度由配置参数list-max-ziplist-size决定。</li><li>quicklist 默认的压缩深度是 0，也就是不压缩。压缩的实际深度由配置参数list-compress-depth决定。</li><li>为了支持快速的 push/pop 操作，quicklist 的首尾两个 ziplist 不压缩，此时深度就是 1。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h3&gt;&lt;p&gt;Redis 早期版本存储 list 列表数据结构使用的是压缩列表 ziplist 和普通的双向链表 linkedlist，也就是元素少时用 ziplist，元素多时用 linkedlist。&lt;/p&gt;

&lt;p&gt;项目地址：&lt;a href=&quot;https://github.com/lishq/redis-base-demo&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/lishq/redis-base-demo&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Redis" scheme="https://blog.tolvyou.cn/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>redis数据结构之『压缩列表』</title>
    <link href="https://blog.tolvyou.cn/2018/10/15/redis-data-structure-ziplist/"/>
    <id>https://blog.tolvyou.cn/2018/10/15/redis-data-structure-ziplist/</id>
    <published>2018-10-15T03:52:05.000Z</published>
    <updated>2019-02-08T08:22:17.296Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>Redis 为了节约内存空间使用，zset 和 hash 容器对象在元素个数较少的时候，采用压缩列表 (ziplist) 进行存储。压缩列表是一块连续的内存空间，元素之间紧挨着存储，没有任何冗余空隙。</p><p>项目地址：<a href="https://github.com/lishq/redis-base-demo" target="_blank" rel="noopener">https://github.com/lishq/redis-base-demo</a></p><a id="more"></a><h3 id="ziplist"><a href="#ziplist" class="headerlink" title="ziplist"></a>ziplist</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ziplist</span>&lt;T&gt; &#123;</span></span><br><span class="line">    int32 zlbytes; <span class="comment">// 整个压缩列表占用字节数</span></span><br><span class="line">    int32 zltail_offset; <span class="comment">// 最后一个元素距离压缩列表起始位置的偏移量，用于快速定位到最后一个节点</span></span><br><span class="line">    int16 zllength; <span class="comment">// 元素个数</span></span><br><span class="line">    T[] entries; <span class="comment">// 元素内容列表，挨个挨个紧凑存储</span></span><br><span class="line">    int8 zlend; <span class="comment">// 标志压缩列表的结束，值恒为 0xFF</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://lishq.oss-cn-beijing.aliyuncs.com/github.io/1f9af5f57d26904a0f5518f0198f1035.PNG" alt=""></p><p>压缩列表为了支持双向遍历，所以才会有 ztail_offset 这个字段，用来快速定位到最后一个元素，然后倒着遍历。</p><p>entry 块随着容纳的元素类型不同，也会有不一样的结构。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">entry</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span>&lt;var&gt; prevlen; <span class="comment">// 前一个 entry 的字节长度</span></span><br><span class="line">    <span class="keyword">int</span>&lt;var&gt; encoding; <span class="comment">// 元素类型编码</span></span><br><span class="line">    optional byte[] content; <span class="comment">// 元素内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>它的 prevlen 字段表示前一个 entry 的字节长度，当压缩列表倒着遍历时，需要通过这个字段来快速定位到下一个元素的位置。</li><li>它是一个变长的整数，如果entry.content小于254字节，prevlen是1个字节，内容大于254则prevlen是5个字节。所以list中内容变化可能导致级联更新的问题。</li><li>当字符串长度比较长的时候，5 个字节只占用不到(5/(254+5))&lt;2%的空间。</li></ul><h3 id="增加元素"><a href="#增加元素" class="headerlink" title="增加元素"></a>增加元素</h3><p>因为 ziplist 都是紧凑存储，没有冗余空间 (对比一下 Redis 的字符串结构)。意味着插入一个新的元素就需要调用 realloc 扩展内存。取决于内存分配器算法和当前的 ziplist 内存大小，realloc 可能会重新分配新的内存空间，并将之前的内容一次性拷贝到新的地址，也可能在原有的地址上进行扩展，这时就不需要进行旧内容的内存拷贝。<br><br>如果 ziplist 占据内存太大，重新分配内存和拷贝内存就会有很大的消耗。所以 ziplist 不适合存储大型字符串，存储的元素也不宜过多。</p><h3 id="连锁更新"><a href="#连锁更新" class="headerlink" title="连锁更新"></a>连锁更新</h3><ul><li>如果 ziplist 里面每个 entry 恰好都存储了 253 字节的内容，那么第一个 entry 内容的修改就会导致后续所有 entry 的级联更新，这就是一个比较耗费计算资源的操作。</li><li>如果 ziplist 里面每个 entry 恰好都存储了 253 字节的内容，其中big 节点的长度大于等于 254 字节， 而 small 节点的长度小于 254 字节， 那么当我们将 small 节点从压缩列表中删除之后， 也会导致后续所有 entry 的级联更新。</li></ul><h3 id="IntSet-小整数集合"><a href="#IntSet-小整数集合" class="headerlink" title="IntSet 小整数集合"></a>IntSet 小整数集合</h3><p>当 set 集合容纳的元素都是整数并且元素个数较小时，Redis 会使用 intset 来存储结合元素。intset 是紧凑的数组结构，同时支持 16 位、32 位和 64 位整数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">intset</span>&lt;T&gt; &#123;</span></span><br><span class="line">    int32 encoding; <span class="comment">// 决定整数位宽是 16 位、32 位还是 64 位</span></span><br><span class="line">    int32 length; <span class="comment">// 元素个数</span></span><br><span class="line">    <span class="keyword">int</span>&lt;T&gt; contents; <span class="comment">// 整数数组，可以是 16 位、32 位和 64 位</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="http://lishq.oss-cn-beijing.aliyuncs.com/github.io/53e1557addc1d3bbd33716131da89960.PNG" alt=""></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; sadd lishq:test <span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line">(integer) <span class="number">3</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; debug object lishq:test</span><br><span class="line">Value at:<span class="number">0x7f3bd7e28590</span> refcount:<span class="number">1</span> encoding:intset serializedlength:<span class="number">15</span> lru:<span class="number">12860648</span> lru_seconds_idle:<span class="number">18</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; sadd lishq:test java</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; debug object lishq:test</span><br><span class="line">Value at:<span class="number">0x7f3bd7e28590</span> refcount:<span class="number">1</span> encoding:hashtable serializedlength:<span class="number">12</span> lru:<span class="number">12860705</span> lru_seconds_idle:<span class="number">11</span></span><br></pre></td></tr></table></figure><p>观察 debug object 的输出字段 encoding 的值，可以发现当 set 里面放进去了非整数值时，存储形式立即从 intset 转变成了 hash 结构。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>压缩列表是一种为节约内存而开发的顺序型数据结构。</li><li>压缩列表被用作列表键和哈希键的底层实现之一。</li><li>压缩列表可以包含多个节点，每个节点可以保存一个字节数组或者整数值。</li><li>添加新节点到压缩列表， 或者从压缩列表中删除节点， 可能会引发连锁更新操作， 但这种操作出现的几率并不高。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h3&gt;&lt;p&gt;Redis 为了节约内存空间使用，zset 和 hash 容器对象在元素个数较少的时候，采用压缩列表 (ziplist) 进行存储。压缩列表是一块连续的内存空间，元素之间紧挨着存储，没有任何冗余空隙。&lt;/p&gt;
&lt;p&gt;项目地址：&lt;a href=&quot;https://github.com/lishq/redis-base-demo&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/lishq/redis-base-demo&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Redis" scheme="https://blog.tolvyou.cn/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>redis数据结构之『字典』</title>
    <link href="https://blog.tolvyou.cn/2018/10/15/redis-data-structure-dict/"/>
    <id>https://blog.tolvyou.cn/2018/10/15/redis-data-structure-dict/</id>
    <published>2018-10-15T03:09:26.000Z</published>
    <updated>2019-02-08T08:22:41.765Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>dict 是 Redis 服务器中出现最为频繁的复合型数据结构</p><p>项目地址：<a href="https://github.com/lishq/redis-base-demo" target="_blank" rel="noopener">https://github.com/lishq/redis-base-demo</a></p><a id="more"></a><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><ul><li>hash结构使用dict</li><li>redis所有的key-value组成一个全局dict</li><li>带过期时间的key也是一个dict</li><li>zset存储value和score值映射关系使用dict</li><li>set的结构底层实现也是dict，只不过所有的value都是NULL<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RedisDb</span> &#123;</span></span><br><span class="line">    dict* dict; <span class="comment">// all keys  key=&gt;value</span></span><br><span class="line">    dict* expires; <span class="comment">// all expired keys key=&gt;long(timestamp)</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zset</span> &#123;</span></span><br><span class="line">    dict *dict; <span class="comment">// all values  value=&gt;score</span></span><br><span class="line">    zskiplist *zsl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="dict-内部结构"><a href="#dict-内部结构" class="headerlink" title="dict 内部结构"></a>dict 内部结构</h3><p><img src="http://lishq.oss-cn-beijing.aliyuncs.com/github.io/0a44d4f76cbb411b8a006ac4f43f7044.PNG" alt=""></p><p>dict结构内部包含两个 hashtable，通常情况下只有一个 hashtable 是有值的。但是在 dict 扩容缩容时，需要分配新的 hashtable，然后进行渐进式搬迁，这时候两个 hashtable 存储的分别是旧的 hashtable 和新的 hashtable。待搬迁结束后，旧的 hashtable 的值被删除，新hashtable 取而代之。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">    dictht ht[<span class="number">2</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://lishq.oss-cn-beijing.aliyuncs.com/github.io/fa8f8460eb97ddcb51b37f59f146b551.PNG" alt=""><br>类似Java的HashMap，数组+链表的形式。</p><h3 id="渐进式rehash"><a href="#渐进式rehash" class="headerlink" title="渐进式rehash"></a>渐进式rehash</h3><p>大字典的扩容是遍历链表中所有旧元素，copy到新的数组下，O(n)的操作，所以redis执行渐进式搬迁。</p><ul><li><p>当前dict的hset，hdel会触发搬迁操作</p></li><li><p>redis定时任务中主动进行搬迁</p></li></ul><h3 id="hash函数"><a href="#hash函数" class="headerlink" title="hash函数"></a>hash函数</h3><p>Redis 的字典默认的 hash 函数是 siphash。siphash 算法即使在输入 key 很小的情况下，也可以产生随机性特别好的输出，而且它的性能也非常突出</p><h3 id="扩容条件"><a href="#扩容条件" class="headerlink" title="扩容条件"></a>扩容条件</h3><p>正常情况下，当 hash 表中元素的个数等于第一维数组的长度时，就会开始扩容，扩容的新数组是原数组大小的 2 倍。不过如果 Redis 正在做 bgsave，为了减少内存页的过多分离 (Copy On Write)，Redis 尽量不去扩容 (dict_can_resize)，但是如果 hash 表已经非常满了，元素的个数已经达到了第一维数组长度的 5 倍 (dict_force_resize_ratio)，说明 hash 表已经过于拥挤了，这个时候就会强制扩容。</p><h3 id="缩容条件"><a href="#缩容条件" class="headerlink" title="缩容条件"></a>缩容条件</h3><p>当 hash 表因为元素的逐渐删除变得越来越稀疏时，Redis 会对 hash 表进行缩容来减少 hash 表的第一维数组空间占用。缩容的条件是元素个数低于数组长度的 10%。缩容不会考虑 Redis 是否正在做 bgsave。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h3&gt;&lt;p&gt;dict 是 Redis 服务器中出现最为频繁的复合型数据结构&lt;/p&gt;
&lt;p&gt;项目地址：&lt;a href=&quot;https://github.com/lishq/redis-base-demo&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/lishq/redis-base-demo&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Redis" scheme="https://blog.tolvyou.cn/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>redis数据结构之『字符串』</title>
    <link href="https://blog.tolvyou.cn/2018/10/15/redis-data-structure-string/"/>
    <id>https://blog.tolvyou.cn/2018/10/15/redis-data-structure-string/</id>
    <published>2018-10-15T02:10:44.000Z</published>
    <updated>2019-02-08T08:23:12.703Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>Redis 中的字符串是可以修改的字符串，在内存中它是以字节数组的形式存在的。由于Redis对字符串在安全性、效率以及功能方面的要求。自己构建了一种名为简单动态字符串（simple dynamic string，SDS）的抽象类型， 并将 SDS 用作 Redis 的默认字符串表示。</p><ul><li>除了用来保存数据库中的字符串值之外， SDS 还被用作缓冲区（buffer）</li><li>AOF 模块中的 AOF 缓冲区， 以及客户端状态中的输入缓冲区， 都是由 SDS 实现的</li></ul><p>项目地址：<a href="https://github.com/lishq/redis-base-demo" target="_blank" rel="noopener">https://github.com/lishq/redis-base-demo</a></p><a id="more"></a><h3 id="RedisObject"><a href="#RedisObject" class="headerlink" title="RedisObject"></a>RedisObject</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SDS</span>&lt;T&gt; &#123;</span></span><br><span class="line">  T capacity; <span class="comment">// 数组容量</span></span><br><span class="line">  T len; <span class="comment">// 数组长度</span></span><br><span class="line">  byte flags; <span class="comment">// 特殊标识位，不理睬它</span></span><br><span class="line">  byte[] content; <span class="comment">// 数组内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的 SDS 结构使用了范型 T，为什么不直接用 int 呢，这是因为当字符串比较短时，len 和 capacity 可以使用 byte 和 short 来表示，Redis 为了对内存做极致的优化，不同长度的字符串使用不同的结构体来表示。<br><br>### embstr vs raw<br></p><p>Redis 的字符串有两种存储方式，在长度特别短时，使用 emb 形式存储 (embeded)，当长度超过 44 时，使用 raw 形式存储。</p><p>Redis 对象头结构体<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RedisObject</span> &#123;</span></span><br><span class="line">    int4 type; <span class="comment">// 4bits</span></span><br><span class="line">    int4 encoding; <span class="comment">// 4bits</span></span><br><span class="line">    int24 lru; <span class="comment">// 24bits</span></span><br><span class="line">    int32 refcount; <span class="comment">// 4bytes ；对象引用计数器，内存回收</span></span><br><span class="line">    <span class="keyword">void</span> *ptr; <span class="comment">// 8bytes，64-bit system；指向对象内容的具体存储位置</span></span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure></p><ul><li>一个 RedisObject 对象头需要占据 16 字节的存储空间。</li></ul><p>SDS结构体<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SDS</span> &#123;</span></span><br><span class="line">    int8 capacity; <span class="comment">// 1byte</span></span><br><span class="line">    int8 len; <span class="comment">// 1byte</span></span><br><span class="line">    int8 flags; <span class="comment">// 1byte</span></span><br><span class="line">    byte[] content; <span class="comment">// 内联数组，长度为 capacity</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>在字符串比较小时，SDS 对象头的大小是capacity+3，至少是 3。意味着分配一个字符串的最小空间占用为 19 字节 (16+3)。</li></ul><p><img src="http://lishq.oss-cn-beijing.aliyuncs.com/github.io/f5bce2a1817a05af15e5b21c3dc5a0df.png" alt=""></p><p>embstr将RedisObject对象头和sds连续存储，只需要一次malloc，占用内存更少。但是每次改变需要重新分配内存。</p><p>raw需要两次malloc，两个对象头在内存地址不连续。</p><p>因为jemalloc/tcmalloc 等分配内存的单位是2的指数。如果长度超过64bytes，redis认为是大字符串。不再使用embstr存储，改用raw形式。<br><img src="http://lishq.oss-cn-beijing.aliyuncs.com/github.io/72c2095b0441cf8770dc6ca3ec43a17c.png" alt=""><br>看上面这张图可以算出，留给 content 的长度最多只有 45(64-19) 字节了。字符串又是以\0结尾，之所以多出这样一个字节，是为了便于直接使用 glibc 的字符串处理函数，所以 embstr 最大能容纳的字符串长度就是 44。</p><h3 id="扩容策略"><a href="#扩容策略" class="headerlink" title="扩容策略"></a>扩容策略</h3><p>字符串在长度小于 1M 之前，扩容空间采用加倍策略，也就是保留 100% 的冗余空间。当长度超过 1M 之后，为了避免加倍后的冗余空间过大而导致浪费，每次扩容只会多分配 1M 大小的冗余空间。</p><p>Redis 规定字符串的长度不得超过 512M 字节。创建字符串时 len 和 capacity 一样长，不会多分配冗余空间，这是因为绝大多数场景下我们不会使用 append 操作来修改字符串。</p><h3 id="C字符串和-SDS-之间的区别"><a href="#C字符串和-SDS-之间的区别" class="headerlink" title="C字符串和 SDS 之间的区别"></a>C字符串和 SDS 之间的区别</h3><ul><li>获取字符串长度的复杂度由O(N)降为O(1) 。</li><li>API 是安全的，不会造成缓冲区溢出。</li><li>修改字符串长度 N 次最多需要执行 N 次内存重分配。</li><li>可以保存文本或者二进制数据。</li><li>可以使用一部分 &lt;string.h&gt; 库中的函数。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h3&gt;&lt;p&gt;Redis 中的字符串是可以修改的字符串，在内存中它是以字节数组的形式存在的。由于Redis对字符串在安全性、效率以及功能方面的要求。自己构建了一种名为简单动态字符串（simple dynamic string，SDS）的抽象类型， 并将 SDS 用作 Redis 的默认字符串表示。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;除了用来保存数据库中的字符串值之外， SDS 还被用作缓冲区（buffer）&lt;/li&gt;
&lt;li&gt;AOF 模块中的 AOF 缓冲区， 以及客户端状态中的输入缓冲区， 都是由 SDS 实现的&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;项目地址：&lt;a href=&quot;https://github.com/lishq/redis-base-demo&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/lishq/redis-base-demo&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Redis" scheme="https://blog.tolvyou.cn/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>基于切面/快照/日志/操作/统计的通用服务</title>
    <link href="https://blog.tolvyou.cn/2018/09/26/java-annotation-common-log/"/>
    <id>https://blog.tolvyou.cn/2018/09/26/java-annotation-common-log/</id>
    <published>2018-09-26T02:04:46.000Z</published>
    <updated>2018-09-26T03:32:17.340Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>aop + 自定义注解，实现统一日志，统计，的功能。</p><p>期望能满足如下要求：</p><ul><li>高吞吐</li><li>支持同步，异步两种模式，分别代表，允许丢数据，不允许丢数据</li></ul><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><ul><li>登陆登出、系统核心功能调用频率统计、系统运行关键数据收集等</li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>需要一个自定义注解，一个aop，一个异步线程持续将数据写入到数据库中。当然也可以考虑同步的。</li></ul><a id="more"></a><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>方法上的调用代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AuditLog</span>(operation = <span class="string">"动作标识"</span>,objectType=<span class="string">"类型标识"</span>,type=async,<span class="keyword">module</span>=<span class="string">"模块标识"</span>,</span><br><span class="line">        objectName=<span class="meta">@Value</span>(<span class="string">"args[]"</span>),level=<span class="string">"日志级别"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">publishProblem</span><span class="params">(Object args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//dosomething</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>aop中的代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuditLogInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> AuditLogger auditLogger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> ExecutorService executors = <span class="keyword">new</span> TraceThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line"><span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line"><span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">around</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">Object o = pjp.proceed();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Method method = Modifier.isInterface(pjp.getSignature().getDeclaringType().getModifiers()) ?</span><br><span class="line">pjp.getTarget().getClass().getMethod(pjp.getSignature().getName(), ((MethodSignature) pjp.getSignature()).getMethod().getParameterTypes())</span><br><span class="line">: ((MethodSignature) pjp.getSignature()).getMethod();</span><br><span class="line">AuditLog auditLog = method.getAnnotation(AuditLog.class);</span><br><span class="line"><span class="keyword">if</span> (!SyswareUtil.isEmpty(auditLog)) &#123;</span><br><span class="line">executors.execute(<span class="keyword">new</span> AuditLogInterceptor.AuditLogThread(auditLogger,</span><br><span class="line">getAuditLog(auditLog, pjp.getArgs(), o)));</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> AuditLogException(<span class="string">"获取实现方法发生错误："</span> + e.getMessage());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuditLogThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> AuditLogger service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> AuditLogObject instance;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AuditLogThread</span><span class="params">(AuditLogger service, AuditLogObject instance)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.service = service;</span><br><span class="line"><span class="keyword">this</span>.instance = instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">service.log(instance);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><a href="http://dushenzhi.top/2016/12/11/%E5%B0%86ThreadLocal%E4%BC%A0%E9%80%92%E5%88%B0%E5%AD%90%E7%BA%BF%E7%A8%8B/" target="_blank" rel="noopener">多线程参数传递问题</a><br>使用多线程时父线程中的上下文信息通常无法直接传递到子线程中去，容易造成程序bug。</p><ul><li>method-1：每次都手动的将子线程需要用到的ThreadLocal数据传递到子线程中，这样子线程也能随时获取到线程上下文信息。</li><li>method-2：自定义一个ThreadPoolExecutor代替系统的ThreadPoolExecutor，每次用线程池提交线程任务时，线程池会自动将父线程的ThreadLocal自动传递到子线程中，避免每次手动传递ThreadLocal到子线程。<br>method-2实现<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TraceThreadPoolExecutor</span> <span class="keyword">extends</span> <span class="title">ThreadPoolExecutor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TraceThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize, <span class="keyword">int</span> maximumPoolSize, <span class="keyword">long</span> keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TraceThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize, <span class="keyword">int</span> maximumPoolSize, <span class="keyword">long</span> keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TraceThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize, <span class="keyword">int</span> maximumPoolSize, <span class="keyword">long</span> keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, handler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TraceThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize, <span class="keyword">int</span> maximumPoolSize, <span class="keyword">long</span> keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory, handler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(<span class="keyword">final</span> Runnable command)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Operator operator = OperationContext.getInstance().getOperator();</span><br><span class="line">        <span class="keyword">final</span> String userId = operator.getUserId();</span><br><span class="line">        Runnable task = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            OperationContextUtil.operatorContext(userId);</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    command.run();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                    <span class="comment">//dosomething</span></span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    OperationContext.getInstance().clear();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">super</span>.execute(task);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="考虑的点"><a href="#考虑的点" class="headerlink" title="考虑的点"></a>考虑的点</h3><ul><li>分布式部署，server端随时上下线会不会有影响，基本上常见的并发编程问题。</li><li>更优雅的接入方式，提供一个jar包，方法上增加一个注解即可。</li><li>与CAT等常用优秀开源产品的结合使用</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>保证效率和代码质量的情况下，根据自身项目去灵活实现。合适自己的才是最好的</li><li>后续遇到其他的使用方案再进行补充</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h3&gt;&lt;p&gt;aop + 自定义注解，实现统一日志，统计，的功能。&lt;/p&gt;

&lt;p&gt;期望能满足如下要求：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;高吞吐&lt;/li&gt;
&lt;li&gt;支持同步，异步两种模式，分别代表，允许丢数据，不允许丢数据&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;场景&quot;&gt;&lt;a href=&quot;#场景&quot; class=&quot;headerlink&quot; title=&quot;场景&quot;&gt;&lt;/a&gt;场景&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;登陆登出、系统核心功能调用频率统计、系统运行关键数据收集等&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;&lt;/a&gt;思路&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;需要一个自定义注解，一个aop，一个异步线程持续将数据写入到数据库中。当然也可以考虑同步的。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://blog.tolvyou.cn/tags/Java/"/>
    
      <category term="Annotation" scheme="https://blog.tolvyou.cn/tags/Annotation/"/>
    
  </entry>
  
  <entry>
    <title>Java-GC总结</title>
    <link href="https://blog.tolvyou.cn/2018/09/23/java-gc-review/"/>
    <id>https://blog.tolvyou.cn/2018/09/23/java-gc-review/</id>
    <published>2018-09-23T15:23:42.000Z</published>
    <updated>2018-11-23T01:23:00.852Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>最近读了周志明先生写的深入理解jvm，不敢说理解有多深。总结以供回顾。</p><h3 id="自动内存管理机制"><a href="#自动内存管理机制" class="headerlink" title="自动内存管理机制"></a>自动内存管理机制</h3><p><img src="http://lishq.oss-cn-beijing.aliyuncs.com/github.io/6b0f6224a74263815dcbdd6bc0b71b76.png" alt="内存自动管理机制"></p><a id="more"></a><h3 id="对象是否已死"><a href="#对象是否已死" class="headerlink" title="对象是否已死"></a>对象是否已死</h3><ul><li>可达性分析算法<p>判断对象是否存活的算法是这样的：通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连时，则<br>证明此对象是不可用的。此外，这里没有使用引用记数算法，因为很难解决对象之间相互引用的关系。</p></li></ul><p><img src="http://lishq.oss-cn-beijing.aliyuncs.com/github.io/9355159b98ad8116b2835ad8727f1dc4.png" alt="可达性分析算法"></p><h3 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h3><h4 id="标记-清除-Mark-Sweep-算法"><a href="#标记-清除-Mark-Sweep-算法" class="headerlink" title="标记-清除(Mark-Sweep)算法"></a>标记-清除(Mark-Sweep)算法</h4><ul><li>效率不高；标记清除之后会产生大量空间碎片，导致提前触发一下次GC<p>首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象</p></li></ul><h4 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h4><ul><li>实现简单，运行高效。代价是把内存缩小为了原来的一半<p>将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面然后再把已使用过的内存空间一次清理掉。</p></li></ul><h4 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h4><p>标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</p><h4 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h4><p>根据对象存活周期的不同将内存划分为几块。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集都发现有大批对象死去，只有少量存活，那就选用复制算法。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须用“标记-清理”或者“标记-整理”算法来进行回收。</p><h3 id="常见垃圾收集器"><a href="#常见垃圾收集器" class="headerlink" title="常见垃圾收集器"></a>常见垃圾收集器</h3><ul><li>串行 Serial 单线程的一个回收器，简单，易实现，效率高</li><li>并行 ParNew Serial的多线程版，可以充分的利用cpu的资源，减少回收的时间</li><li>吞吐量优先 Parallel Scavenge，侧重于吞吐量的控制</li><li>并发标记清除 CMS concurrent mark sweep 一种以获取最短回收停顿时间为目标的回收器，该回收器基于标记-清除算法<br><img src="http://lishq.oss-cn-beijing.aliyuncs.com/github.io/84bcf767251547d63e02853ff3ae0e6f.png" alt="常见垃圾收集器"></li></ul><h3 id="CMS-GC"><a href="#CMS-GC" class="headerlink" title="CMS GC"></a>CMS GC</h3><ul><li>初始标记,仅仅标记一下GC Roots能直接关联到的对象，速度很快</li><li>concurrent-mark 并发标记，由前段标记过的绿色对象出发，所有可达到的对象都在本阶段标记</li><li>重新标记(修正并发标记期间因用户程序继续用作而导致标记产生变动的那一部分对象的标记记录)，暂停所有用户线程，重新扫描用户堆对象，进行可达性分析。注意，当前阶段以新生代对象为根来判断对象是否存活</li><li>并发清理，进行并发的垃圾清理</li></ul><p><img src="http://lishq.oss-cn-beijing.aliyuncs.com/github.io/6ada2f9cdd7659d73f6a233365dd410f.png" alt="CMS"></p><h5 id="常用优化"><a href="#常用优化" class="headerlink" title="常用优化"></a>常用优化</h5><ul><li>如果应用存在大量的短期对象，应该选择较大的年轻代；如果存在相对较多的持久对象，老年代应该适当增大。</li><li>CMS提供CMSScavengeBeforeRemark参数，用来保证Remark前强制进行一次Minor GC</li><li>通过把-XX:PermSize参数和-XX:MaxPermSize设置成一样，强制虚拟机在启动的时候就把永久代的容量固定下来，避免运行时自动扩容</li><li>CMS默认情况下不会回收Perm区，通过参数CMSPermGenSweepingEnabled、CMSClassUnloadingEnabled ，可以让CMS在Perm区容量不足时对其回收</li></ul><h3 id="G1-GC"><a href="#G1-GC" class="headerlink" title="G1 GC"></a>G1 GC</h3><p><img src="http://lishq.oss-cn-beijing.aliyuncs.com/github.io/6f923abac12e3fa3c96f13e285beeb19.png" alt="分区收集"></p><ul><li>初始标记———&gt;并发标记———&gt;最终标记———&gt;清理回收</li><li>并行与并发;分代收集;空间整理;可预测的停顿;运行期间不会产生内存空间碎片;它将整个Java堆划分为多个大小相等的独立区域(Region),虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分Region的集合</li></ul><h5 id="region"><a href="#region" class="headerlink" title="region"></a>region</h5><p>每个region被标记成eden, old, survivor, humongous，其中humongous代表巨型对象。<br><br>region大小设置 -XX:G1HeapRegionSize ，1，2，4，8，32M，默认值是堆的大小/2048</p><h5 id="yong-gc"><a href="#yong-gc" class="headerlink" title="yong gc"></a>yong gc</h5><p>一般对象均在eden区分配内存，除了humongous对象，当所有eden区域被耗尽内存时，触发yong gc，活跃对象copy到survivor区和old区中，空闲的region会被放入空闲列表<br><br>-XX:MaxGCPauseMillis 设置G1收集过程目标时间，默认值200ms<br><br>-XX:G1NewSizePercent 新生代最小值，默认值5%<br><br>-XX:G1MaxNewSizePercent 新生代最大值，默认值60%</p><h5 id="mixed-gc"><a href="#mixed-gc" class="headerlink" title="mixed gc"></a>mixed gc</h5><p>触发机制：当老年代的大小占整个堆大小百分比达到该阀值时，会触发一次mixed gc<br><br>执行过程：参考cms执行过程。类似。会优先考虑收益高的old区域执行gc。</p><h5 id="full-gc"><a href="#full-gc" class="headerlink" title="full gc"></a>full gc</h5><p>如果对象内存分配过快，mixed gc来不及执行，导致年轻代被占满，就会触发full gc，serial old gc，导致长时间的暂停时间。</p><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p>UseSerialGC:<br>client模式下，采用serial+serial Old组合<br><br>UseParNewGC:<br>常用ParNew+Serial Old组合<br><br>UseConcMarkSweepGC:<br>常用ParNew+CMS+Serial Old<br><br>UseParallelGC:<br>采用Parallel Scavenge+serial Old收集器<br><br>UseParallelOldGC:<br>采用Parallel Scavenge+Parallel Old组合</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h3&gt;&lt;p&gt;最近读了周志明先生写的深入理解jvm，不敢说理解有多深。总结以供回顾。&lt;/p&gt;

&lt;h3 id=&quot;自动内存管理机制&quot;&gt;&lt;a href=&quot;#自动内存管理机制&quot; class=&quot;headerlink&quot; title=&quot;自动内存管理机制&quot;&gt;&lt;/a&gt;自动内存管理机制&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;http://lishq.oss-cn-beijing.aliyuncs.com/github.io/6b0f6224a74263815dcbdd6bc0b71b76.png&quot; alt=&quot;内存自动管理机制&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Jvm" scheme="https://blog.tolvyou.cn/tags/Jvm/"/>
    
  </entry>
  
  <entry>
    <title>netty-reactor</title>
    <link href="https://blog.tolvyou.cn/2018/09/22/netty-reactor/"/>
    <id>https://blog.tolvyou.cn/2018/09/22/netty-reactor/</id>
    <published>2018-09-22T10:19:15.000Z</published>
    <updated>2018-10-29T07:49:31.436Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="Reactor模型"><a href="#Reactor模型" class="headerlink" title="Reactor模型"></a>Reactor模型</h3><p>大量网络框架采用reactor模型进行设计和开发，reactor模式基于事件驱动，特别适合处理海量的I/O事件。</p><h3 id="Reactor多线程模型"><a href="#Reactor多线程模型" class="headerlink" title="Reactor多线程模型"></a>Reactor<a href="https://blog.csdn.net/king866/article/details/54427447" target="_blank" rel="noopener">多线程模型</a></h3><p><img src="http://lishq.oss-cn-beijing.aliyuncs.com/github.io/ce86218219ff60c70d21e5f20c3c217e.jpg" alt="多线程模型"></p><ul><li>有专门的nio线程-acceptor线程用于监听服务端，接收客户端的tcp连接请求</li><li>网络io操作读写由一个nio线程池负责，包含一个队列和多个可用线程，由这些nio线程负责消息的读取，解码，编码，发送</li><li>一个nio线程可以同时处理n条链路，反之不可，防止出现并发操作问题</li></ul><p>一个nio线程监听和处理客户端连接可能会存在性能问题。</p><p>例如百万客户端连接，or 服务端需要对客户端握手进行安全认证，本身非常损耗性能。</p><p>为了解决性能问题，出现了主从reactor多线程模型。</p><a id="more"></a><h3 id="Netty中Reactor模型的实现"><a href="#Netty中Reactor模型的实现" class="headerlink" title="Netty中Reactor模型的实现"></a>Netty中Reactor模型的实现</h3><p><img src="http://lishq.oss-cn-beijing.aliyuncs.com/github.io/a094b188a9eff9b5da27a68315af3452.png" alt="netty-model"></p><p>特点</p><ul><li>服务端接收客户端的连接是一个独立的nio线程池</li><li>accptor线程池仅只用于客户端的登录，握手和安全认证，成功后，将链路注册到subReactor线程池上</li><li>相比nio创建更少的对象，更小的GC压力；</li></ul><p>执行过程</p><ul><li>从主线程中随机选择一个reactor线程作为accptor线程，用于绑定监听端口，接收客户端连接</li><li>accptor线程接收客户端连接请求后创建新的SocketChannel，将其注册到主线程池的其他reactor线程，其负责接入认证，黑白名单，握手等操作</li><li>将SocketChannel从主reactor线程摘除，重新注册到sub reactor线程池上，用于读取，解码，编码，发送操作</li></ul><h3 id="Netty中几个重要概念及其关系"><a href="#Netty中几个重要概念及其关系" class="headerlink" title="Netty中几个重要概念及其关系"></a>Netty中几个重要概念及其关系</h3><pre>1.EventLoopGroup2.EventLoop3.boss/worker4.channel5.event(inbound/outbound)6.pipeline7.handler--------------------------------------------------------------------1.EventLoopGroup中包含一组EventLoop2.EventLoop的大致数据结构是    a.一个任务队列    b.一个延迟任务队列(schedule)    c.EventLoop绑定了一个Thread, 这直接避免了pipeline中的线程竞争    d.每个EventLoop有一个Selector, boss用Selector处理accept, worker用Selector处理read,write等3.EventLoop执行的任务分为两大类:IO任务和非IO任务.    a.IO任务比如: OP_ACCEPT、OP_CONNECT、OP_READ、OP_WRITE    b.非IO任务比如: bind、channelActive等4.boss可简单理解为Reactor模式中的mainReactor的角色, worker可简单理解为subReactor的角色    a.boss和worker共用EventLoop的代码逻辑    b.在不bind多端口的情况下bossEventLoopGroup中只需要包含一个EventLoop    c.workerEventLoopGroup中一般包含多个EventLoop    d.netty server启动后会把一个监听套接字ServerSocketChannel注册到bossEventLoop中    e.bossEventLoop一个主要责任就是负责accept连接(channel)然后dispatch到worker    f.worker接到boss转发的channel后负责处理此chanel后续的read,write等event5.channel分两大类ServerChannel和channel, ServerChannel对应着监听套接字(ServerSocketChannel), channel对应着一个网络连接6.有两大类event:inbound/outbound(上行/下行)7.event按照一定顺序在pipeline里面流转, 流转顺序参见下图8.pipeline是责任链模式的设计，里面有多个handler的,上行事件顺序执行pipeline，下行事件逆序执行pipeline。 同时每个handler节点过滤在pipeline中流转的event, 如果判定需要自己处理这个event,则处理(用户可以在pipeline中添加自己的handler)--------------------------------------------------------------------                                            I/O Request                                            via Channel or                                        ChannelHandlerContext                                                    |+---------------------------------------------------+---------------+|                           ChannelPipeline         |               ||                                                  \|/              ||    +---------------------+            +-----------+----------+    ||    | Inbound Handler  N  |            | Outbound Handler  1  |    ||    +----------+----------+            +-----------+----------+    ||              /|\                                  |               ||               |                                  \|/              ||    +----------+----------+            +-----------+----------+    ||    | Inbound Handler N-1 |            | Outbound Handler  2  |    ||    +----------+----------+            +-----------+----------+    ||              /|\                                  .               ||               .                                   .               || ChannelHandlerContext.fireIN_EVT() ChannelHandlerContext.OUT_EVT()||        [ method call]                       [method call]         ||               .                                   .               ||               .                                  \|/              ||    +----------+----------+            +-----------+----------+    ||    | Inbound Handler  2  |            | Outbound Handler M-1 |    ||    +----------+----------+            +-----------+----------+    ||              /|\                                  |               ||               |                                  \|/              ||    +----------+----------+            +-----------+----------+    ||    | Inbound Handler  1  |            | Outbound Handler  M  |    ||    +----------+----------+            +-----------+----------+    ||              /|\                                  |               |+---------------+-----------------------------------+---------------+                |                                  \|/+---------------+-----------------------------------+---------------+|               |                                   |               ||       [ Socket.read() ]                    [ Socket.write() ]     ||                                                                   ||  Netty Internal I/O Threads (Transport Implementation)            |+-------------------------------------------------------------------+</pre><h3 id="NioEventLoop的设计原理"><a href="#NioEventLoop的设计原理" class="headerlink" title="NioEventLoop的设计原理"></a>NioEventLoop的设计原理</h3><p><img src="http://lishq.oss-cn-beijing.aliyuncs.com/github.io/05cabcc6c3abcfc32fbc49feec4e0e41.png" alt="NioEventLoop"></p><ul><li><p>消息的读取，解码，后续handler的执行，始终由NioEventLoop负责，整个流程不会存在上下文的切换</p></li><li><p>一个客户端连接只注册到一个NioEventLoop上，避免了多个IO线程并发操作</p></li><li><p>一个NioEventLoop聚合了一个多路复用器Selector，因此可以处理成千上万的客户端连接</p></li><li><p>netty通过串行化线程水平并行处理，既能提升了多核并发处理能力，也避免了上下文切换和并发保护带来的额外性能损耗</p></li></ul><p>Code实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">newchild()</span><br><span class="line"><span class="function"><span class="keyword">protected</span> EventLoop <span class="title">newChild</span><span class="params">(Executor executor, Object... args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> NioEventLoop(<span class="keyword">this</span>, executor, (SelectorProvider) args[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">构造方法:</span><br><span class="line">NioEventLoop(NioEventLoopGroup parent, Executor executor, SelectorProvider selectorProvider) &#123;</span><br><span class="line">    <span class="keyword">super</span>(parent, executor, <span class="keyword">false</span>);</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    provider = selectorProvider;</span><br><span class="line">    selector = openSelector();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">父类构造方法:</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">SingleThreadEventExecutor</span><span class="params">(EventExecutorGroup parent, Executor executor, <span class="keyword">boolean</span> addTaskWakesUp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(parent);</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="keyword">this</span>.addTaskWakesUp = addTaskWakesUp;</span><br><span class="line">    <span class="keyword">this</span>.executor = executor;</span><br><span class="line">    taskQueue = newTaskQueue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><pre>大致流程：1.newChild():创建NioEventLoop线程,首先是打开一个selector2.接着在父类中会构造一个MpscQueue:taskQueue用于外部线程执行(非IO事件)Netty任务的时候,如果判断不是在NioEventLoop对应线程里面执行,非IO事件都是先丢到这个MPSC队列再由worker线程去异步执行,PlatformDependent.newMpscQueue(maxPendingTasks)创建MpscQueue保存异步任务队列;3.创建一个selector:provider.openSelector()创建selector轮询初始化连接4.接着DISABLE_KEYSET_OPTIMIZATION是判断是否需要对sun.nio.ch.SelectorImpl中的selectedKeys进行优化, 不做配置的话默认需要优化.</pre><p>哪些优化呢：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectedSelectionKeySet</span> <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">SelectionKey</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    SelectionKey[] keys;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    SelectedSelectionKeySet() &#123;</span><br><span class="line">        keys = <span class="keyword">new</span> SelectionKey[<span class="number">1024</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(SelectionKey o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        keys[size++] = o;</span><br><span class="line">        <span class="keyword">if</span> (size == keys.length) &#123;</span><br><span class="line">            increaseCapacity();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><pre>  原来SelectorImpl中的selectedKeys和publicSelectedKeys是个HashSet, 新的数据结构是数组, 初始大小1024。      a.避免了HashSet的频繁自动扩容。      b.屏蔽了remove、contains、iterator这些不需要的功能。      c.HashSet用拉链法解决哈希冲突, 也就是说它的数据结构是数组+链表,   而我们又知道, 对于selectedKeys, 最重要的操作是遍历全部元素, 但是数组+链表的数据结构对于cpu的 cache line 来说肯定是不够友好的.如果是直接遍历数组的话, cpu会把数组中相邻的元素一次加载到同一个cache line里面(一个cache line的大小一般是64个字节), 所以遍历数组无疑效率更高.</pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Reactor模型&quot;&gt;&lt;a href=&quot;#Reactor模型&quot; class=&quot;headerlink&quot; title=&quot;Reactor模型&quot;&gt;&lt;/a&gt;Reactor模型&lt;/h3&gt;&lt;p&gt;大量网络框架采用reactor模型进行设计和开发，reactor模式基于事件驱动，特别适合处理海量的I/O事件。&lt;/p&gt;

&lt;h3 id=&quot;Reactor多线程模型&quot;&gt;&lt;a href=&quot;#Reactor多线程模型&quot; class=&quot;headerlink&quot; title=&quot;Reactor多线程模型&quot;&gt;&lt;/a&gt;Reactor&lt;a href=&quot;https://blog.csdn.net/king866/article/details/54427447&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;多线程模型&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;http://lishq.oss-cn-beijing.aliyuncs.com/github.io/ce86218219ff60c70d21e5f20c3c217e.jpg&quot; alt=&quot;多线程模型&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;有专门的nio线程-acceptor线程用于监听服务端，接收客户端的tcp连接请求&lt;/li&gt;
&lt;li&gt;网络io操作读写由一个nio线程池负责，包含一个队列和多个可用线程，由这些nio线程负责消息的读取，解码，编码，发送&lt;/li&gt;
&lt;li&gt;一个nio线程可以同时处理n条链路，反之不可，防止出现并发操作问题&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一个nio线程监听和处理客户端连接可能会存在性能问题。&lt;/p&gt;

&lt;p&gt;例如百万客户端连接，or 服务端需要对客户端握手进行安全认证，本身非常损耗性能。&lt;/p&gt;

&lt;p&gt;为了解决性能问题，出现了主从reactor多线程模型。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Netty" scheme="https://blog.tolvyou.cn/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>Java 通配符替换的几种实现方式</title>
    <link href="https://blog.tolvyou.cn/2018/05/22/java-wildcard-achieve/"/>
    <id>https://blog.tolvyou.cn/2018/05/22/java-wildcard-achieve/</id>
    <published>2018-05-22T09:34:10.000Z</published>
    <updated>2018-05-22T11:50:39.521Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="Java常用通配符的替换及定制实现。"><a href="#Java常用通配符的替换及定制实现。" class="headerlink" title="Java常用通配符的替换及定制实现。"></a>Java常用通配符的替换及定制实现。</h3><ul><li>String.format(“hi, %s”, “uname”)</li><li>log.info(“hi, {}”, “uname”)</li></ul><h3 id="自行实现"><a href="#自行实现" class="headerlink" title="自行实现"></a>自行实现</h3><p>思路：</p><ul><li>方法体 format(Object… value)；</li><li>实现方式：字符匹配替换，Matcher类find。<br><code>Pattern类的作用在于编译正则表达式后创建一个匹配模式.</code><br><code>Matcher类使用Pattern实例提供的模式信息对正则表达式进行匹配.</code><br><code>matcher.appendReplacement() 与 matcher.appendTail().</code><br>前者是将当前匹配子串替换为指定字符串，并且将替换后的子串，以及其之前到上次匹配子串之后的字符串段添加到一个 StringBuffer 对象里。后者则将最后一次匹配工作后剩余的字符串添加到一个 StringBuffer 对象里。</li></ul><p>Code实现：<br><a id="more"></a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> StringBuilder buffer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String namedParameterPrefix = <span class="string">":"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String regex = <span class="string">"[&#123;]\\d*[&#125;]"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Pattern fsPattern = Pattern.compile(regex);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StringWrapper</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    buffer = <span class="keyword">new</span> StringBuilder(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StringWrapper</span><span class="params">(StringBuilder s)</span></span>&#123;</span><br><span class="line">buffer = s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Map&lt;String, Object&gt; namedParameter = <span class="keyword">new</span> HashMap&lt;String, Object&gt;(<span class="number">32</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> StringWrapper <span class="title">setParameter</span><span class="params">(String namedParameter, Object value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.namedParameter.put(namedParameter, value);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> StringWrapper <span class="title">setProperties</span><span class="params">(Map&lt;String, Object&gt; map)</span> </span>&#123;</span><br><span class="line">    namedParameter = map;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">format</span><span class="params">(Object... value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (namedParameter.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        Set&lt;String&gt; keySet = namedParameter.keySet();</span><br><span class="line">        <span class="keyword">for</span> (String key : keySet) &#123;</span><br><span class="line">            Object objValue = namedParameter.get(key);</span><br><span class="line">            String parameterName = namedParameterPrefix + key;</span><br><span class="line">            buffer = <span class="keyword">new</span> StringBuilder(buffer.toString().replace(parameterName, </span><br><span class="line">            (objValue == <span class="keyword">null</span> ? <span class="string">""</span> : objValue.toString())));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> len = value.length;</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> buffer.toString();</span><br><span class="line">    StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    Matcher matcher = fsPattern.matcher(buffer);</span><br><span class="line">    <span class="keyword">while</span> (matcher.find()) &#123;</span><br><span class="line">        String group = matcher.group();</span><br><span class="line">        <span class="keyword">int</span> index = getIndex(group);</span><br><span class="line">        <span class="keyword">if</span> (index &gt; len - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"format的输入参数没有第"</span> + (index + <span class="number">1</span>) + <span class="string">"个参数值！"</span>);</span><br><span class="line">        Object objValue = value[index];</span><br><span class="line">        matcher.appendReplacement(sb, (objValue == <span class="keyword">null</span> ? <span class="string">""</span> : objValue.toString()));</span><br><span class="line">    &#125;</span><br><span class="line">    matcher.appendTail(sb);</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getIndex</span><span class="params">(String group)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (group == <span class="keyword">null</span> || group.trim().equals(<span class="string">""</span>))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"regex匹配的group为空！"</span>);</span><br><span class="line">    <span class="keyword">int</span> len = group.length();</span><br><span class="line">    <span class="keyword">return</span> NumberUtils.toInt(group.substring(<span class="number">1</span>, len - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String ttt = <span class="string">"hello world, :username, Time：&#123;0&#125;！"</span>;</span><br><span class="line">    StringWrapper w = <span class="keyword">new</span> StringWrapper(ttt);</span><br><span class="line">    System.out.println(w.setParameter(<span class="string">"username"</span>, <span class="string">"lsq"</span>).format(<span class="keyword">new</span> Date().getTime()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="执行结果如下"><a href="#执行结果如下" class="headerlink" title="执行结果如下"></a>执行结果如下</h2><pre><code>hello world, lsq, Time：1526978430709！</code></pre><h2 id="String-format实现过程"><a href="#String-format实现过程" class="headerlink" title="String.format实现过程"></a>String.format实现过程</h2><ul><li>分析源码得到其通过<a href="http://tool.oschina.net/uploads/apidocs/jdk-zh/java/util/Formatter.html" target="_blank" rel="noopener">java.util.Formatter</a>实现。</li><li>代码比较简洁，贴出用来作为对比。</li><li>先通过Matcher从字符串中查找分隔符，拆分成FOrmatString数组，在进行分段print输出。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">format</span><span class="params">(String format, Object... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Formatter().format(format, args).toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Formatter <span class="title">format</span><span class="params">(Locale l, String format, Object ... args)</span> </span>&#123;</span><br><span class="line">    ensureOpen();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// index of last argument referenced</span></span><br><span class="line">    <span class="keyword">int</span> last = -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// last ordinary index</span></span><br><span class="line">    <span class="keyword">int</span> lasto = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    FormatString[] fsa = parse(format);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; fsa.length; i++) &#123;</span><br><span class="line">        FormatString fs = fsa[i];</span><br><span class="line">        <span class="keyword">int</span> index = fs.index();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">switch</span> (index) &#123;</span><br><span class="line">            <span class="keyword">case</span> -<span class="number">2</span>:  <span class="comment">// fixed string, "%n", or "%%"</span></span><br><span class="line">                fs.print(<span class="keyword">null</span>, l);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> -<span class="number">1</span>:  <span class="comment">// relative index</span></span><br><span class="line">                <span class="keyword">if</span> (last &lt; <span class="number">0</span> || (args != <span class="keyword">null</span> &amp;&amp; last &gt; args.length - <span class="number">1</span>))</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> MissingFormatArgumentException(fs.toString());</span><br><span class="line">                fs.print((args == <span class="keyword">null</span> ? <span class="keyword">null</span> : args[last]), l);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:  <span class="comment">// ordinary index</span></span><br><span class="line">                lasto++;</span><br><span class="line">                last = lasto;</span><br><span class="line">                <span class="keyword">if</span> (args != <span class="keyword">null</span> &amp;&amp; lasto &gt; args.length - <span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> MissingFormatArgumentException(fs.toString());</span><br><span class="line">                fs.print((args == <span class="keyword">null</span> ? <span class="keyword">null</span> : args[lasto]), l);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:  <span class="comment">// explicit index</span></span><br><span class="line">                last = index - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (args != <span class="keyword">null</span> &amp;&amp; last &gt; args.length - <span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> MissingFormatArgumentException(fs.toString());</span><br><span class="line">                fs.print((args == <span class="keyword">null</span> ? <span class="keyword">null</span> : args[last]), l);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException x) &#123;</span><br><span class="line">            lastException = x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="org-slf4j-Logger-info实现过程"><a href="#org-slf4j-Logger-info实现过程" class="headerlink" title="org.slf4j.Logger.info实现过程"></a>org.slf4j.Logger.info实现过程</h2><ul><li><p>org.slf4j.helpers.MessageFormatter.arrayFormat()</p><p>  <img src="https://eagle-file.oss-cn-shanghai.aliyuncs.com/img/java/java-wildcard-achieve.png" alt="逻辑"></p></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p>Formatter是广泛被用到的格式化方法，它能让一些东西变得更加有规范，很多超市小票，信息单，用这个方法来格式化就显得很不错。</p></li><li><p>String.format 这个方法很实用，但如果是大批量进行字符串格式化，就需要考虑到性能方面的问题，因为每次调用 format() 方法都会 new 一个 Formatter 对象。而在 Java 中频繁创建对象需要大量时间，而且还要花时间对这些对象进行GC。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Java常用通配符的替换及定制实现。&quot;&gt;&lt;a href=&quot;#Java常用通配符的替换及定制实现。&quot; class=&quot;headerlink&quot; title=&quot;Java常用通配符的替换及定制实现。&quot;&gt;&lt;/a&gt;Java常用通配符的替换及定制实现。&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;String.format(“hi, %s”, “uname”)&lt;/li&gt;
&lt;li&gt;log.info(“hi, {}”, “uname”)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;自行实现&quot;&gt;&lt;a href=&quot;#自行实现&quot; class=&quot;headerlink&quot; title=&quot;自行实现&quot;&gt;&lt;/a&gt;自行实现&lt;/h3&gt;&lt;p&gt;思路：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;方法体 format(Object… value)；&lt;/li&gt;
&lt;li&gt;实现方式：字符匹配替换，Matcher类find。&lt;br&gt;&lt;code&gt;Pattern类的作用在于编译正则表达式后创建一个匹配模式.&lt;/code&gt;&lt;br&gt;&lt;code&gt;Matcher类使用Pattern实例提供的模式信息对正则表达式进行匹配.&lt;/code&gt;&lt;br&gt;&lt;code&gt;matcher.appendReplacement() 与 matcher.appendTail().&lt;/code&gt;&lt;br&gt;前者是将当前匹配子串替换为指定字符串，并且将替换后的子串，以及其之前到上次匹配子串之后的字符串段添加到一个 StringBuffer 对象里。后者则将最后一次匹配工作后剩余的字符串添加到一个 StringBuffer 对象里。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Code实现：&lt;br&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://blog.tolvyou.cn/tags/Java/"/>
    
  </entry>
  
</feed>
